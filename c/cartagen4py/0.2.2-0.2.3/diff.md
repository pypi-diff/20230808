# Comparing `tmp/cartagen4py-0.2.2-py3-none-any.whl.zip` & `tmp/cartagen4py-0.2.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,54 @@
-Zip file size: 44154 bytes, number of entries: 40
+Zip file size: 60663 bytes, number of entries: 52
 -rw-r--r--  2.0 unx      183 b- defN 23-May-16 13:17 cartagen4py/__init__.py
--rw-r--r--  2.0 unx      134 b- defN 23-May-15 08:34 cartagen4py/algorithms/__init__.py
+-rw-r--r--  2.0 unx      179 b- defN 23-Jul-27 11:49 cartagen4py/algorithms/__init__.py
 -rw-r--r--  2.0 unx      244 b- defN 23-May-15 08:34 cartagen4py/algorithms/buildings/__init__.py
--rw-r--r--  2.0 unx     4500 b- defN 23-Jul-10 07:34 cartagen4py/algorithms/buildings/amalgamation.py
+-rw-r--r--  2.0 unx     4579 b- defN 23-Jul-20 15:09 cartagen4py/algorithms/buildings/amalgamation.py
 -rw-r--r--  2.0 unx     7791 b- defN 23-Jul-18 08:14 cartagen4py/algorithms/buildings/random_displacement.py
 -rw-r--r--  2.0 unx     8144 b- defN 23-May-24 14:53 cartagen4py/algorithms/buildings/simplification.py
 -rw-r--r--  2.0 unx    15705 b- defN 23-Jul-10 07:34 cartagen4py/algorithms/buildings/squaring.py
 -rw-r--r--  2.0 unx       55 b- defN 23-May-12 12:21 cartagen4py/algorithms/general/__init__.py
--rw-r--r--  2.0 unx    43733 b- defN 23-Jul-18 08:59 cartagen4py/algorithms/general/constraint.py
+-rw-r--r--  2.0 unx    50721 b- defN 23-Jul-24 10:01 cartagen4py/algorithms/general/constraint.py
 -rw-r--r--  2.0 unx      120 b- defN 23-May-12 12:23 cartagen4py/algorithms/lines/__init__.py
 -rw-r--r--  2.0 unx     5307 b- defN 23-Jun-21 09:43 cartagen4py/algorithms/lines/line_simplification.py
 -rw-r--r--  2.0 unx     3095 b- defN 23-May-24 14:53 cartagen4py/algorithms/lines/line_smoothing.py
--rw-r--r--  2.0 unx      162 b- defN 23-May-16 08:50 cartagen4py/data_enrichment/__init__.py
+-rw-r--r--  2.0 unx      122 b- defN 23-Aug-08 09:09 cartagen4py/algorithms/network/__init__.py
+-rw-r--r--  2.0 unx    11009 b- defN 23-Aug-07 13:28 cartagen4py/algorithms/network/branching_crossroads.py
+-rw-r--r--  2.0 unx     5423 b- defN 23-Aug-07 13:47 cartagen4py/algorithms/network/roundabouts.py
+-rw-r--r--  2.0 unx      212 b- defN 23-Jul-27 09:38 cartagen4py/data_enrichment/__init__.py
 -rw-r--r--  2.0 unx     7219 b- defN 23-Jul-05 09:28 cartagen4py/data_enrichment/building_measures.py
 -rw-r--r--  2.0 unx    14259 b- defN 23-Jul-10 07:34 cartagen4py/data_enrichment/stroke.py
 -rw-r--r--  2.0 unx     1018 b- defN 23-May-12 11:58 cartagen4py/data_enrichment/urban_areas.py
+-rw-r--r--  2.0 unx      261 b- defN 23-Aug-08 09:11 cartagen4py/data_enrichment/network/__init__.py
+-rw-r--r--  2.0 unx    10538 b- defN 23-Aug-08 13:16 cartagen4py/data_enrichment/network/branching_crossroads.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Aug-08 07:39 cartagen4py/data_enrichment/network/dead_ends.py
+-rw-r--r--  2.0 unx     3941 b- defN 23-Aug-08 14:03 cartagen4py/data_enrichment/network/dual_carriageways.py
+-rw-r--r--  2.0 unx     2042 b- defN 23-Aug-08 12:34 cartagen4py/data_enrichment/network/roundabouts.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-01 13:47 cartagen4py/evaluation/__init__.py
 -rw-r--r--  2.0 unx      238 b- defN 23-Mar-01 13:47 cartagen4py/evaluation/constraint_satisfaction.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-01 13:47 cartagen4py/processes/__init__.py
--rw-r--r--  2.0 unx      210 b- defN 23-May-15 08:50 cartagen4py/utils/__init__.py
+-rw-r--r--  2.0 unx      250 b- defN 23-Jul-24 12:36 cartagen4py/utils/__init__.py
 -rw-r--r--  2.0 unx     3766 b- defN 23-Jun-21 15:05 cartagen4py/utils/plot_utils.py
 -rw-r--r--  2.0 unx       49 b- defN 23-May-15 08:52 cartagen4py/utils/clustering/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 23-Mar-30 13:41 cartagen4py/utils/clustering/dbscan.py
--rw-r--r--  2.0 unx      189 b- defN 23-May-15 08:51 cartagen4py/utils/geometry/__init__.py
--rw-r--r--  2.0 unx      615 b- defN 23-Jun-21 15:05 cartagen4py/utils/geometry/angle.py
+-rw-r--r--  2.0 unx      240 b- defN 23-Jul-26 10:00 cartagen4py/utils/geometry/__init__.py
+-rw-r--r--  2.0 unx     2198 b- defN 23-Jul-31 13:56 cartagen4py/utils/geometry/angle.py
+-rw-r--r--  2.0 unx      588 b- defN 23-Jul-27 12:38 cartagen4py/utils/geometry/distances.py
 -rw-r--r--  2.0 unx     1327 b- defN 23-Mar-21 13:10 cartagen4py/utils/geometry/extent.py
--rw-r--r--  2.0 unx     3329 b- defN 23-Jun-21 15:05 cartagen4py/utils/geometry/line.py
+-rw-r--r--  2.0 unx     4291 b- defN 23-Aug-07 13:10 cartagen4py/utils/geometry/line.py
 -rw-r--r--  2.0 unx     3167 b- defN 23-May-12 11:54 cartagen4py/utils/geometry/segment.py
 -rw-r--r--  2.0 unx       91 b- defN 23-May-15 08:51 cartagen4py/utils/math/__init__.py
 -rw-r--r--  2.0 unx     4693 b- defN 23-Jul-10 07:34 cartagen4py/utils/math/morphology.py
--rw-r--r--  2.0 unx      474 b- defN 23-May-12 11:28 cartagen4py/utils/math/vector.py
+-rw-r--r--  2.0 unx      474 b- defN 23-Jul-25 15:17 cartagen4py/utils/math/vector.py
+-rw-r--r--  2.0 unx       91 b- defN 23-Aug-08 12:58 cartagen4py/utils/network/__init__.py
+-rw-r--r--  2.0 unx     1441 b- defN 23-Aug-08 14:41 cartagen4py/utils/network/faces.py
+-rw-r--r--  2.0 unx     5416 b- defN 23-Aug-07 11:50 cartagen4py/utils/network/roads.py
 -rw-r--r--  2.0 unx      106 b- defN 23-May-15 08:50 cartagen4py/utils/partitioning/__init__.py
--rw-r--r--  2.0 unx     2183 b- defN 23-Jul-18 07:39 cartagen4py/utils/partitioning/network.py
+-rw-r--r--  2.0 unx     2301 b- defN 23-Jul-25 13:07 cartagen4py/utils/partitioning/network.py
 -rw-r--r--  2.0 unx      334 b- defN 23-May-15 09:06 cartagen4py/utils/partitioning/quadtree.py
 -rw-r--r--  2.0 unx       54 b- defN 23-May-16 08:51 cartagen4py/utils/tessellation/__init__.py
 -rw-r--r--  2.0 unx     3721 b- defN 23-May-16 07:42 cartagen4py/utils/tessellation/hexagonal.py
--rw-r--r--  2.0 unx      914 b- defN 23-Jul-18 09:00 cartagen4py-0.2.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-18 09:00 cartagen4py-0.2.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 23-Jul-18 09:00 cartagen4py-0.2.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3772 b- defN 23-Jul-18 09:00 cartagen4py-0.2.2.dist-info/RECORD
-40 files, 141005 bytes uncompressed, 37938 bytes compressed:  73.1%
+-rw-r--r--  2.0 unx      914 b- defN 23-Aug-08 14:41 cartagen4py-0.2.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-08 14:41 cartagen4py-0.2.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 23-Aug-08 14:41 cartagen4py-0.2.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4996 b- defN 23-Aug-08 14:41 cartagen4py-0.2.3.dist-info/RECORD
+52 files, 193017 bytes uncompressed, 52445 bytes compressed:  72.8%
```

## zipnote {}

```diff
@@ -30,26 +30,50 @@
 
 Filename: cartagen4py/algorithms/lines/line_simplification.py
 Comment: 
 
 Filename: cartagen4py/algorithms/lines/line_smoothing.py
 Comment: 
 
+Filename: cartagen4py/algorithms/network/__init__.py
+Comment: 
+
+Filename: cartagen4py/algorithms/network/branching_crossroads.py
+Comment: 
+
+Filename: cartagen4py/algorithms/network/roundabouts.py
+Comment: 
+
 Filename: cartagen4py/data_enrichment/__init__.py
 Comment: 
 
 Filename: cartagen4py/data_enrichment/building_measures.py
 Comment: 
 
 Filename: cartagen4py/data_enrichment/stroke.py
 Comment: 
 
 Filename: cartagen4py/data_enrichment/urban_areas.py
 Comment: 
 
+Filename: cartagen4py/data_enrichment/network/__init__.py
+Comment: 
+
+Filename: cartagen4py/data_enrichment/network/branching_crossroads.py
+Comment: 
+
+Filename: cartagen4py/data_enrichment/network/dead_ends.py
+Comment: 
+
+Filename: cartagen4py/data_enrichment/network/dual_carriageways.py
+Comment: 
+
+Filename: cartagen4py/data_enrichment/network/roundabouts.py
+Comment: 
+
 Filename: cartagen4py/evaluation/__init__.py
 Comment: 
 
 Filename: cartagen4py/evaluation/constraint_satisfaction.py
 Comment: 
 
 Filename: cartagen4py/processes/__init__.py
@@ -69,14 +93,17 @@
 
 Filename: cartagen4py/utils/geometry/__init__.py
 Comment: 
 
 Filename: cartagen4py/utils/geometry/angle.py
 Comment: 
 
+Filename: cartagen4py/utils/geometry/distances.py
+Comment: 
+
 Filename: cartagen4py/utils/geometry/extent.py
 Comment: 
 
 Filename: cartagen4py/utils/geometry/line.py
 Comment: 
 
 Filename: cartagen4py/utils/geometry/segment.py
@@ -87,14 +114,23 @@
 
 Filename: cartagen4py/utils/math/morphology.py
 Comment: 
 
 Filename: cartagen4py/utils/math/vector.py
 Comment: 
 
+Filename: cartagen4py/utils/network/__init__.py
+Comment: 
+
+Filename: cartagen4py/utils/network/faces.py
+Comment: 
+
+Filename: cartagen4py/utils/network/roads.py
+Comment: 
+
 Filename: cartagen4py/utils/partitioning/__init__.py
 Comment: 
 
 Filename: cartagen4py/utils/partitioning/network.py
 Comment: 
 
 Filename: cartagen4py/utils/partitioning/quadtree.py
@@ -102,20 +138,20 @@
 
 Filename: cartagen4py/utils/tessellation/__init__.py
 Comment: 
 
 Filename: cartagen4py/utils/tessellation/hexagonal.py
 Comment: 
 
-Filename: cartagen4py-0.2.2.dist-info/METADATA
+Filename: cartagen4py-0.2.3.dist-info/METADATA
 Comment: 
 
-Filename: cartagen4py-0.2.2.dist-info/WHEEL
+Filename: cartagen4py-0.2.3.dist-info/WHEEL
 Comment: 
 
-Filename: cartagen4py-0.2.2.dist-info/top_level.txt
+Filename: cartagen4py-0.2.3.dist-info/top_level.txt
 Comment: 
 
-Filename: cartagen4py-0.2.2.dist-info/RECORD
+Filename: cartagen4py-0.2.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cartagen4py/algorithms/__init__.py

```diff
@@ -1,3 +1,4 @@
 from cartagen4py.algorithms.buildings import *
 from cartagen4py.algorithms.lines import *
-from cartagen4py.algorithms.general import *
+from cartagen4py.algorithms.general import *
+from cartagen4py.algorithms.network import *
```

## cartagen4py/algorithms/buildings/amalgamation.py

```diff
@@ -12,15 +12,14 @@
 def morphological_amalgamation(buildings, buffer_size, edge_length):
     output_collection = []
     clusters = []
     multipolygon = MultiPolygon(buildings)
 
     # make a morphological closing on the multipolygon
     closed = closing_multi_polygon(multipolygon, buffer_size, cap_style=2)
-    print(closed)
     merged = opening(closed, buffer_size, cap_style=2)
 
     if(merged.geom_type == 'Polygon'):
         clusters.append(merged)
     elif (merged.geom_type == 'MultiPolygon'):
         for simple in merged.geoms:
             clusters.append(simple)
@@ -64,15 +63,15 @@
         if(angle < math.pi/4):
             # offset case
             # create a vector from the edge
             vector = Vector2D(nextEdge)
             # keep last vertex of final_coords in memory
             last_vertex = final_coords[len(final_coords)-1]
             # remove the last two vertices
-            l_element = len(tuple)-2
+            l_element = len(final_coords)-2
             final_coords = final_coords[:l_element]
             # get the antepenultimate vertex of final_coords (which is now the last)
             antepenultimate = final_coords[len(final_coords)-1]
             # translate this vertex with the vector
             translated = vector.translate(Point(antepenultimate))
             # add translated and then lastVertex to the list of vertices
             final_coords.append(translated.coords)
@@ -80,27 +79,28 @@
         elif(angle < 3*math.pi/4):
             # it is a corner case
             # get the intersection point of previousEdge and nextEdge considered as straight lines
             intersection = previousEdge.straight_line_intersection(nextEdge)
             # keep last vertex of final_coords in memory
             last_vertex = final_coords[len(final_coords)-1]
             # remove last vertex
-            # TODO
+            l_element = len(final_coords)-1
+            final_coords = final_coords[:l_element]
             # add intersection and then lastVertex to the list of vertices
-            final_coords.append(intersection.coords)
+            final_coords.append(intersection.coords[0])
             final_coords.append(last_vertex)
         else:
             # intrusion or protrusion case
             # create a vector from the edge
             vector = Vector2D(nextEdge)
             # remove the last two vertices
-            l_element = len(tuple)-2
+            l_element = len(final_coords)-2
             final_coords = final_coords[:l_element]
             # get the antepenultimate vertex of final_coords (which is now the last)
             antepenultimate = final_coords[len(final_coords)-1]
             # translate this vertex with the vector
             translated = vector.translate(Point(antepenultimate))
-            final_coords.append(intersection.coords)
+            final_coords.append(intersection.coords[0])
             final_coords.append(nextEdge.point2)
     
     return Polygon(final_coords)
```

## cartagen4py/algorithms/general/constraint.py

```diff
@@ -1,36 +1,42 @@
 # This is an implementation of the least squares method proposed by Lars E. Harrie (1999)
-
-import shapely, pprint, geopandas
+from collections import Counter
+import shapely, pprint, geopandas, math
 import numpy as np
 from cartagen4py.utils.partitioning.network import network_partition
 np.set_printoptions(suppress=True)
 
 class ConstraintMethod:
     """
     Initialize constraint method object
     Parameters
     ----------
-    max_iteration : int optional
+    max_iteration int optional
         This is the maximum number of iteration before breaking the loop. If constraints and weights are correctly set, the norm tolerance threshold should be reached before the maximum number of iteration.
         Default value is set to 1000.
     norm_tolerance : float optional
         The threshold below which the norm of the resulting point matrix is acceptable enough to break the iteration loop.
         The default value is set to 0.05.
+    same_object_conflicts : boolean optional
+        Set if shapes of the same object have spatial conflicts.
+        The default value is set to True.
+    crossing_node_threshold : int optional
+        When two lines intersects, define the number of nodes from the intersection on wich spatial conflicts between those two lines doesn't apply.
+        The default value is set to 7.
     verbose : boolean optional
         For debugging purposes, choose to print some key values while the constraint method is calculated.
         Default set to False.
     """
-    def __init__(self, max_iteration=1000, norm_tolerance=0.05, verbose=False):
+    def __init__(self, max_iteration=1000, norm_tolerance=0.05, same_object_conflicts=True, crossing_node_threshold=7, verbose=False):
         self.MAX_ITER = max_iteration
         self.NORM_TOLERANCE = norm_tolerance
+        self.SAME_OBJECT_CONFLICTS = same_object_conflicts
+        self.CROSSING_NODE_THRESHOLD = crossing_node_threshold
         self.VERBOSE = verbose
 
-        self.__EXPORT_SPATIAL_DEBUG = False
-
         self.__ALLOWED_CONSTRAINTS = {
             'Point': ['movement'],
             'LineString': ['movement', 'stiffness', 'curvature'],
             'Polygon': ['movement', 'stiffness', 'curvature']
         }
 
         # Create dummy arrays for distances and conflicts weights
@@ -42,31 +48,28 @@
         # The same list of objects once the generalization has been made
         self.__RESULTS = []
         # Stores weights as entered by the user with the add() method
         self.__WEIGHTS = []
         # Stores the number of different shapes
         self.__SHAPE_COUNT = 0
         
-        # Stores all points of all objects
-        self.__points = []
         # Stores all points of all objects in nested lists of shapes
         self.__shapes = []
+        self.__points = []
 
         # Stores points influenced by specific constraints
         self.__constraints = {
             'movement': [],
             'stiffness': [],
-            'curvature': []
+            'curvature': [],
+            # Nodes and links will be respectively populated with node to node and node to link spatial conflicts
+            'nodes': [],
+            'links': []
         }
 
-        # Nodes and links will be respectively populated with node to node and node to link spatial conflicts
-        self.__nodes = []
-        self.__links = []
-
-
     def add(self, *objects, **weights):
         """
         Add one or multiple geographic object for preparation before the generalization. If multiple objects are provided, they must have the same geometry type.
         Parameters
         ----------
         object : **Geopandas**, *GeoSerie*.
             One or multiple GeoSerie of geographic objects, can be points, lines or polygons (if multigeometry are provided, they will be exploded).
@@ -191,23 +194,16 @@
         """
         Launch the constraint generalization on the added objects.
         """
         # Checks if objects are present
         if len(self.__OBJECTS) < 1:
             raise Exception('No objects provided, cannot generalize.')
         
-        # Prepare points and shapes using their index
-        points = self.__generate_point_list()
-
-        # Flag spatially conflicting points depending on the distance parameter
-        self.__calculate_spatial_conflicts(points)
-
-        # Debugging tool to visualize spatial conflicts
-        if self.__EXPORT_SPATIAL_DEBUG:
-            self.__export_spatial_conflicts(points)
+        # Prepare geometries before launching the constraint method
+        points = self.__prepare_geometries()
 
         # Build the observation matrix
         self.__build_Y(points)
 
         # Build the weighing matrice
         self.__build_W(points)
 
@@ -236,104 +232,88 @@
 
         return result
 
     def __build_Y(self, points):
         """
         Build the observation vector.
         """
+        movement = self.__constraints['movement']
         stiffness = self.__constraints['stiffness']
         curvature = self.__constraints['curvature']
-        nodes = self.__nodes
-        links = self.__links
+        nodes = self.__constraints['nodes']
+        links = self.__constraints['links']
 
         # Define the size of the vector
-        size = 2 * len(points) +  2 * len(stiffness) + 3 * len(curvature) + len(nodes) + len(links)
+        size = 2 * len(movement) +  2 * len(stiffness) + 3 * len(curvature) + len(nodes) + len(links)
     
         # Create a zero filled np array of the wanted shape
         Y = np.zeros(size)
 
         # Add x and y value to the begining of the vector representing the movement constraint
-        for i, p in enumerate(points):
-            Y[2 * i] = p[0]
-            Y[2 * i + 1] = p[1]
+        for i, p in enumerate(movement):
+            coordinates = points[p[0]]
+            Y[2 * i] = coordinates[0]
+            Y[2 * i + 1] = coordinates[1]
 
-        offset = 2 * len(points)
+        offset = 2 * len(movement)
         for i, p in enumerate(stiffness):
-            current_id = p[0]
-            # Retrieve the next point in the shape
-            apply, next_id = self.__get_next_point_in_shape(current_id, points)
-            # The apply boolean is set to False if the current point is the last of the shape in a LineString
-            if apply:
-                dx, dy = self.__calculate_stiffness(current_id, next_id, points)
-                # Difference between the current and the following along the x axis (x - x+1)
-                Y[offset + 2 * i] = dx
-                # Difference between the current and the following along the y axis (y - y+1)
-                Y[offset + 2 * i + 1] = dy
+            dx, dy = self.__calculate_stiffness(p, points)
+            # Difference between the current and the following along the x axis (x - x+1)
+            Y[offset + 2 * i] = dx
+            # Difference between the current and the following along the y axis (y - y+1)
+            Y[offset + 2 * i + 1] = dy
         
         offset += 2 * len(stiffness)
         for i, p in enumerate(curvature):
-            current_id = p[0]
-            # Retrieve the previous and the next point in the shape
-            apply, previous_id, next_id = self.__get_surrounding_points_in_shape(current_id, points)
-            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
-            if apply:
-                alpha, normp, normn = self.__calculate_curvature(previous_id, current_id, next_id, points)
-                # First value of the constraint is the angle formed by the previous, the current and the next point
-                Y[offset + i] = alpha
-                # Second value is the norm of the vector formed by the previous and the current point
-                Y[offset + i + 1] = normp
-                # Third value is the norm of the vector formed by the current and the next point
-                Y[offset + i + 2] = normn
+            alpha, normp, normn = self.__calculate_curvature(p, points)
+            # First value of the constraint is the angle formed by the previous, the current and the next point
+            Y[offset + i] = alpha
+            # Second value is the norm of the vector formed by the previous and the current point
+            Y[offset + i + 1] = normp
+            # Third value is the norm of the vector formed by the current and the next point
+            Y[offset + i + 2] = normn
 
         # Keep 0 for the spatial conflicts (nodes and links)
 
         self.__Y = Y
 
     def __build_B(self, points):
         """
         Build the matrix B -> Y - S(X).
         """
+        movement = self.__constraints['movement']
         stiffness = self.__constraints['stiffness']
         curvature = self.__constraints['curvature']
-        nodes = self.__nodes
-        links = self.__links
+        nodes = self.__constraints['nodes']
+        links = self.__constraints['links']
 
-        S = np.zeros(2 * len(points) + 2 * len(stiffness) + 3 * len(curvature) + len(nodes) + len(links))
+        S = np.zeros(2 * len(movement) + 2 * len(stiffness) + 3 * len(curvature) + len(nodes) + len(links))
 
-        for i, p in enumerate(points):
-            S[2 * i] = p[0]
-            S[2 * i + 1] = p[1]
+        for i, p in enumerate(movement):
+            coordinates = points[p[0]]
+            S[2 * i] = coordinates[0]
+            S[2 * i + 1] = coordinates[1]
 
-        offset = 2 * len(points)
+        offset = 2 * len(movement)
         for i, p in enumerate(stiffness):
-            current_id = p[0]
-            # Retrieve the next point in the shape
-            apply, next_id = self.__get_next_point_in_shape(current_id, points)
-            # The apply boolean is set to False if the current point is the last of the shape in a LineString
-            if apply:
-                dx, dy = self.__calculate_stiffness(current_id, next_id, points)
-                # Difference between the current and the following along the x axis (x - x+1)
-                S[offset + 2 * i] = dx
-                # Difference between the current and the following along the y axis (y - y+1)
-                S[offset + 2 * i + 1] = dy
+            dx, dy = self.__calculate_stiffness(p, points)
+            # Difference between the current and the following along the x axis (x - x+1)
+            S[offset + 2 * i] = dx
+            # Difference between the current and the following along the y axis (y - y+1)
+            S[offset + 2 * i + 1] = dy
 
         offset += 2 * len(stiffness)
         for i, p in enumerate(curvature):
-            current_id = p[0]
-            # Retrieve the previous and the next point in the shape
-            apply, previous_id, next_id = self.__get_surrounding_points_in_shape(current_id, points)
-            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
-            if apply:
-                alpha, normp, normn = self.__calculate_curvature(previous_id, current_id, next_id, points)
-                # First value of the constraint is the angle formed by the previous, the current and the next point
-                S[offset + i] = alpha
-                # Second value is the norm of the vector formed by the previous and the current point
-                S[offset + i + 1] = normp
-                # Third value is the norm of the vector formed by the current and the next point
-                S[offset + i + 2] = normn
+            alpha, normp, normn = self.__calculate_curvature(p, points)
+            # First value of the constraint is the angle formed by the previous, the current and the next point
+            S[offset + i] = alpha
+            # Second value is the norm of the vector formed by the previous and the current point
+            S[offset + i + 1] = normp
+            # Third value is the norm of the vector formed by the current and the next point
+            S[offset + i + 2] = normn
 
         offset += 3 * len(curvature)
         for i, n in enumerate(nodes):
             if n[3] > n[2]:
                 # Add 0 if the actual distance is higher than the minimum distance
                 S[offset + i] = 0
             else:
@@ -351,48 +331,52 @@
 
         return self.__Y - S
 
     def __build_W(self, points):
         """
         Build the weighting matrix.
         """
+        # Stores arrays inside a list
         constraints = []
 
         movement = []
         # Loop through moving points
-        for i, p in enumerate(points):
-            w = self.__constraints['movement'][i][1]
+        for m in self.__constraints['movement']:
+            w = m[1]
             # Add the weight value to the movement list two times for x and y
             movement.extend([w, w])
-        # Create a full matrix 
         constraints.append(np.full(len(movement), movement))
 
         stiffness = []
-        # Loop through the stiffness constraint
+        # Loop through stiffness constrained points
         for s in self.__constraints['stiffness']:
-            stiffness.extend([s[1], s[1]])
+            w = s[2]
+            stiffness.extend([w, w])
         constraints.append(np.full(len(stiffness), stiffness))
 
         curvature = [] 
-        # Loop through the curvature constraint
+        # Loop through curvature constrained points
         for c in self.__constraints['curvature']:
-            curvature.extend([c[1], c[1], c[1]])
+            w = c[3]
+            curvature.extend([w, w, w])
         constraints.append(np.full(len(curvature), curvature))
 
-        conflicts = []
+        spatial = []
         # Loop through node to node conflicts
-        for n in self.__nodes:
+        for n in self.__constraints['nodes']:
+            w = n[4]
             # Add the weight to the list
-            conflicts.append(n[4])
+            spatial.append(w)
         # Loop through node to link conflicts
-        for l in self.__links:
+        for l in self.__constraints['links']:
+            w = l[5]
             # Add the weight to the list
-            conflicts.append(l[5])
+            spatial.append(w)
         # Create the spatial conflict weight matrix
-        constraints.append(np.full(len(conflicts), conflicts))
+        constraints.append(np.full(len(spatial), spatial))
 
         # Create the diagonal weighting matrix by concatenating all constraints matrices
         self.__W = np.diag(np.concatenate((constraints)))
 
     def __compute_dx(self, points):
         """
         Apply the least square method to the model.
@@ -433,107 +417,106 @@
         return A
 
     def __build_stiffness(self, points):
         """
         Create a matrix for the stiffness constraint.
         """
         stiffness = self.__constraints['stiffness']
+
+        # Create the matrix
         m = np.zeros((2 * len(stiffness), 2 * len(points)))
 
-        for i, p in enumerate(stiffness):
-            current_id = p[0]
-            # Retrieve the next point in the shape
-            apply, next_id = self.__get_next_point_in_shape(current_id, points)
-            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
-            if apply:
-                # x for the current point
-                m[2 * i][2 * current_id] = 1
-                # x for the next point
-                m[2 * i][2 * next_id] = -1
-                # y for the current point
-                m[2 * i + 1][2 * current_id + 1] = 1
-                # y for the next point
-                m[2 * i + 1][2 * next_id + 1] = -1
+        for i, s in enumerate(stiffness):
+            # x for the current point
+            m[2 * i][2 * s[0]] = 1
+            # x for the next point
+            m[2 * i][2 * s[1]] = -1
+            # y for the current point
+            m[2 * i + 1][2 * s[0] + 1] = 1
+            # y for the next point
+            m[2 * i + 1][2 * s[1] + 1] = -1
 
         return m
 
     def __build_curvature(self, points):
         """
         Create a matrix for the curvature constraint.
         """
         curvature = self.__constraints['curvature']
+
+        # Create the matrix
         m = np.zeros((3 * len(curvature), 2 * len(points)))
 
-        for i, p in enumerate(curvature):
-            p = p[0]
-            # Retrieve the previous and the next point in the shape
-            apply, pp, pn = self.__get_surrounding_points_in_shape(p, points)
-            # The apply boolean is set to False if the current point is the first or the last of the shape in a LineString
-            if apply:
-                xp, yp = points[pp][0], points[pp][1]
-                x, y = points[p][0], points[p][1]
-                xn, yn = points[pn][0], points[pn][1]
-
-                x_xp = x - xp
-                y_yp = y - yp
-                x_xn = x - xn
-                y_yn = y - yn
-                b = ((x_xp) * (x_xp) + (y_yp) * (y_yp))
-                d = ((x_xn) * (x_xn) + (y_yn) * (y_yn))
-                c = ((x_xp) * (y_yn) - (x_xn) * (y_yp))
-                bd = b * d
-                a = (bd) ** (-0.5)
-                
-                # df/dxi-1
-                m[3 * i][2 * pp] = a * (-x_xp * c + y_yn * b) / b
-                # df/dyi-1
-                m[3 * i][2 * pp + 1] = a * (-x_xn * b - y_yp * c) / b
-                # df/dxi
-                m[3 * i][2 * p] = a * ((-yp + yn) * bd + c * ((x_xp) * d + (x_xn) * b)) / bd
-                # df/dyi
-                m[3 * i][2 * p + 1] = a * ((xp - xn) * bd + c * ((y_yp) * d + (y_yn) * b)) / bd
-                # df/dxi+1
-                m[3 * i][2 * pn] = a * (-x_xn * c - y_yp * d) / d
-                # df/dyi+1
-                m[3 * i][2 * pn + 1] = a * (x_xp * d - y_yn * c) / d
-
-                # Calculate length of the previous and next segment
-                lp = np.sqrt((x - xp) * (x - xp) + (y - yp) * (y - yp))
-                ln = np.sqrt((xn - x) * (xn - x) + (yn - y) * (yn - y))
-
-                # Influence of the length of previous segment on the current point
-                # x
-                m[3 * i + 1][2 * p] = (x - xp) / lp
-                # y
-                m[3 * i + 1][2 * p + 1] = (y - yp) / lp
-                # Influence of the length of previous segment on the previous point (p)
-                # xp
-                m[3 * i + 1][2 * pp] = -((x - xp) / lp)
-                # yp
-                m[3 * i + 1][2 * pp + 1] = -((y - yp) / lp)
-
-                # Influence of the length of following segment on the next point (n)
-                # xn
-                m[3 * i + 2][2 * pn] = (xn - x) / ln
-                # yn
-                m[3 * i + 2][2 * pn + 1] = (yn - y) / ln
-                # Influence of the length of following segment on the current point
-                # x
-                m[3 * i + 2][2 * p] = -((xn - x) / ln)
-                # y
-                m[3 * i + 2][2 * p + 1] = -((yn - y) / ln)
+        for i, c in enumerate(curvature):
+            pp, p, pn = c[0], c[1], c[2]
+
+            # Coordinates of the previous point
+            xp, yp = points[pp][0], points[pp][1]
+            # Coordinates of the current point
+            x, y = points[p][0], points[p][1]
+            # Coordinates of the next point
+            xn, yn = points[pn][0], points[pn][1]
+
+            x_xp = x - xp
+            y_yp = y - yp
+            x_xn = x - xn
+            y_yn = y - yn
+            b = ((x_xp) * (x_xp) + (y_yp) * (y_yp))
+            d = ((x_xn) * (x_xn) + (y_yn) * (y_yn))
+            c = ((x_xp) * (y_yn) - (x_xn) * (y_yp))
+            bd = b * d
+            a = (bd) ** (-0.5)
+            
+            # df/dxi-1
+            m[3 * i][2 * pp] = a * (-x_xp * c + y_yn * b) / b
+            # df/dyi-1
+            m[3 * i][2 * pp + 1] = a * (-x_xn * b - y_yp * c) / b
+            # df/dxi
+            m[3 * i][2 * p] = a * ((-yp + yn) * bd + c * ((x_xp) * d + (x_xn) * b)) / bd
+            # df/dyi
+            m[3 * i][2 * p + 1] = a * ((xp - xn) * bd + c * ((y_yp) * d + (y_yn) * b)) / bd
+            # df/dxi+1
+            m[3 * i][2 * pn] = a * (-x_xn * c - y_yp * d) / d
+            # df/dyi+1
+            m[3 * i][2 * pn + 1] = a * (x_xp * d - y_yn * c) / d
+
+            # Calculate length of the previous and next segment
+            lp = np.sqrt((x - xp) * (x - xp) + (y - yp) * (y - yp))
+            ln = np.sqrt((xn - x) * (xn - x) + (yn - y) * (yn - y))
+
+            # Influence of the length of previous segment on the current point
+            # x
+            m[3 * i + 1][2 * p] = (x - xp) / lp
+            # y
+            m[3 * i + 1][2 * p + 1] = (y - yp) / lp
+            # Influence of the length of previous segment on the previous point (p)
+            # xp
+            m[3 * i + 1][2 * pp] = -((x - xp) / lp)
+            # yp
+            m[3 * i + 1][2 * pp + 1] = -((y - yp) / lp)
+
+            # Influence of the length of following segment on the next point (n)
+            # xn
+            m[3 * i + 2][2 * pn] = (xn - x) / ln
+            # yn
+            m[3 * i + 2][2 * pn + 1] = (yn - y) / ln
+            # Influence of the length of following segment on the current point
+            # x
+            m[3 * i + 2][2 * p] = -((xn - x) / ln)
+            # y
+            m[3 * i + 2][2 * p + 1] = -((yn - y) / ln)
 
         return m
 
     def __build_spatial(self, points):
         """
         Create a matrix for the spatial conflicts constraint.
         """
-        nodes = self.__nodes
-        links = self.__links
+        nodes = self.__constraints['nodes']
+        links = self.__constraints['links']
 
         # Create the matrix
         m = np.zeros((len(nodes) + len(links), 2 * len(points)))
 
         # Loop through all node to node conflicts
         for i, n in enumerate(nodes):
             # Retrieve both points coordinates
@@ -618,311 +601,514 @@
             # x2
             m[offset + i][2 * n[2]] = e
             # y2
             m[offset + i][2 * n[2] + 1] = f
 
         return m
 
-    def __calculate_stiffness(self, current_id, next_id, points):
+    def __calculate_stiffness(self, stiffness, points):
         """
         Estimate the stiffness by calculating the amount of movement between following point on a shape.
         """
+        current_id, next_id = stiffness[0], stiffness[1]
+
         x0, y0 = points[current_id][0], points[current_id][1]
         x1, y1 = points[next_id][0], points[next_id][1]
+
         return x0 - x1, y0 - y1
 
-    def __calculate_curvature(self, previous_id, current_id, next_id, points):
+    def __calculate_curvature(self, curvature, points):
         """
         Estimate the curvature by calculating the angle formed by the point, its previous and its following point.
         """
+        previous_id, current_id, next_id = curvature[0], curvature[1], curvature[2]
+
         pp = np.array((points[previous_id][0], points[previous_id][1]))
         pc = np.array((points[current_id][0], points[current_id][1]))
         pn = np.array((points[next_id][0], points[next_id][1]))
 
         u = (pc - pp)
         normu = np.linalg.norm(u)
         v = (pn - pc)
         normv = np.linalg.norm(v)
 
         return np.cross(u / normu, v / normv), normu, normv
 
+    def __prepare_geometries(self):
+        """
+        Prepare geometries and stores them on adequate shapes to be handle by the constraint method.
+        """
+        # Prepare points and shapes using their index
+        points = self.__generate_point_list()
+
+        # Setup the constraints
+        self.__setup_constraints(points)
+
+        # Flag spatially conflicting points
+        self.__calculate_spatial_conflicts(points)
+
+        return np.array(points)
+
+    def __generate_point_list(self):
+        """
+        Generate a list of points composed by a tuple of coordinates (x, y), the id of the object, the id of the shape of the object, and the id of the point inside the shape.
+        Generate a nested list of objects composed of all points it is made of, sorted by shapes.
+        Generate lists of points that will accept constraints
+        """
+        unique_points = []
+
+        def get_coordinates(self, shape):
+            """
+            Returns a list of coordinates from a shapely geometry.constraints
+            """
+            if shape.geom_type == 'Polygon':
+                # For Polygon type
+                return shape.exterior.coords
+            else:
+                # For LineString type
+                return shape.coords
+
+        def get_pid_if_duplicate(coordinates):
+            """
+            Return True or False if those coordinates already exists.
+            If they exist, return the index of the already existing point.
+            """
+            for pid, c in enumerate(unique_points):
+                if c == coordinates:
+                    return True, pid
+            return False, None
+
+        point_id = 0
+        # Loop through each objects
+        for oid, shapes in enumerate(self.__OBJECTS):
+            o = []
+            # Loop through each shape of the object
+            for sid, shape in shapes.iterrows():
+                geom = shape.geometry
+
+                s = []
+                # Retrieve the geometry type
+                geomtype = geom.geom_type
+
+                points = []
+                # Retrieve x, y of the points of the shape
+                if geomtype == 'Polygon':
+                    # For Polygon type
+                    points = geom.exterior.coords
+                else:
+                    # For LineString type
+                    points = geom.coords
+
+                # Retrieve first and last index of the shape
+                enclosing = [0, len(points) - 1]
+
+                # Loop through each points in the shape
+                for pid, p in enumerate(points):
+                    # Skipping the last point of a polygon as it is the same as the first one
+                    if geomtype == 'Polygon' and pid == enclosing[1]:
+                        continue
+
+                    # Stores the index of the point to apply constraints
+                    cid = point_id
+
+                    duplicate, dpid = get_pid_if_duplicate(p)
+                    if duplicate:
+                        # Append the already existing point index to its shape
+                        s.append(dpid)
+                        # Change the point index to the already existing one to add constraints
+                        cid = dpid
+                    else:
+                        # Append the point index to its shape
+                        s.append(point_id)
+                        # Append the coordinates to the full list of points
+                        unique_points.append(p)
+                        # Increment the point index if it's a new point
+                        point_id += 1
+                    
+                # Add the list of shapes to the object
+                o.append(s)
+            # Add the list of objects to the list
+            self.__shapes.append(o)
+
+        # Stores unique points
+        self.__points = unique_points
+
+        # Return an array of unique points
+        return np.array(unique_points)
+
+    def __setup_constraints(self, points):
+        """
+        Create constraint and their related properties to easily create matrices afterwards.
+        """
+
+        def add_movement(obj, value):
+            """
+            Add the movement constraint as a list with :
+                - Index of the point
+                - Weight of the constraint
+            If the point as already a movement constraint, it replaces the current weight if the new is higher.
+            """
+            for s in obj:
+                for pid in s:
+                    add = True
+                    for eid, existing in enumerate(self.__constraints['movement']):
+                        if existing[0] == pid:
+                            self.__constraints['movement'][eid][1] = max(value, existing[1])
+                            add = False
+                    if add:
+                        self.__constraints['movement'].append([pid, value])
+        
+        def add_stiffness(obj, value, geomtype):
+            """
+            Add the stiffness constraint as a list with :
+                - Index of the current point
+                - Index of the next point in the shape
+                - Weight of the constraint
+            """
+            for shape in obj:
+                for pid, point in enumerate(shape):
+                    next_id = None
+                    # If it's not the last point of the shape
+                    if pid < (len(shape) - 1):
+                        # Return the real next id
+                        next_id = shape[pid + 1]
+                    # If the current point id is the last of the shape
+                    else:
+                        # If it's a polygon, return the first point
+                        if geomtype == 'Polygon':
+                            next_id = shape[0]
+
+                    if next_id is not None:
+                        self.__constraints['stiffness'].append([point, next_id, value])
+
+        def add_curvature(obj, value, geomtype):
+            """
+            Add the curvature constraint as a list with :
+                - Index of the previous point in the shape
+                - Index of the current point
+                - Index of the next point in the shape
+                - Weight of the constraint
+            """
+            for shape in obj:
+                for pid, point in enumerate(shape):
+                    previous_id = None
+                    next_id = None
+                    # If the current point if not the first or the last
+                    if pid > 0 and pid < (len(shape) - 1):
+                        # Set previous and next as its natural previous and next point
+                        previous_id = shape[pid - 1]
+                        next_id = shape[pid + 1]
+                    # If the current point is either the first or the last
+                    else:
+                        # Check if the shape is a polygon
+                        if geomtype == 'Polygon':
+                            # If the point is the first of the shape
+                            if pid == 0:
+                                # Return the previous as the last point and the next as its natural next
+                                previous_id = shape[-1]
+                                next_id = shape[pid + 1]
+                            # If the point is the last of the shape
+                            elif pid == (len(shape) - 1):
+                                # Return its natural previous and the next as the first of the shape
+                                previous_id = shape[pid - 1]
+                                next_id = shape[0]
+                    if previous_id is not None and next_id is not None:
+                        self.__constraints['curvature'].append([previous_id, point, next_id, value])
+                            
+        for oid, o in enumerate(self.__shapes):
+            # Get the geometry type
+            geomtype = self.__OBJECTS[oid].geometry[0].geom_type
+            # Get the constraints weights
+            weights = self.__WEIGHTS[oid]
+            for name, value in weights.items():
+                if name == 'movement':
+                    add_movement(o, value)
+                elif name == 'stiffness':
+                    add_stiffness(o, value, geomtype)
+                elif name == 'curvature':
+                    add_curvature(o, value, geomtype)
+
     def __calculate_spatial_conflicts(self, points):
         """
         Retrieve conflicting pairs of nodes and nodes, or nodes and links.
         """
 
-        # Check if the node to link conflict concern segments of different objects crossing themselves
-        def line_crossing(p, point, line, points):
-            # Retrieve previous and following points of the shape
-            a, previous_id, next_id = self.__get_surrounding_points_in_shape(p, points)
-            # Loop through both points
-            for i in [previous_id, next_id]:
-                # If point exists
-                if i is not None:
-                    # Create the geometry
-                    ip = shapely.Point(points[i])
-                    # Create the line formed with the current point
-                    crossline = shapely.LineString([point, ip])
-                    # If that line crosses the concerned line, return True
-                    if shapely.crosses(line, crossline):
-                        return True
-            # If none of the two lines cross the concerned line, return False
-            return False
+        node_crossing = []
+        edge_crossing = []
 
-        # Check if a node to node conflict already exists before adding one
-        def add_node_to_node(c):
+        def remove_conflicts(remove, line1, line2):
+            def remove_node_to_node(n1, n2):
+                indexes = []
+                for i, c in enumerate(self.__constraints['nodes']):
+                    c1, c2 = c[0], c[1]
+                    remove = False
+                    if c1 == n1 and c2 == n2:
+                        remove = True
+                    if c1 == n2 and c2 == n1:
+                        remove = True
+                    if remove:
+                        indexes.append(i)
+                for r in indexes:
+                    self.__constraints['nodes'].pop(r)
+            
+            def remove_node_to_link(n, n1, n2):
+                indexes = []
+                for i, c in enumerate(self.__constraints['links']):
+                    c, c1, c2 = c[0], c[1], c[2]
+                    remove = False
+                    if c == n and c1 == n1 and c2 == n2:
+                        remove = True
+                    if remove:
+                        indexes.append(i)
+                for r in indexes:
+                    self.__constraints['links'].pop(r)
+            
+            for n1 in remove:
+                for n2 in line1:
+                    remove_node_to_node(n1, n2)
+            for n1 in remove:
+                for n2 in line2:
+                    remove_node_to_node(n1, n2)
+            for n in line1:
+                for n1 in remove:
+                    for n2 in remove:
+                        remove_node_to_link(n, n1, n2)
+            for n in line2:
+                for n1 in remove:
+                    for n2 in remove:
+                        remove_node_to_link(n, n1, n2)
+
+
+        # Get the surrounding points in a shape with a given threshold
+        def get_surrounding_in_shape(shape, value, threshold, previous_only=False, next_only=False):
+            idx = shape.index(value)
+            result = shape[:]
+            result.remove(value)
+
+            if next_only:
+                left = idx
+            else:
+                left = idx - threshold
+                left = min(max(0, left), len(result) - (2 * threshold))
+            if previous_only:
+                right = idx
+            else:
+                if next_only:
+                    t = threshold
+                else:
+                    t = 2 * threshold
+                right = left + t
+
+            return result[left:right]
+
+        # Check if two LineStrings intersect
+        def flag_crossing(n, n1, n2, shape, shape1):
+            # If the lines cross at one node
+            if n == n1:
+                add = True
+                for nc in node_crossing:
+                    if nc[0] == n:
+                        add = False
+                if add:
+                    node_crossing.append([n, shape, shape1])
+            else:
+                # Create the line with the two nodes
+                line = shapely.LineString([points[n1], points[n2]])
+                # Retrieve the index of the node in the shape
+                nid = shape.index(n)
+
+                crossing = None
+                # If it's not the first node of the shape
+                if nid > 0:
+                    # Create the line between the node and the previous node
+                    pp = shape[nid - 1]
+                    linep = shapely.LineString([points[n], points[pp]])
+                    # Check if both lines crosses
+                    if shapely.crosses(line, linep):
+                        crossing = [n, pp, n1, n2]
+                # If it's not the last node of the shape
+                if nid < (len(shape) - 1) and crossing is None:
+                    # Create the line between the node and the next node
+                    pn = shape[nid + 1]
+                    linen = shapely.LineString([points[n], points[pn]])
+                    # Check if both lines crosses
+                    if shapely.crosses(line, linen):
+                        crossing = [n, pn, n1, n2]
+
+                # If a crossing has been found
+                if crossing is not None:
+                    add = True
+                    # Check if it's not already present before adding to the list
+                    for ec in edge_crossing:
+                        if Counter(ec[0]) == Counter(crossing):
+                            add = False
+                    if add:
+                        edge_crossing.append([crossing, shape, shape1])
+
+
+        # Check if a node to link conflict already exists before adding one
+        def add_node_to_link(c):
             add = True
-            for n in self.__nodes:
-                if (c[0] == n[0] and c[1] == n[1]):
+            for n in self.__constraints['links']:
+                if (c[0] == n[0] and c[1] == n[1] and c[2] == n[2]):
                     add = False
-                if (c[0] == n[1] and c[1] == n[0]):
+                if (c[0] == n[0] and c[1] == n[2] and c[2] == n[1]):
                     add = False
             if add:
-                self.__nodes.append(c)
+                self.__constraints['links'].append(c)
+
+        # Check if a node to node conflict already exists before adding one
+        def add_node_to_node(c):
+            add = False
+            if c[0] != c[1]:
+                add = True
+                for n in self.__constraints['nodes']:
+                    if (c[0] == n[0] and c[1] == n[1]):
+                        add = False
+                    if (c[0] == n[1] and c[1] == n[0]):
+                        add = False
+            if add:
+                self.__constraints['nodes'].append(c)
 
-        def retrieve_nodes_links(shape, geomtype, p, conflict_dist, min_dist, weight):
+        def retrieve_nodes_links(shape, shape1, geomtype, geomtype1, p, conflict_dist, min_dist, weight):
             point = shapely.Point(points[p])
             # Loop through all the points of the LineString or Polygon shape
-            for pid1, p1 in enumerate(shape):
+            for pid1, p1 in enumerate(shape1):
                 notlast = True
                 # Check if it's not the last point of the shape
-                if pid1 < (len(shape) - 1):
-                    p2 = shape[pid1 + 1]
+                if pid1 < (len(shape1) - 1):
+                    p2 = shape1[pid1 + 1]
                 else:
                     notlast = False
-                    if geomtype == 'Polygon':
-                        p2 = shape[0]
+                    if geomtype1 == 'Polygon':
+                        p2 = shape1[0]
                     else:
                         continue
+                
                 # Retrieve the current and next point, calculate the line between them
                 point1 = shapely.Point(points[p1])
                 point2 = shapely.Point(points[p2])
                 line = shapely.LineString([point1, point2])
                 # Calculate the distance between the point and point 1 and 2, and with the line
                 pdist1 = shapely.distance(point, point1)
                 pdist2 = shapely.distance(point, point2)
                 ldist = shapely.distance(point, line)
-                # First, re-checks if one of the three distance is below the minimum distance threshold
+                # First, checks if one of the three distance is below the minimum distance threshold
                 if pdist1 < conflict_dist or pdist2 < conflict_dist or ldist < conflict_dist:
+                    # For LineString, check if the two lines intersects
+                    if geomtype == geomtype1 == 'LineString':
+                        flag_crossing(p, p1, p2, shape, shape1)
+
                     # If the line distance is the smallest, insert a node to link spatial conflict
                     if ldist < pdist1 and ldist < pdist2:
-                        if line_crossing(p, point, line, points) == False:
-                            self.__links.append([p, p1, p2, min_dist, ldist, weight]) 
-                    else:
+                        #if line_crossing(p, point, line, points) == False:
+                        add_node_to_link([p, p1, p2, min_dist, ldist, weight])
+                    else:                      
                         # Determine which node is the closest
                         if pdist1 < pdist2:
                             add_node_to_node([p, p1, min_dist, pdist1, weight])
                         else:
                             if notlast:
                                 add_node_to_node([p, p2, min_dist, pdist2, weight])
 
         # Check if the considered point is spatially conflicting with other points
-        def check_conflicts(p):
+        def check_conflicts(shape, p, oid, sid, pid):
+            geomtype = self.__OBJECTS[oid].geometry[sid].geom_type
             point = shapely.Point(points[p])
-            oid, sid, pid = self.__points[p][0], self.__points[p][1], self.__points[p][2]
             # Loop through all objects
             for oid1, o in enumerate(self.__shapes):
                 # Loop through all shapes
                 for sid1, s in enumerate(o):
-                    # Checks if the shape is not the same as the concerned point
-                    if oid1 == oid and sid1 == sid:
-                        continue
-                    else:
-                        # Getting the weight of the spatial conflict constraint from the matrix
-                        weight = self.__CONFLICTS[oid][oid1]
-                        # Getting the distance value from the distances matrix
-                        min_dist = self.__DISTANCES[oid][oid1]
-                        # Setting a distance equal to 1.5 times the min distance to retrieve conflicting objects
-                        # Setting conflict_dist = min_dist doesn't take the 1.5 time conflicting entities
-                        conflict_dist = 1.5 * min_dist
-                        
-                        # Retrieve the geometry of the shape
-                        shape = self.__OBJECTS[oid1].geometry[sid1]
-                        # Checks if that shape is within the minimum distance before retrieving pairs of nodes and links
-                        if shapely.dwithin(point, shape, conflict_dist):
-                            # Stores the geometry type
-                            geomtype = shape.geom_type
-                            # Checks if the shape is a point
-                            if geomtype == 'Point':
-                                distance = shapely.distance(point, shape)
-                                add_node_to_node([p, s[0], min_dist, distance, weight])
-                            # If it's not, checking if it's closer to a node or a segment
-                            else:
-                                retrieve_nodes_links(s, geomtype, p, conflict_dist, min_dist, weight)
+                    # Retrieve the geometry of the shape
+                    shape1 = self.__OBJECTS[oid1].geometry[sid1]
+                    # Stores the geometry type
+                    geomtype1 = shape1.geom_type
+
+                    # Checks if it's the same object
+                    if oid1 == oid:
+                        if geomtype1 == 'LineString':
+                            continue
+                        if sid1 == sid:
+                            continue
+                        if self.SAME_OBJECT_CONFLICTS == False:
+                            continue
+                    # Getting the weight of the spatial conflict constraint from the matrix
+                    weight = self.__CONFLICTS[oid][oid1]
+                    # Getting the distance value from the distances matrix
+                    min_dist = self.__DISTANCES[oid][oid1]
+                    # Setting a distance equal to 1.5 times the min distance to retrieve conflicting objects
+                    # Setting conflict_dist = min_dist doesn't take the 1.5 time conflicting entities
+                    conflict_dist = 1.5 * min_dist
+                    
+                    # Checks if that shape is within the minimum distance before retrieving pairs of nodes and links
+                    if shapely.dwithin(point, shape1, conflict_dist):
+                        # Checks if the shape is a point
+                        if geomtype1 == 'Point':
+                            distance = shapely.distance(point, shape1)
+                            add_node_to_node([p, s[0], min_dist, distance, weight])
+                        # If it's not, checking if it's closer to a node or a segment
+                        else:
+                            retrieve_nodes_links(shape, s, geomtype, geomtype1, p, conflict_dist, min_dist, weight)
 
         # Loop through all objects
-        for o in self.__shapes:
+        for oid, o in enumerate(self.__shapes):
             # Loop through all shapes
-            for s in o:
+            for sid, s in enumerate(o):
                 # Loop through all points
-                for p in s:
+                for pid, p in enumerate(s):
                     # Check conflicts with other points
-                    check_conflicts(p)
+                    check_conflicts(s, p, oid, sid, pid)
 
-    def __generate_point_list(self):
-        """
-        Generate a list of points composed by a tuple of coordinates (x, y), the id of the object, the id of the shape of the object, and the id of the point inside the shape.
-        Generate a nested list of objects composed of all points it is made of, sorted by shapes.
-        Generate lists of points that will accept constraints
-        """
+        threshold = self.CROSSING_NODE_THRESHOLD
 
-        def add_point_constraint(pid, weights):
-            for cname, clist in self.__constraints.items():
-                if cname in weights.keys():
-                    w = np.inf if weights[cname] == -1 else weights[cname]
-                    self.__constraints[cname].append((pid, w))
-
-        unique_points = []
-        point_id = 0
-        # Loop through each objects
-        for oid, shapes in enumerate(self.__OBJECTS):
-            # retrieve the weights of the concerned object
-            weights = self.__WEIGHTS[oid]
-            o = []
-            # Loop through each shape of the object
-            for sid, shape in shapes.iterrows():
-                s = []
-                # Retrieve the geometry type
-                geomtype = shape.geometry.geom_type
-                # Retrieve x, y of the points of the shape
-                points = self.__get_coordinates(shape.geometry)
-                # Loop through each points in the shape
-                for pid, p in enumerate(points):
-                    # Skipping the last point of a polygon as it is the same as the first one
-                    if geomtype == 'Polygon' and pid >= (len(points) - 1):
-                        continue
-                    else:
-                        # Append point to the full list of points
-                        unique_points.append(p)
-                        # Append the position of the point within its object and shape
-                        self.__points.append((oid, sid, pid))
-                        # Append the point to its shape
-                        s.append(point_id)
-                        # Add the constraint associated with the point
-                        add_point_constraint(point_id, weights)
-                        point_id += 1
-                # Add the list of shapes to the object
-                o.append(s)
-            # Add the list of objects to the list
-            self.__shapes.append(o)
-
-        # Return an array of unique points
-        return np.array(unique_points)
-
-    def __get_next_point_in_shape(self, current_id, points):
-        """
-        Look for the next point in the shape.
-        Return a boolean set to True if a point was found, i.e. the current point is not the last of a LineString.
-        If the current point is the last point of a polygon, it returns the first point.
-        """
-        # Get the position of the current point
-        position = self.__points[current_id]
-        oid, sid, pid = position[0], position[1], position[2]
-
-        # Get its shape
-        shape = self.__shapes[oid][sid]
-        # Get the geometry type
-        geomtype = self.__OBJECTS[oid].geometry[0].geom_type
-        
-        apply = True
-        next_id = None
-
-        if pid < (len(shape) - 1):
-            # Return the real next id if it's not the last point of the shape
-            next_id = shape[pid + 1]
-        else:
-            if geomtype == 'Polygon':
-                # If the current point id the last of the shape and it's a polygon, return the first point
-                next_id = shape[0]
-            else:
-                # Set the boolean to false for the last point of a linestring
-                apply = False
-        
-        return apply, next_id
-
-    def __get_surrounding_points_in_shape(self, current_id, points):
-        """
-        Look for the previous and the next point in the shape.
-        Return a boolean set to True if both points were found, i.e. the current point is not the first or the last of a LineString.
-        If the current point is first or the last point of the polygon, it returns correct surrounding points.
-        """
-        # Get the position of the current point
-        position = self.__points[current_id]
-        oid, sid, pid = position[0], position[1], position[2]
-
-        # Get its shape
-        shape = self.__shapes[oid][sid]
-        # Get the geometry type
-        geomtype = self.__OBJECTS[oid].geometry[0].geom_type
-        
-        apply = True
-        previous_id = None
-        next_id = None
-
-        # If the current point if not the first or the last
-        if pid > 0 and pid < (len(shape) - 1):
-            # Set previous and next as its natural previous and next point
-            previous_id = shape[pid - 1]
-            next_id = shape[pid + 1]
-        # If the current point either the first or the last
-        else:
-            # Check if the shape is a polygon
-            if geomtype == 'Polygon':
-                # If the point is the first of the shape
-                if pid == 0:
-                    # Return the previous as the last point and the next as its natural next
-                    previous_id = shape[-1]
-                    next_id = shape[pid + 1]
-                # If the point is the last of the shape
-                elif pid == (len(shape) - 1):
-                    # Return its natural previous and the next as the first of the shape
-                    previous_id = shape[pid - 1]
-                    next_id = shape[0]
-            # Set boolean to False if the shape is a LineString
-            else:
-                apply = False
-        
-        return apply, previous_id, next_id
+        # Once every spatial conflicts have been created, removing conflicts around crossing lines
+        for nc in node_crossing:
+            node, line1, line2 = nc[0], nc[1], nc[2]
+            remove = [node]
+            remove.extend(get_surrounding_in_shape(line1, node, threshold))
+            remove.extend(get_surrounding_in_shape(line2, node, threshold))
+            remove_conflicts(remove, line1, line2)
+
+        if threshold > 0:
+            threshold -= 1
+            for ec in edge_crossing:
+                p1, p2, p3, p4 = ec[0][0], ec[0][1], ec[0][2], ec[0][3]
+                line1, line2 = ec[1], ec[2]
+                remove = [p1, p2, p3, p4]
+                remove.extend(get_surrounding_in_shape(line1, p1, threshold, previous_only=True))
+                remove.extend(get_surrounding_in_shape(line1, p2, threshold, next_only=True))
+                remove.extend(get_surrounding_in_shape(line2, p3, threshold, previous_only=True))
+                remove.extend(get_surrounding_in_shape(line2, p4, threshold, next_only=True))
+                remove_conflicts(remove, line1, line2)
 
     def __update_distances(self, points):
         """
         Update the distance between pairs of nodes and pairs of nodes and links
         """
         # Loop through node to node conflicts
-        for i, n in enumerate(self.__nodes):
+        for i, n in enumerate(self.__constraints['nodes']):
             # Retrieve coordinates of the two nodes
             n1, n2 = points[n[0]], points[n[1]]
             x1, x2, y1, y2 = n1[0], n2[0], n1[1], n2[1]
             # Calculate the vector formed by those two points
             v = np.array([x2 - x1, y2 - y1])
             # Calculate its norm, i.e. distance and updating it
             nodedistance = np.linalg.norm(v)
-            self.__nodes[i][3] = nodedistance
+            self.__constraints['nodes'][i][3] = nodedistance
 
         # Loop through node to link conflicts
-        for i, l in enumerate(self.__links):
+        for i, l in enumerate(self.__constraints['links']):
             # Retrieve coordinates of the three nodes as array
             n0 = np.array(points[l[0]])
             n1 = np.array(points[l[1]])
             n2 = np.array(points[l[2]])
             # Calculate the distance between the first node and the line formed by the other two
             linkdistance = np.linalg.norm(np.cross(n2 - n1, n1 - n0)) / np.linalg.norm(n2 - n1)
             # Updating the distance
-            self.__links[i][4] = linkdistance
-
-    def __get_coordinates(self, shape):
-        """
-        Returns a list of coordinates from a shapely geometry.constraints
-        """
-        if shape.geom_type == 'Polygon':
-            # For Polygon type
-            return shape.exterior.coords
-        else:
-            # For LineString type
-            return shape.coords
+            self.__constraints['links'][i][4] = linkdistance
 
     def __reconstruct_geometries(self, points):
         """
         Reconstruct Geoseries with the generalized geometries
         """
         # Loop through the results objects
         for oid, o in enumerate(self.__RESULTS):
@@ -947,63 +1133,73 @@
                         # If the geometry is a polygon, add the first point as the last to close it
                         sha.append(sha[0])
                         geometry = shapely.Polygon(sha)
                     # Update the geometry of the shape
                     self.__RESULTS[oid].loc[sid, 'geometry'] = geometry
         return self.__OBJECTS
 
-    def __export_spatial_conflicts(self, points):
+    def get_nodes(self):
         """
-        Exports spatial conflicts as links between pairs of nodes and pairs of nodes and links.
-        This function is for DEBUGGING PURPOSES.
+        Return the full list of nodes as a GeoDataFrame.
         """
         pointslist = []
         shape_id = 0
         for o in self.__shapes:
             for s in o:
                 for p in s:
                     pointslist.append({
                     'id' : p,
                     'object' : shape_id,
-                    'geometry' : shapely.Point(points[p])
+                    'geometry' : shapely.Point(self.__points[p])
                 }) 
                 shape_id += 1         
+        return geopandas.GeoDataFrame(pointslist, crs=3857)
 
-        points_gdf = geopandas.GeoDataFrame(pointslist, crs=3857)
+        points_gdf.to_file("cartagen4py/data/data_bourbonnaise/points_nodes.geojson", driver="GeoJSON")
 
-        nodes = []
-        for i, node in enumerate(self.__nodes):
-            nodes.append({
+    def get_nodes_conflicts(self):
+        """
+        Return all the nodes to nodes conflicts as a LineString between the two nodes.
+        Return a GeoDataFrame.
+        """
+        lines = []
+        for i, node in enumerate(self.__constraints['nodes']):
+            lines.append({
                 'nid0': node[0],
                 'nid1': node[1],
                 'group': i,
-                'geometry': shapely.LineString([points[node[0]], points[node[1]]])
+                'geometry': shapely.LineString([self.__points[node[0]], self.__points[node[1]]])
             })
 
-        if len(nodes) > 0:
-            nodes_gdf = geopandas.GeoDataFrame(nodes, crs=3857)
-            nodes_gdf.to_file("cartagen4py/data/data_bourbonnaise/nodes.geojson", driver="GeoJSON")
-
-        links = []
-        for lid, link in enumerate(self.__links):
-            p0 = shapely.Point(points[link[0]])
-            p1 = shapely.Point(points[link[1]])
-            p2 = shapely.Point(points[link[2]])
+        if len(lines) > 0:
+            return geopandas.GeoDataFrame(lines, crs=3857)
+        else:
+            return None
+
+    def get_links_conflicts(self):
+        """
+        Return all the nodes to links conflicts as a LineString between the node and the projection of this node on the conflicting line.
+        Return a GeoDataFrame.
+        """
+        lines = []
+        for lid, link in enumerate(self.__constraints['links']):
+            p0 = shapely.Point(self.__points[link[0]])
+            p1 = shapely.Point(self.__points[link[1]])
+            p2 = shapely.Point(self.__points[link[2]])
             line = shapely.LineString([p1, p2])
             dist = line.project(p0)
             projected = line.interpolate(dist)
-            links.append({
+            lines.append({
                 'lid': lid,
                 'geometry': shapely.LineString([p0, projected])
             })
 
-        if len(links) > 0:
-            links_gdf = geopandas.GeoDataFrame(links, crs=3857)
-            links_gdf.to_file("cartagen4py/data/data_bourbonnaise/links.geojson", driver="GeoJSON")
-        
-        points_gdf.to_file("cartagen4py/data/data_bourbonnaise/points_nodes.geojson", driver="GeoJSON")
+        if len(lines) > 0:
+            return geopandas.GeoDataFrame(lines, crs=3857)
+        else:
+            return None
         
     def get_objects_number(self):
         """
         Return the number of objects added to the generalization algorithm.
         """
         return len(self.__OBJECTS)
```

### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

## cartagen4py/data_enrichment/__init__.py

```diff
@@ -1,3 +1,4 @@
 from cartagen4py.data_enrichment.building_measures import *
 from cartagen4py.data_enrichment.urban_areas import *
-from cartagen4py.data_enrichment.stroke import *
+from cartagen4py.data_enrichment.stroke import *
+from cartagen4py.data_enrichment.network import *
```

## cartagen4py/utils/__init__.py

```diff
@@ -1,5 +1,6 @@
 from cartagen4py.utils.clustering import *
 from cartagen4py.utils.geometry import *
 from cartagen4py.utils.math import *
+from cartagen4py.utils.network import *
 from cartagen4py.utils.partitioning import *
 from cartagen4py.utils.tessellation import *
```

## cartagen4py/utils/geometry/__init__.py

```diff
@@ -1,4 +1,5 @@
 from cartagen4py.utils.geometry.angle import *
+from cartagen4py.utils.geometry.distances import *
 from cartagen4py.utils.geometry.extent import *
 from cartagen4py.utils.geometry.line import *
 from cartagen4py.utils.geometry.segment import *
```

## cartagen4py/utils/geometry/angle.py

```diff
@@ -1,10 +1,11 @@
 # This file contains functions that provide angle operations
 
 from shapely.geometry import Point
+import shapely
 import numpy as np
 from math import pi
 
 def angle_3_pts(point1, point2, point3):
     angle1 = angle_2_pts(point2, point1)
     angle2 = angle_2_pts(point2, point3)
 
@@ -16,9 +17,73 @@
     return np.arctan2(y, x)
 
 # converts an angle between 0 and 2Pi or in [-Pi, Pi] to the [0, Pi] interval
 def angle_to_zero_pi(angle):
     if angle > pi:
         return angle - pi
     if angle < 0:
-        return -angle
+        return - angle
+    return angle
+
+def angle_between_2lines(line1, line2):
+    """
+    Return the angle between two lines that crosses at their end or start point. Takes shapely LineStrings as input.
+    """
+    # retrieve coordinates of lines nodes, number of node in lines and start and end node
+    coords1 = line1.coords
+    l1 = len(coords1)
+    start1, end1 = coords1[0], coords1[-1]
+    coords2 = line2.coords
+    l2 = len(coords2)
+    start2, end2 = coords2[0], coords2[-1]
+
+    sgeom1 = sgeom2 = None
+    current = None
+
+    if start1 == start2:
+        current = start1
+        sgeom1 = True
+        sgeom2 = True
+    if start1 == end2:
+        current = start1
+        sgeom1 = True
+        sgeom2 = False
+    if end1 == end2:
+        current = end1
+        sgeom1 = False
+        sgeom2 = False
+    if end1 == start2:
+        current = end1
+        sgeom1 = False
+        sgeom2 = True
+
+    # In this case, lines are not crossing
+    if current is None:
+        return None
+
+    previous = following = None
+
+    if l1 > 2:
+        if sgeom1:
+            previous = coords1[2]
+        else:
+            previous = coords1[-3]
+    else:
+        if sgeom1:
+            previous = coords1[1]
+        else:
+            previous = coords1[-2]
+
+    if l2 > 2:
+        if sgeom2:
+            following = coords2[2]
+        else:
+            following = coords2[-3]
+    else:
+        if sgeom2:
+            following = coords2[1]
+        else:
+            following = coords2[-2]
+
+    angle = angle_3_pts(shapely.Point(previous), shapely.Point(current), shapely.Point(following))
+
     return angle
```

## cartagen4py/utils/geometry/line.py

```diff
@@ -1,9 +1,11 @@
-from shapely.geometry import Point, Polygon, LineString
 import numpy as np
+import shapely
+from shapely.ops import split, nearest_points, snap
+from shapely.geometry import Point, Polygon, LineString
 
 def get_shortest_edge_length(geom: LineString):
     min_length = float('inf')
     segments = get_linestring_segments(geom)
     for segment in segments:
         print(segment)
         length = Point(segment[0]).distance(Point(segment[1]))
@@ -95,8 +97,44 @@
         distance = vertex_pt.distance(point)
         if distance == 0:
             continue
         if distance < min_dist:
             min_dist = distance
             nearest = vertex_pt
     
-    return nearest
+    return nearest
+
+def extend_line_with_point(line, point, position='start'):
+    """
+    Extend the line with a given point, depending on the position, adds it at the start or the end
+    """
+    new_line = []
+    p = [point.x, point.y]
+
+    if position == 'start':
+        new_line.append(p)
+
+    for n in line.coords:
+        new_line.append(n)
+
+    if position == 'end':
+        new_line.append(p)
+
+    return LineString(new_line)
+        
+def split_line_at_point(line, point):
+    """
+    Split a line at a given point along this line.
+    Return the two new linestrings.
+    Return None if the line and the point doesn't intersect.
+    """
+    if line.distance(point) < 1e-8:
+        return None
+
+    projected = nearest_points(point, line)[1]
+    splitted = split(snap(line, projected, 0.0001), projected)
+
+    lines = []
+    for s in splitted.geoms:
+        lines.append(s)
+
+    return lines[0], lines[1]
```

## cartagen4py/utils/partitioning/network.py

```diff
@@ -1,31 +1,34 @@
 import shapely
 from shapely.ops import linemerge, unary_union, polygonize
-from cartagen4py.utils.geometry import extent 
+from cartagen4py.utils.geometry import extent
 
-# Calculates the faces of one or multiple networks and return a list of polygons
-def calculate_network_faces(*networks):
+def calculate_network_faces(*networks, convex_hull=True):
+    """
+    Calculates the faces of one or multiple shapely geometry networks and return a shapely geometry sequence of polygons.
+    """
     if len(networks) < 1:
         raise Exception('No networks provided, network partition cannot be created.')
 
     network = []
     for i, n in enumerate(networks):
         for object in n:
             if object.geom_type == 'LineString':
                 network.append(object)
             elif object.geom_type == 'MultiLineString':
                 for line in object.geoms:
                     network.append(line)
 
-    # Calculating the networks convex hull
-    multilines = unary_union(network)
-    multilines = linemerge(network)
-    hull = shapely.convex_hull(multilines)
-    # Adding the convex hull boundary as a linestring to the network
-    network.append(hull.boundary)
+    if convex_hull:
+        # Calculating the networks convex hull
+        multilines = unary_union(network)
+        multilines = linemerge(network)
+        hull = shapely.convex_hull(multilines)
+        # Adding the convex hull boundary as a linestring to the network
+        network.append(hull.boundary)
     
     # Fully dissolve and node the network
     network = unary_union(network)
     # Merge all contiguous lines
     network = linemerge(network)
     # Return a list of polygons representing the faces of the network
     return polygonize(network)
```

## Comparing `cartagen4py-0.2.2.dist-info/METADATA` & `cartagen4py-0.2.3.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: cartagen4py
-Version: 0.2.2
+Version: 0.2.3
 Summary: Python package to generalise geographic objects for cartographic purposes
 Home-page: https://github.com/LostInZoom/cartagen4py
 Author: Guillaume Touya, Justin Berli
 Author-email: guillaume.touya@ign.fr
 License: CeCILL-C
 Keywords: Generalization,Cartography,cartographic generalization
 Platform: Linux
```

