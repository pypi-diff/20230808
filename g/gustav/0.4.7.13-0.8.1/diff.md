# Comparing `tmp/gustav-0.4.7.13-py2-none-any.whl.zip` & `tmp/gustav-0.8.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,27 @@
-Zip file size: 74229 bytes, number of entries: 31
--rw-rw-r--  2.0 unx     1068 b- defN 15-Oct-12 21:14 gustav/dataTemplate_adaptive.py
--rw-rw-r--  2.0 unx     8160 b- defN 15-Oct-12 21:14 gustav/gustav.py
--rw-rw-r--  2.0 unx    14372 b- defN 15-Oct-12 21:14 gustav/settings_constant_nogui.py
--rw-rw-r--  2.0 unx    29385 b- defN 16-Apr-21 17:38 gustav/utils.py
--rw-rw-r--  2.0 unx     2035 b- defN 18-Mar-26 15:55 gustav/__init__.py
--rw-rw-r--  2.0 unx     5114 b- defN 15-Oct-12 21:14 gustav/frontends/term.py
--rw-rw-r--  2.0 unx      828 b- defN 15-Oct-12 21:14 gustav/frontends/__init__.py
--rw-rw-r--  2.0 unx     4865 b- defN 15-Oct-12 21:14 gustav/frontends/tk.py
--rw-rw-r--  2.0 unx    22086 b- defN 15-Oct-12 21:14 gustav/frontends/pylabconfig.py
--rw-rw-r--  2.0 unx    12334 b- defN 15-Oct-12 21:14 gustav/frontends/qt.py
--rw-rw-r--  2.0 unx      833 b- defN 15-Oct-12 21:14 gustav/methods/__init__.py
--rw-rw-r--  2.0 unx     3183 b- defN 15-Oct-12 21:14 gustav/methods/constant.py
--rw-rw-r--  2.0 unx    16115 b- defN 17-Feb-15 23:08 gustav/methods/adaptive.py
--rw-rw-r--  2.0 unx      989 b- defN 16-Feb-29 17:38 gustav/user_scripts/test_gustav_lateralizationForm_Joystick.py
--rw-rw-r--  2.0 unx      663 b- defN 15-Oct-12 21:14 gustav/user_scripts/test_gustav_closedSetForm.py
--rw-rw-r--  2.0 unx    16034 b- defN 15-Oct-12 21:14 gustav/user_scripts/gustav_exp__constantStim_gui.py
--rw-rw-r--  2.0 unx      479 b- defN 15-Oct-12 21:14 gustav/user_scripts/test_gustav_lateralizationForm.py
--rw-rw-r--  2.0 unx    16744 b- defN 15-Oct-12 21:14 gustav/user_scripts/gustav_exp__constantStim_nogui.py
--rw-rw-r--  2.0 unx    13848 b- defN 15-Oct-12 21:14 gustav/user_scripts/gustav_exp__adaptive_quietthresholds.py
--rw-rw-r--  2.0 unx    18608 b- defN 15-Oct-12 21:14 gustav/user_scripts/gustav_exp__ild_sensitivity.py
--rw-rw-r--  2.0 unx      848 b- defN 15-Oct-12 21:14 gustav/user_scripts/test_gustav_speechForm.py
--rw-rw-r--  2.0 unx      377 b- defN 15-Oct-12 21:14 gustav/user_scripts/gustav_run.py
--rw-rw-r--  2.0 unx    17247 b- defN 15-Oct-12 21:14 gustav/user_scripts/gustav_exp__ClosedSetSpeech.py
--rw-rw-r--  2.0 unx    14050 b- defN 17-Feb-20 15:00 gustav/user_scripts/gustav__puretone_quietthresholds.py
--rw-rw-r--  2.0 unx      680 b- defN 15-Oct-12 21:14 gustav/user_scripts/test_gustav_adaptiveForm.py
--rw-rw-r--  2.0 unx     1701 b- defN 18-Mar-27 18:42 gustav-0.4.7.13.dist-info/DESCRIPTION.rst
--rw-rw-r--  2.0 unx      273 b- defN 18-Mar-27 18:42 gustav-0.4.7.13.dist-info/metadata.json
--rw-rw-r--  2.0 unx        7 b- defN 18-Mar-27 18:42 gustav-0.4.7.13.dist-info/top_level.txt
--rw-rw-r--  2.0 unx       92 b- defN 18-Mar-27 18:42 gustav-0.4.7.13.dist-info/WHEEL
--rw-rw-r--  2.0 unx     1828 b- defN 18-Mar-27 18:42 gustav-0.4.7.13.dist-info/METADATA
--rw-rw-r--  2.0 unx     2881 b- defN 18-Mar-27 18:42 gustav-0.4.7.13.dist-info/RECORD
-31 files, 227727 bytes uncompressed, 69571 bytes compressed:  69.4%
+Zip file size: 110741 bytes, number of entries: 25
+-rw-r--r--  2.0 unx     1898 b- defN 23-Aug-08 17:17 gustav/__init__.py
+-rw-r--r--  2.0 unx     1068 b- defN 21-Mar-20 22:36 gustav/dataTemplate_adaptive.py
+-rw-r--r--  2.0 unx     8291 b- defN 22-Mar-12 18:39 gustav/gustav.py
+-rw-r--r--  2.0 unx    32439 b- defN 23-Feb-26 16:13 gustav/utils.py
+-rw-r--r--  2.0 unx      913 b- defN 21-Mar-20 22:36 gustav/forms/__init__.py
+-rw-r--r--  2.0 unx    56957 b- defN 22-Feb-01 00:32 gustav/forms/lateralization.py
+-rw-r--r--  2.0 unx    60675 b- defN 21-Dec-03 16:43 gustav/forms/localization.py
+-rw-r--r--  2.0 unx    53735 b- defN 22-Feb-07 18:00 gustav/forms/nafc.py
+-rw-r--r--  2.0 unx    46112 b- defN 22-Jan-16 17:21 gustav/forms/rt.py
+-rw-r--r--  2.0 unx    40942 b- defN 21-Dec-21 02:40 gustav/forms/speech.py
+-rw-r--r--  2.0 unx     1208 b- defN 23-Feb-26 16:14 gustav/frontends/__init__.py
+-rw-r--r--  2.0 unx     4802 b- defN 21-Mar-20 22:36 gustav/frontends/term.py
+-rw-r--r--  2.0 unx     4742 b- defN 21-Mar-20 22:36 gustav/frontends/tk.py
+-rw-r--r--  2.0 unx      833 b- defN 21-Mar-20 22:36 gustav/methods/__init__.py
+-rw-r--r--  2.0 unx    16104 b- defN 22-May-09 17:03 gustav/methods/adaptive.py
+-rw-r--r--  2.0 unx     3322 b- defN 21-Mar-20 22:36 gustav/methods/constant.py
+-rw-r--r--  2.0 unx    16146 b- defN 21-Mar-20 22:36 gustav/methods/pest.py
+-rw-r--r--  2.0 unx    10923 b- defN 23-Feb-26 16:16 gustav/user_scripts/gustav_exp__adaptive__frequency_discrim.py
+-rw-r--r--  2.0 unx    10965 b- defN 23-Feb-26 16:16 gustav/user_scripts/gustav_exp__adaptive_quietthresholds.py
+-rw-r--r--  2.0 unx     9890 b- defN 23-Feb-26 16:17 gustav/user_scripts/gustav_exp__lateralization.py
+-rw-r--r--  2.0 unx    32423 b- defN 23-Aug-08 17:18 gustav-0.8.1.dist-info/LICENSE.md
+-rw-r--r--  2.0 unx     1085 b- defN 23-Aug-08 17:18 gustav-0.8.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Aug-08 17:18 gustav-0.8.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        7 b- defN 23-Aug-08 17:18 gustav-0.8.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2098 b- defN 23-Aug-08 17:18 gustav-0.8.1.dist-info/RECORD
+25 files, 417670 bytes uncompressed, 107373 bytes compressed:  74.3%
```

## zipnote {}

```diff
@@ -1,94 +1,76 @@
-Filename: gustav/dataTemplate_adaptive.py
+Filename: gustav/__init__.py
 Comment: 
 
-Filename: gustav/gustav.py
+Filename: gustav/dataTemplate_adaptive.py
 Comment: 
 
-Filename: gustav/settings_constant_nogui.py
+Filename: gustav/gustav.py
 Comment: 
 
 Filename: gustav/utils.py
 Comment: 
 
-Filename: gustav/__init__.py
+Filename: gustav/forms/__init__.py
 Comment: 
 
-Filename: gustav/frontends/term.py
+Filename: gustav/forms/lateralization.py
 Comment: 
 
-Filename: gustav/frontends/__init__.py
+Filename: gustav/forms/localization.py
 Comment: 
 
-Filename: gustav/frontends/tk.py
+Filename: gustav/forms/nafc.py
 Comment: 
 
-Filename: gustav/frontends/pylabconfig.py
+Filename: gustav/forms/rt.py
 Comment: 
 
-Filename: gustav/frontends/qt.py
+Filename: gustav/forms/speech.py
 Comment: 
 
-Filename: gustav/methods/__init__.py
+Filename: gustav/frontends/__init__.py
 Comment: 
 
-Filename: gustav/methods/constant.py
+Filename: gustav/frontends/term.py
 Comment: 
 
-Filename: gustav/methods/adaptive.py
+Filename: gustav/frontends/tk.py
 Comment: 
 
-Filename: gustav/user_scripts/test_gustav_lateralizationForm_Joystick.py
+Filename: gustav/methods/__init__.py
 Comment: 
 
-Filename: gustav/user_scripts/test_gustav_closedSetForm.py
+Filename: gustav/methods/adaptive.py
 Comment: 
 
-Filename: gustav/user_scripts/gustav_exp__constantStim_gui.py
+Filename: gustav/methods/constant.py
 Comment: 
 
-Filename: gustav/user_scripts/test_gustav_lateralizationForm.py
+Filename: gustav/methods/pest.py
 Comment: 
 
-Filename: gustav/user_scripts/gustav_exp__constantStim_nogui.py
+Filename: gustav/user_scripts/gustav_exp__adaptive__frequency_discrim.py
 Comment: 
 
 Filename: gustav/user_scripts/gustav_exp__adaptive_quietthresholds.py
 Comment: 
 
-Filename: gustav/user_scripts/gustav_exp__ild_sensitivity.py
-Comment: 
-
-Filename: gustav/user_scripts/test_gustav_speechForm.py
-Comment: 
-
-Filename: gustav/user_scripts/gustav_run.py
-Comment: 
-
-Filename: gustav/user_scripts/gustav_exp__ClosedSetSpeech.py
-Comment: 
-
-Filename: gustav/user_scripts/gustav__puretone_quietthresholds.py
-Comment: 
-
-Filename: gustav/user_scripts/test_gustav_adaptiveForm.py
-Comment: 
-
-Filename: gustav-0.4.7.13.dist-info/DESCRIPTION.rst
+Filename: gustav/user_scripts/gustav_exp__lateralization.py
 Comment: 
 
-Filename: gustav-0.4.7.13.dist-info/metadata.json
+Filename: gustav-0.8.1.dist-info/LICENSE.md
 Comment: 
 
-Filename: gustav-0.4.7.13.dist-info/top_level.txt
+Filename: gustav-0.8.1.dist-info/METADATA
 Comment: 
 
-Filename: gustav-0.4.7.13.dist-info/WHEEL
+Filename: gustav-0.8.1.dist-info/WHEEL
 Comment: 
 
-Filename: gustav-0.4.7.13.dist-info/METADATA
+Filename: gustav-0.8.1.dist-info/top_level.txt
 Comment: 
 
-Filename: gustav-0.4.7.13.dist-info/RECORD
+Filename: gustav-0.8.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## gustav/gustav.py

```diff
@@ -1,32 +1,30 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2014 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Psylab.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
-# Bug reports, bug fixes, suggestions, enhancements, or other 
-# contributions are welcome. Go to http://code.google.com/p/psylab/ 
-# for more information and to contribute. Or send an e-mail to: 
-# cbrown1@pitt.edu.
+# Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 import os
 from random import shuffle
 import sys
 import getopt
 import numpy as np
 from . import utils
 
@@ -84,104 +82,107 @@
 
     if experimentFile == None:
         experimentFile = exp.term.get_file(None, "Open Gustav Experiment File", "", "Python or Plain Text Files (*.py *.txt);;All files (*.*)")
         if experimentFile == '':
             exp.utils.log(exp, "Gustav cancelled at user request (Prompt for Experiment File)")
             return
 
-    if subjectID == None:
-        exp.subjID = exp.term.get_input(parent=None, title = "Gustav!", prompt = 'Enter a Subject ID:')
-        q = exp.quitKeys
-        q.append('')
-        if exp.subjID in q:
-            exp.utils.log(exp, "Gustav cancelled at user request (Prompt for Subject ID)")
-            return
-    else:
-        exp.subjID = str(subjectID)
-
+    exp.subjID = subjectID
     exp.experimentPath,exp.experimentFile = os.path.split(experimentFile)
     exp.experimentBase = os.path.splitext(exp.experimentFile)[0]
     exp.experimentFilePath = os.path.join(exp.experimentPath,exp.experimentFile)
     sys.path.append(exp.experimentPath)
     exp.experiment = __import__(exp.experimentBase)
 
     exp.experiment.setup( exp )
 
+    if not exp.subjID:
+        exp.utils.log(exp, "Warning: exp.subjID not assigned at startup. Be sure to set in setup.")
+
     exp.method_str = exp.method
     try:
         methodi = __import__('methods',globals(), locals(), exp.method_str)
     except ImportError:
-        raise Exception("Error importing experimental method: " + exp.method_str)
+        raise Exception(f"Error importing experimental method: {exp.method_str}")
     exp.method = getattr(methodi, exp.method_str)
 
     exp.utils.initialize_experiment( exp )
     if recordData is not None:
         exp.recordData = recordData
 
     if exp.recordData:
         got_dataString = False
         for datatype in exp.eventTypes:
-            if hasattr(exp, 'dataString_%s' % datatype):
+            if hasattr(exp, f'dataString_{datatype}'):
                 got_dataString = True
                 break
         if not got_dataString:
-            ret = exp.frontend.get_yesno(None, title = "Gustav!", 
+            ret = exp.frontend.get_yesno(None, title = "Gustav!",
                     prompt = "exp.recordData == True, but no dataStrings were found so no data will be record data.\nAre you sure you want to continue?")
-            if not ret:
+            if ret:
+                exp.utils.log(exp, "WARNING: No data will be recorded!")
+            else:
                 exp.utils.log(exp, "Gustav cancelled at user request (Prompt to record data)")
                 return
-            else:
-                exp.utils.log(exp, "WARNING: No data will be recorded!")
     else:
         exp.utils.log(exp, "WARNING: No data will be recorded!")
     if exp.var.order == 'menu':
         exp.utils.menu_condition( exp )
 
     if exp.run.gustav_is_go == False:
         exp.utils.log(exp, "Gustav cancelled at user request (Prompt to select conditions)")
         return
-    ret = exp.frontend.get_yesno(None, title = "Gustav!", prompt = "Ready to begin testing?")
-    if not ret:
-        exp.utils.log(exp, "Gustav cancelled at user request (Prompt to begin testing)")
-        return
 
-    exp.utils.update_time(exp.run)
-    if not os.path.isfile(exp.dataFile):
-        exp.utils.save_data(exp, 'header')
-    exp.utils.do_event(exp, 'pre_exp')
-    exp.run.trials_exp = 0
     exp.run.gustav_is_go = True
+    exp.utils.do_event(exp, 'pre_exp')
+    # TODO: pull out event parsing code from initialize_experiment function (utils.py:235),
+    # into its own function and call it here, so experimenter can set methods etc in setup 
+    # and event priorities in pre_exp. See `priority` at bottom of utils.py
+    if not exp.run.gustav_is_go:
+        exp.utils.log(exp, "Gustav cancelled (via pre_exp)")
+    else:
+        exp.utils.update_time(exp.run)
+        if not os.path.isfile(exp.dataFile):
+            exp.utils.save_data(exp, 'header')
+        exp.run.trials_exp = 0
+
     while exp.run.gustav_is_go:
         if exp.var.order == 'prompt':
             exp.prompt_condition(exp)
         else:
             exp.run.condition = exp.var.orderarray[exp.run.block]
         if exp.var.order == 'prompt' or exp.run.condition+1 not in exp.var.ignore:
             exp.run.trials_block = 0
             exp.utils.get_current_variables(exp)
             exp.utils.do_event(exp, 'pre_block')
             exp.run.block_on = True
             while exp.run.block_on:
                 exp.run.trial_on = True
                 while exp.run.trial_on:
                     exp.utils.do_event(exp, 'pre_trial')
-                    exp.present_trial(exp)
-                    exp.prompt_response(exp)
-                    exp.utils.do_event(exp, 'post_trial')
-                    exp.run.trials_block += 1
-                    exp.run.trials_exp += 1
-
+                    if exp.run.gustav_is_go: exp.present_trial(exp)
+                    if exp.run.gustav_is_go: exp.prompt_response(exp)
+                    if exp.run.gustav_is_go: exp.utils.do_event(exp, 'post_trial')
+                    if exp.run.gustav_is_go:
+                        exp.run.trials_block += 1
+                        exp.run.trials_exp += 1
+                    else:
+                        exp.run.trial_on = False
+                        exp.run.block_on = False
             exp.utils.do_event(exp, 'post_block')
             exp.run.block += 1
             if exp.var.order != 'prompt' and exp.run.block == exp.run.nblocks:
                 exp.run.gustav_is_go = False
 
     # End gustav_is_go loop
     exp.utils.do_event(exp, 'post_exp')
+    if exp.logConsoleDelay:
+        print(exp.logConsoleDelay_str)
 
+    
 def main(argv):
     experimentFile = None
     subjectID = None
     frontend = None
     recordData = None
     action = 'run'
     try:
@@ -211,8 +212,7 @@
     elif action in ('list'):
         info(experimentFile = experimentFile, frontend = frontend)
     else:
         run(experimentFile = experimentFile, subjectID = subjectID, frontend = frontend, recordData = recordData)
 
 if __name__ == '__main__':
     main(sys.argv[1:])
-
```

## gustav/utils.py

```diff
@@ -1,39 +1,38 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2014 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Psylab.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
-# Bug reports, bug fixes, suggestions, enhancements, or other 
-# contributions are welcome. Go to http://code.google.com/p/psylab/ 
-# for more information and to contribute. Or send an e-mail to: 
-# cbrown1@pitt.edu.
+# Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 import os, sys, fnmatch
 import numpy as np
 import socket
 import datetime
 import codecs
 import types
 import collections
+import textwrap
 from time import sleep
 from inspect import getmembers
 from functools import reduce
 from .frontends import term
 
 #TODO: Modularize/standardize input methods. 
 # That is, implement modular, reuseable input methods that can be 
@@ -82,29 +81,31 @@
     logString_post_trial = None#Write this string to the console and/or logfile after every trial
     logString_post_block = None#Write this string to the console and/or logfile after every block
     logString_post_exp = None  #Write this string to the console and/or logfile at end of exp
     logString_header = "# A log file for Gustav\n\n" #Write this string to the logfile if it is new
     logFile = 'gustav_logfile_$date.log'
     logFile_unexpanded = ""
     logConsole = True
+    logConsoleDelay = False
+    logConsoleDelay_str = ''
     dataString_pre_exp = ''    #Write this string to datafile at exp begin
     dataString_pre_block = ''  #Write this string to datafile before every block
     dataString_pre_trial = ''  #Write this string to datafile before every trial
     dataString_post_trial = '' #Write this string to datafile after every trial
     dataString_post_block = '' #Write this string to datafile after every block
     dataString_post_exp = ''   #Write this string to datafile at exp end
     dataString_header = '#A data file for Gustav\n\n'#Write this string to datafile if the file is new
     dataFile ='$name.csv'
     dataFile_unexpanded =''
     recordData = True
     comments = ''
     disable_functions = []          # Experimenter can add function names as strings to disable them
     quitKeys = ['/', 'q']
     eventTypes = [ 'pre_exp', 'pre_block', 'pre_trial', 'post_trial', 'post_block', 'post_exp' ]
-    frontendTypes = ['qt', 'tk', 'term']
+    frontendTypes = ['tk', 'term']
     from .frontends import term
 
     def prompt_response(self,exp):
         while True:
             ret = exp.frontend.get_input(None, "Gustav!","Enter Response: ")
             # Check for quit
             if ret in exp.quitKeys:
@@ -207,79 +208,89 @@
 
 
 def initialize_experiment( exp ):
     """Do stuff necessary for the start of an experiment
     """
     logpath = os.path.split(exp.logFile)
     if not os.path.isdir(logpath[0]):
-        print("Created logfile path: {}".format(logpath[0]))
+        print(f"Created logfile path: {logpath[0]}")
         os.makedirs(logpath[0])
     else:
-        debug(exp, "Found logfile path: {}".format(logpath[0]))
+        debug(exp, f"Found logfile path: {logpath[0]}")
     # For logfile name, we expand date and exp name only and dont do full  
     # variable expansion because many variables haven't been set yet.
     date = datetime.datetime.now().strftime('%Y-%m-%d')
     exp.logFile = exp.logFile.replace("$date", date)
     exp.logFile = exp.logFile.replace("$name", exp.name)
     exp.logFile = exp.logFile.replace("$host", exp.host)
     if not os.path.isfile(exp.logFile):
         exp.logString_header = exp.logString_header.replace("$date", date)
         write_data(exp.logString_header, exp.logFile)
-        debug(exp, "Created log file: {}".format(exp.logFile))
+        debug(exp, f"Created log file: {exp.logFile}")
     else:
-        debug(exp, "Found log file: {}".format(exp.logFile))
+        debug(exp, f"Found log file: {exp.logFile}")
 
     exp.utils.get_frontend(exp, exp.frontend)
-    debug(exp, "Got frontend: {}".format(exp.frontend.name))
+    debug(exp, f"Got frontend: {exp.frontend.name}")
     # For each event type, look for a function in method, and in experiment.
     # If a function is found, add to list to be run during that event. 
+    # TODO: This code needs to go into its own function to facilitate priorities,
+    # and refactored so that functions from arbitrary scripts can be 
+    # registered. Pull code from gustav.py:101 to register scripts. This 
+    # will allow tremendous flexibility, eg., custom prompt_response,
+    # or moving form screen updates to the actual forms, etc.
     for event in exp.eventTypes:
         if hasattr(exp.method, event):
-            thisstr = "{}_".format(event)
+            thisstr = f"{event}_"
             thisfunclist = getattr(exp, thisstr)
             thisfunclist.append(getattr(exp.method, event))
-            debug(exp, "Found event in method: {}".format(event))
+            debug(exp, f"Found event in method: {event}")
         if hasattr(exp.experiment, event):
-            thisstr = "{}_".format(event)
+            thisstr = f"{event}_"
             thisfunclist = getattr(exp, thisstr)
             thisfunclist.append(getattr(exp.experiment, event))
-            debug(exp, "Found event in experiment: {}".format(event))
+            debug(exp, f"Found event in experiment: {event}")
 
     # A few 'special' events that should only occur (if at all) in the experiment file:
     if hasattr(exp.experiment, "present_trial"):
         exp.present_trial = exp.experiment.present_trial
         debug(exp, "Found event in experiment: present_trial")
     if hasattr(exp.experiment, "prompt_response"):
         exp.prompt_response = exp.experiment.prompt_response
         debug(exp, "Found event in experiment: prompt_response")
     if hasattr(exp.experiment, "prompt_condition"):
         exp.prompt_condition = exp.experiment.prompt_condition
         debug(exp, "Found event in experiment: prompt_condition")
+    if hasattr(exp.experiment, "exception"):
+        exp.exception = exp.experiment.exception
+        debug(exp, "Found event in experiment: exception")
+
 
     exp.utils.process_variables(exp)
     exp.run.nblocks = exp.var.nblocks
     if exp.recordData:
         debug(exp, "Data will be recorded")
         datapath = os.path.split(exp.dataFile)
         if not os.path.isdir(datapath[0]):
             os.makedirs(datapath[0])
-            debug(exp, "Created datafile path: {}".format(datapath[0]))
+            debug(exp, f"Created datafile path: {datapath[0]}")
         else:
-            debug(exp, "Found datafile path: {}".format(datapath[0]))
+            debug(exp, f"Found datafile path: {datapath[0]}")
         exp.dataFile_unexpanded = exp.dataFile
         exp.dataFile = get_expanded_vals_in_string(exp.dataFile, exp)
         if not os.path.isfile(exp.dataFile):
             exp.dataString_header = get_expanded_vals_in_string(exp.dataString_header, exp)
             write_data(exp.dataString_header, exp.dataFile)
-            debug(exp, "Created datafile: {}".format(exp.dataFile))
+            debug(exp, f"Created datafile: {exp.dataFile}")
         else:
-            debug(exp, "Found datafile: {}".format(exp.dataFile))
+            debug(exp, f"Found datafile: {exp.dataFile}")
     else:
         debug(exp, "Data will not be recorded")
 
+
 def process_variables(exp):
     """Processes conditions
         Factorialize all 'factorial' conditions, and add all 'covariable' conditions
         For each variable, make a list of levels for each condition
     """
 
     # Begin get number of levels
@@ -290,35 +301,35 @@
     if len(exp.var.factorial) > 0:
         exp.var.nlevels_fact = 1
         for v in exp.var.factorial:
             exp.var.levelsbycond[v] = []
             exp.var.varlist.append(v)
             nfact[v] = len(exp.var.factorial[v])
             exp.var.nlevels_fact *= nfact[v]
-            debug(exp, "Found factorial variable: {} [{:} levels]".format(v, len(exp.var.factorial[v])))
+            debug(exp, f"Found factorial variable: {v} [{len(exp.var.factorial[v])} levels]")
 
         factorial = exp.var.varlist
     nlist = 0
     for v in exp.var.covariable:
         if v not in exp.var.levelsbycond.keys():
             exp.var.levelsbycond[v] = []
         covariable.append(v)
         ncov[v] = len(exp.var.covariable[v])
         if nlist == 0 or nlist == 1:
             nlist = ncov[v]
         else:
             if nlist != ncov[v] and ncov[v] != 1:
                 raise Exception("All 'covariable' variables must either have the same number of levels, or one level")
-        debug(exp, "Found list variable: {} [{:} levels]".format(v, len(exp.var.covariable[v])))
+        debug(exp, f"Found list variable: {v} [{len(exp.var.covariable[v])} levels]")
     if len(factorial) == 0:
         for v in exp.var.covariable:
             exp.var.varlist.append(v)
     exp.var.nlevels_list = nlist
     exp.var.nlevels_total = exp.var.nlevels_fact + exp.var.nlevels_list
-    debug(exp, "Counted total conditions: {:} [{:} fact, {:} list]".format(exp.var.nlevels_total, exp.var.nlevels_fact, exp.var.nlevels_list))
+    debug(exp, f"Counted total conditions: {exp.var.nlevels_total} [{exp.var.nlevels_fact} fact, {exp.var.nlevels_list} list]")
     # End get number of levels
 
     # Begin process conditions
     if exp.var.nlevels_fact > 0:
         i = 0
         done = 1
         todo = exp.var.nlevels_fact
@@ -344,27 +355,28 @@
             gotvar = False
             if not v in covariable:
                 # Variable is in factorial but not mentioned in covariable.
                 if len(exp.var.factorial[v]) == 1:
                     # There is only 1 level specified in factorial. Use that for all 'covariable' conditions for that var.
                     for condition in range(exp.var.nlevels_list):
                         exp.var.levelsbycond[v].append(exp.var.factorial[v][0])
+                        print (f"{v}: {exp.var.factorial[v][0]}")
                     gotvar = True
             elif len(exp.var.covariable[v]) == 1:
                 # There is only one level specified. Use that for all conditions for that var.
                 for condition in range(exp.var.nlevels_list):
                     exp.var.levelsbycond[v].append(exp.var.covariable[v][0])
                 gotvar = True
             elif len(exp.var.covariable[v]) == exp.var.nlevels_list:
                 # More than one level specified. Use them all.
                 for condition in range(exp.var.nlevels_list):
                     exp.var.levelsbycond[v].append(exp.var.covariable[v][condition])
                 gotvar = True
             if not gotvar:
-                raise Exception("Unable to process the following variable: {}".format(v))
+                raise Exception(f"Unable to process the following variable: {v}")
 
     # Process order
     if exp.var.order == "random":
         exp.var.orderarray = np.random.permutation(exp.var.nlevels_total)
         exp.var.nblocks = exp.var.nlevels_total
     elif exp.var.order == "natural":
         exp.var.orderarray = np.arange(exp.var.nlevels_total)
@@ -372,18 +384,32 @@
     elif exp.var.order == "prompt":
         exp.var.orderarray = []
         exp.var.nblocks = 999
     elif exp.var.order == "menu":
         exp.var.orderarray = []
         exp.var.nblocks = 0
     else:
-        exp.var.orderarray = str_to_range(exp.var.order)
+        # If not one of the above, could be a string range and/or contain 'xn' feature
+        # Loop looks for a range, which could be just a number eg '4' or a range '2-4'
+        got_range = False
+        items = exp.var.order.split(',')
+        for item in items:
+            if not item.strip() in ['random', 'rand', 'r'] and not item.strip().startswith('x'):
+                got_range = True
+
+        if not got_range:
+            # No range was specified, assume form 'r, x2' or similar, in 
+            # which case all conditions are desired; so add all conditions
+            items.append(f'1-{exp.var.nlevels_total}')
+        exp.var.orderarray = str_to_range(','.join(items))
         exp.var.nblocks = len(exp.var.orderarray)
-    debug(exp, "Got presentation order input string: {}".format(exp.var.order))
-    debug(exp, "Generated presentation order: {}".format(", ".join(str(i) for i in exp.var.orderarray)))
+
+    debug(exp, f"Got presentation order input string: {exp.var.order}")
+    if len(exp.var.orderarray) > 0:
+        debug(exp, "Generated presentation order: {}".format(", ".join(str(i) for i in exp.var.orderarray)))
 # End process_variables
 
 
 def get_current_variables(exp):
     """Get current levels of each variable for a given condition
     """
     condition = exp.run.condition
@@ -394,15 +420,16 @@
             ret = exp.frontend.get_input(prompt = "Enter a value for variable: {}\nor hit enter for current level ({}): ".format(v, exp.var.levelsbycond[v][condition]))
             if ret == "":
                 exp.var.current[v] = exp.var.levelsbycond[v][condition]
             else:
                 exp.var.current[v] = ret
         else:
             exp.var.current[v] = exp.var.levelsbycond[v][condition]
-        debug(exp, "Getting level: {}; for variable: {}".format(exp.var.current[v],v))
+        debug(exp, f"Getting level: {exp.var.current[v]}; for variable: {v}")
+
 
 def get_variable_strtable(exp):
     """Creates a table specifying the levels of each variable for each condition
     """
     vlength = {}
     out = "Condition"
     for v in exp.var.varlist:
@@ -412,14 +439,15 @@
     for i in range(exp.var.nlevels_total):
         out += "{: >9d}".format(i+1)
         for v in exp.var.varlist:
             out += "{{: >{:}}}".format(vlength[v]).format(exp.var.levelsbycond[v][i])
         out += "\n"
     return out
 
+
 def menu_condition(exp):
     """Prompts the experiment to choose the conditions to run
     """
     debug(exp, "Deriving presentation order via menu")
     strtable = exp.utils.get_variable_strtable(exp)
     sel = []
     conditions = []
@@ -500,62 +528,77 @@
 
 def log(exp, message):
     """Writes info to the console, to a log file, or both
     """
     if message is not None and message != '':
         message_exp = exp.utils.get_expanded_vals_in_string(message, exp)
         if exp.logConsole:
-            print(message_exp),
-        if exp.logFile is not None and exp.logFile is not '':
+            if exp.logConsoleDelay:
+                exp.logConsoleDelay_str += message_exp
+            else:
+                print(message_exp),
+        #if exp.logFile is not None and exp.logFile is not '':
+        if exp.logFile != None and exp.logFile != '':
             write_data(message_exp, exp.logFile)
 
     
 def debug(exp, message):
     """Writes debug info to the console, to a log file, or both
     """
     if exp.debug:
         time = datetime.datetime.now().strftime('%H:%M:%S')
         date = datetime.datetime.now().strftime('%Y-%m-%d')
-        dmessage = "DEBUG {},{}: {}".format(date, time, message)
+        dmessage = f"DEBUG {date},{time}: {message}"
         if exp.logConsole:
-            print(dmessage)
-        if exp.logFile is not None and exp.logFile is not '':
+            if exp.logConsoleDelay:
+                exp.logConsoleDelay_str += message_exp
+            else:
+                print(dmessage)
+        #if exp.logFile is not None and exp.logFile is not '':
+        if exp.logFile != None and exp.logFile != '':
             if dmessage[-1:] != "\n":
                 dmessage += "\n"
             write_data(dmessage, exp.logFile)
 
         
 def do_event(exp, event):
     debug(exp, "Begin Event: {}".format(event))
     exp.utils.update_time(exp.run)
-    if hasattr(exp, "{}_".format(event)):
-        funcs = getattr(exp, "{}_".format(event))
+    if hasattr(exp, f"{event}_"):
+        funcs = getattr(exp, f"{event}_")
         for f in funcs:
             if f.__name__ not in exp.disable_functions:
-                f(exp)
-    if hasattr(exp, "logString_{}".format(event)):
-        exp.utils.log(exp, getattr(exp, "logString_{}".format(event)))
-    if hasattr(exp, "dataString_{}".format(event)):
-        exp.utils.save_data(exp, getattr(exp, "dataString_{}".format(event)))
-    debug(exp, "End Event: {}".format(event))
-        
+                if hasattr(exp, "exception"):
+                    try:
+                        f(exp)
+                    except:
+                        exp.exception(exp)
+                else:
+                    f(exp)
+    if hasattr(exp, f"logString_{event}"):
+        exp.utils.log(exp, getattr(exp, f"logString_{event}"))
+    if hasattr(exp, f"dataString_{event}"):
+        exp.utils.save_data(exp, getattr(exp, f"dataString_{event}"))
+    debug(exp, f"End Event: {event}")
         
+    
 def get_frontend(exp, frontend):
     """Tries to load the specified frontend
     """
     frontend_s = frontend
     if frontend_s not in exp.frontendTypes:
         exp.utils.log(exp, "Unknown frontend. Using tk")
         frontend = "tk"
     try:
         frontend = __import__("frontends",globals(), locals(), frontend)
     except ImportError:
-        raise Exception("Could not import frontend: {}".format(frontend))
+        raise Exception(f"Could not import frontend: {frontend}")
     exp.frontend = getattr(frontend, frontend_s)
-    debug(exp, "Got frontend: {}".format(exp.frontend.name))
+    debug(exp, f"Got frontend: {exp.frontend.name}")
+
 
 def obj_to_str(obj, name, indent=""):
     """Returns formatted, python-callable string representations of objects
         including classes, dicts, lists, and other built-in var types
     """
     if isinstance(obj, dict):
         outstr = "{}{} = {{\n".format(indent, name)
@@ -605,17 +648,26 @@
                             instead of just 'val'
         @currentvars     : Same as currentvars, but you will get var names 
                             instead of values (eg., for datafile header). 
         $user[varname]   : The value of a user variable
         $stim[varname]   : The value of a stim variable
     """
 
+    got_wv = True
+    while got_wv:
+        key,val = get_arg(instr, '$comment')
+        if key:
+            val_wrapped = textwrap.wrap(val, initial_indent='# ')
+            instr = instr.replace(key, val_wrapped)
+        else:
+            got_wv = False
+
     outstr = instr.replace("$name", exp.name)
-    outstr = outstr.replace("$note", exp.note)
-    outstr = outstr.replace("$comments", "\n# ".join(exp.comments.split('\n')) )
+    outstr = outstr.replace("$note", "\n# ".join(exp.note.split('\n')) )
+    #outstr = outstr.replace("$comments", "\n# ".join(exp.comments.split('\n')) )
     outstr = outstr.replace("$host", exp.host)
     outstr = outstr.replace("$subj", exp.subjID)
     outstr = outstr.replace("$trial_block", str(exp.run.trials_block+1))
     outstr = outstr.replace("$trial", str(exp.run.trials_exp+1))
     outstr = outstr.replace("$blocks", str(exp.run.nblocks))
     outstr = outstr.replace("$block", str(exp.run.block+1))
     outstr = outstr.replace("$conditions", str(exp.var.nlevels_total))
@@ -624,15 +676,15 @@
     outstr = outstr.replace("$date", exp.run.date)
     outstr = outstr.replace("$response", exp.run.response)
 
     # This func gets called from setup (for datafilename), and exp.var.current is not set at that point
     if len(exp.var.current)>0:
         currentvars = []
         currentvarsvals = []
-        for key, val in exp.var.current.iteritems():
+        for key, val in exp.var.current.items():
             currentvars.append(val)
             currentvarsvals.append("{} = {}".format(key, val))
             outstr = outstr.replace("$var[{}]".format(key), val)
 
         got_cv = True
         while got_cv:
             expr, delim = get_arg(outstr,"$currentvarsvals")
@@ -711,46 +763,90 @@
         return "",""
 
 
 def str_to_range(s):
     """Translate a print-range style string to a list of integers
 
       The input should be a string of comma-delimited values, each of
-      which can be either a number, or a colon-delimited range. If the
-      first token in the list is the string "random" or "r", then the
-      output list will be randomized before it is returned ("r,1:10").
+      which can be either a number, or a colon-delimited range. 
+
+      If one of the tokens in the list is the string "random" or "r",  
+      then the returned list will be randomized ("r,1:10").
+
+      If one of the tokens in the list is the string 'xn' where n is an
+      integer, the returned list will be made up of the input list, 
+      concatenated n times. 
+
+      Both 'r' and 'xn' can be used together
 
       >>> str_to_range('1:5, 20, 22')
       [1, 2, 3, 4, 5, 20, 22]
+
+      >>> str_to_range('x2, 1:5, 20, 22')
+      [1, 2, 3, 4, 5, 20, 22, 1, 2, 3, 4, 5, 20, 22]
+
+      >>> str_to_range('r, 1:5, 20, 22')
+      [4, 20, 1, 2, 22, 5, 3]
+
+      >>> str_to_range('r, x2, 1:5, 20, 22')
+      [4, 20, 1, 2, 22, 5, 3, 1, 5, 20, 4, 2, 3, 22]
+
     """
     s = s.strip()
     randomize = False
+    xtimes = 1
     if s.count(":"):
-        tokens = [x.strip().split(":") for x in s.split(",")]
+        tokens_in = [x.strip().split(":") for x in s.split(",")]
     else:
-        tokens = [x.strip().split("-") for x in s.split(",")]
+        tokens_in = [x.strip().split("-") for x in s.split(",")]
 
-    if tokens[0][0] in ["random","r","rand"]:
-        randomize = True
-        tokens = tokens[1:]
+    tokens_out = []
+    for i in range(len(tokens_in)):
+        if tokens_in[i][0].startswith('r'):
+            randomize = True
+        elif tokens_in[i][0].startswith('x'):
+            xtimes = int(tokens_in[i][0][1:])
+        else:
+            tokens_out.append(tokens_in[i])
 
     # Translate ranges and enumerations into a list of int indices.
     def parse(x):
         if len(x) == 1:
             if x == [""]:  # this occurs when there are trailing commas
                 return []
             else:
                 #return map(int, x)
                 return [int(x[0])-1]
         elif len(x) == 2:
             a,b = x
-            return range(int(a)-1, int(b))
+            return list(range(int(a)-1, int(b)))
         else:
             raise ValueError
 
-    result = reduce(list.__add__, [parse(x) for x in tokens])
-
-    if randomize:
-        np.random.shuffle(result)
+    result = []
+    for i in range(xtimes):
+        this_result = reduce(list.__add__, [parse(x) for x in tokens_out])
+        if randomize:
+            np.random.shuffle(this_result)
+        result += this_result
 
     return result
 
+
+def priority(level):
+    """Provides a decorator to set a priority level to a function
+
+        Use this decorator with events in an experiment script, and it 
+        will be used by gustav to determine the order in which to run 
+        multiple events of the same name, eg., pre_trial from method, 
+        experiment, etc.
+
+        usage:
+
+            @priority(50)
+            def pre_trial(exp):
+                pass
+    """ 
+    def wrapper(func):
+        setattr(func, 'priority', level)
+        return func
+    return wrapper
```

## gustav/__init__.py

```diff
@@ -1,32 +1,30 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2014 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Psylab.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
-# Bug reports, bug fixes, suggestions, enhancements, or other 
-# contributions are welcome. Go to http://code.google.com/p/psylab/ 
-# for more information and to contribute. Or send an e-mail to: 
-# cbrown1@pitt.edu.
+# Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 """Gustav: An event-based framework for psychophysical experiments
 
     Gustav tries to handle all of the aspects of experimentation that are 
     common across experiments (organizing and enumerating experimental 
     variables, the psychophysical procedure, interacting with subjects, 
     logging, saving data, etc.), and leaves to the experimenter the aspects 
     that are unique to each experiment (stimulus generation and delivery, etc). 
@@ -37,11 +35,11 @@
     set, such as the name of the experiment, where and how to save data, what 
     the experimental variables and their levels are, and so on. The best way 
     to understand how one works is to have a look at one. See the test_gustav 
     python scripts in the user_scripts directory for more information.
 
 """
 
-__version__ = '0.4.7.13'
+__version__ = '0.8.1'
 
 from .gustav import run, info, main
-from . import frontends, methods
+from . import frontends, methods, forms
```

## gustav/frontends/term.py

```diff
@@ -1,81 +1,69 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2012 Christopher Brown
+# Copyright (c) 2010-2019 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of Gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# Gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# Gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+# along with Gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
 # Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 import os, sys
-try:
-    # Python2
-    import Tkinter as tk
-    import tkFileDialog as filedialog
-except ImportError:
-    # Python3
-    import tkinter as tk
-    from tkinter import filedialog
 
 try: input = raw_input
 except: pass
 
 name = 'term'
 
-def show_config(exp,run,var,stim,user):
-    print("Sorry, there is no terminal version of the Experiment Configuration Dialog.")
-
 def get_file(parent=None, title = 'Open File', default_dir = "", file_types = ("All files (*.*)")):
     """Opens a file dialog, returns file path as a string
 
         To specify filetypes, use the (qt) format:
         "Python or Plain Text Files (*.py *.txt);;All files (*.*)"
     """
-    ftl = file_types.split(";;")
-    fts = []
-    for ft in ftl:
-        d,t = ft.split("(")
-        fts.append(tuple([d," ".join(t.strip(" )").split())]))
-    toplevel=tk.Tk()
-    toplevel.withdraw()
-    fname = filedialog.askopenfilename( title = title, initialdir = default_dir, filetypes = fts, multiple = False)
-    toplevel.deiconify()
-    toplevel.destroy()
-    if isinstance(fname, tuple):
-        # you suck tk
-        return ''
-    else:
-        return fname
+
+    getting_file = True
+    while getting_file:
+        ret = input("{} ({}): ".format(title, default_dir))
+        if not os.path.exists(ret):
+            print("File does not exist: {}".format(ret))
+        elif not os.path.isfile(ret):
+            print("Not a file: {}".format(ret))
+        else:
+            getting_file = False
+    return ret
+
 
 def get_folder(parent=None, title = 'Open Folder', default_dir = ""):
     """Opens a folder dialog, returns the path as a string
     """
-    toplevel=tk.Tk()
-    toplevel.withdraw()
-    fname = filedialog.askdirectory( title = title, initialdir = default_dir )
-    toplevel.deiconify()
-    toplevel.destroy()
-    if isinstance(fname, tuple):
-        return ''
-    else:
-        return fname
+    getting_folder = True
+    while getting_folder:
+        ret = input("{} ({}): ".format(title, default_dir))
+        if not os.path.exists(ret):
+            print("Path does not exist: {}".format(ret))
+        elif not os.path.isdir(ret):
+             print("Path is not a folder: {}".format(ret))
+        else:
+            getting_folder = False
+    return ret
 
 def get_item(parent=None, title = 'User Input', prompt = 'Choose One:', items = [], current = 0, editable = False):
     """Opens a simple prompt to choose an item from a list, returns a string
     """
     for ind, item in enumerate(items):
         print(" ",ind+1,". ", item)
     ret = input(prompt)
```

## gustav/frontends/__init__.py

```diff
@@ -1,24 +1,46 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2012 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Psylab.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
 # Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
-from . import qt, tk, term
+#try:
+#	from PyQt4 import QtGui, QtCore
+#except ImportError:
+#	pass
+#else:
+#	from . import qt
 
+try:
+    # Python2
+    import Tkinter
+    import tkFileDialog, tkSimpleDialog, tkMessageBox
+except ImportError:
+	try:
+	    # Python3
+	    import tkinter
+	    from tkinter import filedialog, simpledialog, messagebox
+	except ImportError:
+		pass
+	else:
+		from . import tk
+else:
+	from . import tk
+
+from . import term
```

## gustav/frontends/tk.py

```diff
@@ -1,43 +1,41 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2012 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
 # Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 try:
     # Python2
     import Tkinter as tk
     import tkFileDialog as filedialog, tkSimpleDialog as simpledialog, tkMessageBox as messagebox
 except ImportError:
     # Python3
     import tkinter as tk
     from tkinter import filedialog, simpledialog, messagebox
 
 name = 'tk'
 
-def show_config(exp,run,var,stim,user):
-    print("Sorry, there is no tk version of the Experiment Configuration Dialog.")
-
 def get_file(parent=None, title = 'Open File', default_dir = "", file_types = ("All files (*.*)")):
     """Opens a file dialog, returns file path as a string
 
         To specify filetypes, use the (qt) format:
         "Python or Plain Text Files (*.py *.txt);;All files (*.*)"
     """
     ftl = file_types.split(";;")
```

## gustav/methods/__init__.py

```diff
@@ -1,23 +1,23 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2012 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
 # Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
 from . import constant, adaptive
```

## gustav/methods/constant.py

```diff
@@ -1,29 +1,30 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2014 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Psylab.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
 # Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 """Method of constant stimuli for Gustav
 
     This method has three properties, which should be set in pre_exp:
     
     exp.var.constant = {
         'trialsperblock' : 10,
         'startblock' : 1,
@@ -40,34 +41,37 @@
     'trialsperblock' : 10,
     'startblock' : 1,
     'starttrial' : 1,
     }
 
 def pre_exp(exp):
     # Only set these if None, in case they were set in experiment file setup, which has run already
-    if not exp.var.constant.has_key('trialsperblock'):
+#    if not exp.var.constant.has_key('trialsperblock'):
+    if 'trialsperblock' not in exp.var.constant:
         raise Exception("The following constant variables must be set: \n\nexp.var.constant['trialsperblock']\n")
-    if not exp.var.constant.has_key('startblock'):
+#    if not exp.var.constant.has_key('startblock'):
+    if 'startblock' not in exp.var.constant:
         exp.var.constant['startblock'] = 1
-    if not exp.var.constant.has_key('starttrial'):
+#    if not exp.var.constant.has_key('starttrial'):
+    if 'starttrial' not in exp.var.constant:
         exp.var.constant['starttrial'] = 1
 
     if exp.logString_pre_exp == None:
         exp.logString_pre_exp = "Experiment started: $name. Date: $date, Time: $time, Subject #: $subj\n"
     if exp.logString_pre_block == None:
         exp.logString_pre_block = "\n Block $block of $blocks started at $time; Condition: $condition ; $currentvarsvals[' ; ']\n"
     if exp.logString_post_trial == None:
         exp.logString_post_trial = " Trial $trial, Response: $response\n"
     if exp.logString_post_block == None:
         exp.logString_post_block = " Block $block of $blocks ended at $time; Condition: $condition ; $currentvarsvals[' ; ']\n"
     if exp.logString_post_exp == None:
         exp.logString_post_exp = "\nExperiment ended: $name. Date: $date, Time: $time, Subject #: $subj\n"
         
     exp.run.block = exp.var.constant['startblock']-1
-        
+    
     if exp.run.block >= exp.run.nblocks - 1:
         exp.run.gustav_is_go = False
 
 def pre_block(exp):
     if exp.run.block == exp.var.constant['startblock'] - 1:
         exp.run.trials_block = exp.var.constant['starttrial'] - 1
         exp.run.trials_exp = (exp.var.constant['trialsperblock'] * (exp.var.constant['startblock']-1)) + (exp.run.trials_block)
```

## gustav/methods/adaptive.py

```diff
@@ -1,29 +1,30 @@
 # -*- coding: utf-8 -*-
 
-# Copyright (c) 2010-2014 Christopher Brown
+# Copyright (c) 2010-2020 Christopher Brown
 #
-# This file is part of Psylab.
+# This file is part of gustav.
 #
-# Psylab is free software: you can redistribute it and/or modify
+# gustav is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 #
-# Psylab is distributed in the hope that it will be useful,
+# gustav is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License
-# along with Psylab.  If not, see <http://www.gnu.org/licenses/>.
+# along with gustav.  If not, see <http://www.gnu.org/licenses/>.
 #
 # Comments and/or additions are welcome. Send e-mail to: cbrown1@pitt.edu.
 #
 
+
 """Adaptive tracking method for Gustav
 
     This method has several required properties that must be set in pre_exp:
     
     exp.var.dynamic = {
             'name': '',          # Name of the dynamic variable
             'units': '',         # Units of the dynamic variable (dB, etc.)
@@ -203,23 +204,23 @@
             exp.run.block_on = False
             exp.var.dynamic['good_run'] = True
             exp.var.dynamic['msg'] = "{:} reversals reached".format(len(exp.var.dynamic['steps'])-1)
 
 def pre_block(exp):
     missing_vars = ''
     for key,val in dynamic_vars_user.items():
-        if not exp.var.dynamic.has_key(key):
+        if key not in exp.var.dynamic:
             missing_vars += "exp.var.dynamic['{}']\n".format(key)
     if missing_vars != '':
             raise Exception("The following dynamic variables must be set: \n\n{}".format(missing_vars))
     d = exp.var.dynamic.copy()
     exp.var.dynamic = dynamic_vars_block.copy()
     exp.var.dynamic.update(dynamic_vars_track.copy())
     exp.var.dynamic.update(d.copy())
-    if exp.var.dynamic.has_key('step'):
+    if 'step' in exp.var.dynamic:
         exp.dynamic_step = exp.var.dynamic['step']
     else:
         exp.dynamic_step = step
     exp.var.dynamic['value'] = exp.var.dynamic['val_start']
     exp.var.dynamic['values'] = []
     exp.var.dynamic['track'] = []
     exp.var.dynamic['values_at_rev'] = []
```

## gustav/user_scripts/gustav_exp__adaptive_quietthresholds.py

```diff
@@ -1,122 +1,50 @@
 # -*- coding: utf-8 -*-
 
 # A Gustav settings file!
 
 import os, sys
 import numpy as np
 import time
-import socket
-import psylab
-from gustav_forms import qt_adaptive as theForm
-#from brian import hears as bh
-#import brian as b
-import medussa as m
-#import signal_io
-
-def setup(exp,run,var,stim,user):
-
-    if os.name == 'posix':
-        basedir = r'/home/code-breaker/SpiderOak Hive/Python'
-        stimdir = r'/home/code-breaker/SpiderOak Hive/Lab/stim'
-    else:
-        basedir = r'C:\Users\code-breaker\Documents\Python'
-        basedir = r'C:\Documents and Settings\cabrown4\My Documents\Python'
-        #basedir = r'P:\Python'
+import gustav
+from gustav.forms.curses import nafc as theForm
+import psylab                              # https://github.com/cbrown1/psylab
+import medussa as m                        # https://github.com/cbrown1/medussa
+
+def setup(exp):
+    # setup gets called before the experiment begins
 
     # General Experimental Variables
-    exp.name = '_quiet_thresholds_'
-    exp.method = 'adaptive' # 'constant' for constant stimuli, or 'adaptive' for a staircase procedure (SRT, etc)
-    exp.prompt = 'Which interval?' # Prompt for subject
-    exp.frontend = 'qt'
-    exp.logFile = os.path.join(basedir,'logs','$name_$date.log')
-    exp.logConsole = True
-    exp.debug = False
-    exp.recordData = True
-    exp.dataFile = os.path.join(basedir,'data','exp_$subj.py')
+    exp.name = '_quiet_thresholds_'     # Experiment name. Accessible as $name when logging or recording data
+    exp.method = 'adaptive'             # 'constant' for constant stimuli, or 'adaptive' for a staircase procedure (SRT, etc)
+    exp.prompt = 'Which interval?'      # A prompt for subject
+    exp.frontend = 'tk'                 # The frontend to use when interacting with subject or experimenter. Can be 'term' or 'tk'
+    exp.logFile = './$name_$date.log'   # The path to the logfile
+    exp.logConsole = True               # Whether to direct log info to the console
+    exp.logConsoleDelay = True          # When using a curses form, the console is not available. Set to True to delay print until end of exp when curses form is destroyed.
+    exp.debug = False                   # Currently unused
+    exp.recordData = True               # Whether to record data
+    exp.dataFile = './$name_$subj.py'   # The name of the data file
     exp.dataString_trial = ''
     exp.dataString_block = ''
     exp.dataString_exp = ''
     exp.dataString_header = ''
-    exp.cacheTrials = False
-    exp.validKeys = '1,2';  # comma-delimited list of valid responses
+    exp.cacheTrials = False             # Currently unused
+    exp.validKeys = '1,2';              # comma-delimited list of valid responses
     exp.quitKey = '/'
-    exp.note = "Quiet thresholds of pure tones"
+    exp.note = "Quiet thresholds for pure tones"
     exp.comments = '''\
     '''
 
-    """STIMULUS SETS
-        If you generate all your stimuli on the fly, you don't need any of these.
-
-        The only required property is 'type', which should be either 'manual'
-        or 'files'. If it is manual, the experimenter is responsible for
-        handling it.
-
-        If 'type is set to 'soundfiles', each set needs two additional settings:
-
-        'path' is the full path to the folder containing the files
-
-        'fs' is the playback sampling frequency
-
-        There are several optional settings for soundfiles:
-
-        'text' is the full path to a text file that specifies text for each token.
-                There should be one line per token, and the format can be
-                specified (see below).
-
-        'txtfmt' If you're using a text file, you can specify the format here.
-                  You can specify 3 values, 'file', 'kw', and 'text'. The default
-                  format is 'file,kw,text' which in your file would look like:
-                  'CUNY001,4,They LOOKED UP at the BLUE SKY.' where CUNY001 is
-                  the filename [no extension], 4 is the number of keywords, and
-                  the rest of the line is the text. The text should always be
-                  last on the line, and the delimiter can be a comma or a space.
-
-        'mask' is a list of filemasks (e.g., '*.wav; *.WAV'). default = '*.*'
-
-        'load' is 'manual' to simply keep track of filenames, or 'auto' to load
-                stimuli automatically as well. default is 'auto'
-
-        'order' is the presentation order: 'random', 'natural', or a print
-                range style string, which should be a comma-separated list of
-                values, which can be either a single number, or a colon-delimited
-                range. Make the first item in the list the string 'random' to
-                randomize the list. default is 'natural'
-
-        'repeat' is whether to run through the list again if we run out. If this
-                is True and 'order' is random, a new random order will be
-                generated each time. If this is false, you must ensure that there
-                are enough stimulus files available. default is False
-    """
-
-#    stim.sets['CNC'] = {
-#                              'type':   'files',
-#                              'path':   os.path.join(stimdir,'CNC'),
-#                              'text':   '', #os.path.join(basedir,'stim','CUNYf','CUNY.txt'),
-#                              'txtfmt': 'file kw text',
-#                              'mask':   '*.wav; *.WAV',
-#                              'process':   'auto',  # 'auto' = Load stimuli automatically (default)
-#                              'order':  'r,1:500', #
-#                              'repeat': True,   # If we run out of files, should we start over?
-#                              'equate': 3,  # A custom value
-#                              'gammatone_folder' : os.path.join(stimdir,'gammatone_32','CNC'),
-#                            };
-
-#    stim.sets['Noise'] = {
-#                              'type':   'soundfiles',
-#                              'path':   os.path.join(basedir,'stim','noise','gammatone_32'),
-#                              'fs'  :   44100,
-#                              'text':   '', #os.path.join(basedir,'stim','CUNYf','CUNY.txt'),
-#                              'txtfmt': 'file kw text',
-#                              'mask':   '*.wav; *.WAV',
-#                              'load':   'manual',  # 'auto' = Load stimuli automatically (default)
-#                              'order':  'r,1:50', #
-#                              'repeat': True,    # If we run out of files, should we start over?
-#                              'equate': 3,  # A custom value
-#                            };
+    if not exp.subjID:
+        ret = input("Enter Subject ID (Or `\` to quit): ")
+        if ret == '\\':
+            exp.run.gustav_is_go = False
+        else:
+            exp.subjID = ret
 
     """EXPERIMENT VARIABLES
         There are 2 kinds of variables: factorial and ordered
 
         Levels added as 'factvars' variables will be factorialized with each
         other. So, if you have 2 fact variables A & B, each with 3 levels, you
         will end up with 9 conditions: A1B1, A1B2, A1B3, A2B1 etc..
@@ -150,40 +78,29 @@
         for file in stim['masker_files']:
             masker,fs,enc = utils.wavread(file)
             stim['masker'] += masker
         stim['masker'] = stim['masker'][0:stim['masker_samples_needed']]
     """
     # TODO: for python 2.7, change these to ordered dicts, where name is the key
     # and the dict {type, levels} is the val
-    
-    var.factorial.append( {  'name' : 'frequency',
-                            'type' : 'manual',   
-                          'levels' : [
-                                        '125',
-                                        '250',
-                                        '500',
-                                        '1000',
-                                      ]
-                        });
-    
-#    var.factorial.append( {  'name' : 'target',
-#                            'type' : 'stim',    # This variable will be drawn from stim. 'levels' must be stim set names
-#                          'levels' : [
-#                                        'CNC',
-#                                        #'Noise',
-#                                      ]
-#                        });
-
-    def step(exp,run,var,stim,user):
-        var.dynamic['value'] += var.dynamic['cur_step'] * var.dynamic['steps'][var.dynamic['n_reversals']]
-        var.dynamic['value'] = max(var.dynamic['value'], var.dynamic['val_floor'])
-        var.dynamic['value'] = min(var.dynamic['value'], var.dynamic['val_ceil'])
+
+    exp.var.factorial['frequency']= [
+                                    '125',
+                                    '250',
+                                    '500',
+                                    '1000',
+                                  ]
+    def step(exp):
+        # A custom step function for adaptive tracking. This is actually the same as the default one, here for demo purposes
+        exp.var.dynamic['value'] += exp.var.dynamic['cur_step'] * exp.var.dynamic['steps'][exp.var.dynamic['n_reversals']]
+        exp.var.dynamic['value'] = max(exp.var.dynamic['value'], exp.var.dynamic['val_floor'])
+        exp.var.dynamic['value'] = min(exp.var.dynamic['value'], exp.var.dynamic['val_ceil'])
 
 
-    var.dynamic = { 'name': 'Level',     # Name of the dynamic variable
+    exp.var.dynamic = { 'name': 'Level',     # Name of the dynamic variable
                     'units': 'dBSPL',    # Units of the dynamic variable
                     'alternatives': 2,   # Number of alternatives
                     'steps': [5, 5, 2, 2, 2, 2, 2, 2], # Stepsizes to use at each reversal (#revs = len)
                     #'steps': [2, 2],    # Stepsizes to use at each reversal (#revs = len)
                     'downs': 2,          # Number of 'downs'
                     'ups': 1,            # Number of 'ups'
                     'val_start': 50,     # Starting value
@@ -191,121 +108,129 @@
                     'val_floor': 0,      # Floor
                     'val_ceil': 70,      # Ceiling
                     'val_floor_n': 3,    # Number of consecutive floor values to quit at
                     'val_ceil_n': 3,     # Number of consecutive ceiling values to quit at
                     'run_n_trials': 0,   # Set to non-zero to run exactly that number of trials
                     'max_trials': 60,    # Maximum number of trials to run
                     'vals_to_avg': 6,    # The number of values to average
-                    'step': step,        # A custom step function. Signature: def step(exp,run,var,stim,user)
-                    'max_level': 80, 
+                    'step': step,        # optional. A custom step function. Signature: def step(exp)
+                    'max_level': 80,
                    }
 
     """CONDITION PRESENTATION ORDER
         Use 'prompt' to prompt for condition on each block, 'random' to randomize
         condition order, 'menu' to be able to choose from a list of conditions at
         the start of a run, 'natural' to use natural order (1:end), or a
         print-range style string to specify the order ('1-10, 12, 15'). You can
         make the first item in the print range 'random' to randomize the specified
         range.
     """
-    var.order = 'menu'
+    exp.var.order = 'random'
 
     """IGNORE CONDITIONS
         A list of condition numbers to ignore. These conditions will not be
         reflected in the total number of conditions to be run, etc. They will
         simply be skipped as they are encountered during a session.
     """
-    var.ignore = []
+    exp.var.ignore = []
 
     '''USER VARIABLES
         Add any additional variables you need here
     '''
-    user.fs = 44100
-    user.isi = 250 # ms
-    user.interval = 500
+    exp.user.fs = 44100
+    exp.user.isi = 250 # ms
+    exp.user.interval = 500
 
 """CUSTOM PROMPT
     If you want a custom response prompt, define a function for it
     here. run.response should receive the response as a string, and
     if you want to cancel the experiment, set both run.block_on and
     run.pylab_is_go to False
 """
-def prompt_response(exp,run,var,stim,user):
+def prompt_response(exp):
     while True:
-        #ret = exp.utils.getchar()
-        exp.interface.app.processEvents()
-        ret = exp.interface.get_char()
-        if str(ret) in exp.validKeys:
-            run.response = ret
+        ret = exp.interface.get_resp()
+        if ret in exp.validKeys:
+            exp.run.response = ret
             break
-        elif str(ret) in exp.quitKeys:
-            run.block_on = False
-            run.gustav_is_go = False
-            var.dynamic['msg'] = "Cancelled by user"
-            break;
-
-"""PRE_TRIAL
-    This function gets called on every trial to generate the stimulus, and
-    do any other processing you need. All settings and variables are
-    available. For the current level of a variable, use
-    var.current['varname']. 
-"""
-def pre_trial(exp,run,var,stim,user):
-    isi = np.zeros(psylab.signal.ms2samp(user.isi,user.fs))
-    interval_noi = np.zeros(user.interval/1000.*user.fs)
-    interval_sig = psylab.signal.tone(float(var.current['frequency']),user.fs,user.interval)
-    interval_sig = psylab.signal.ramps(interval_sig,user.fs)
-    interval_sig = psylab.signal.atten(interval_sig,var.dynamic['max_level']-var.dynamic['value'])
-
-    var.dynamic['correct'] = np.random.randint(1, var.dynamic['alternatives']+1)
-    if var.dynamic['correct'] == 1:
-        stim.out = np.hstack((interval_sig, isi, interval_noi))
+        elif ret in exp.quitKeys:
+            exp.run.gustav_is_go = False
+            exp.var.dynamic['msg'] = "Cancelled by user"
+            break
+
+def pre_trial(exp):
+    """PRE_TRIAL
+        This function gets called on every trial to generate the stimulus, and
+        do any other processing you need. All settings and variables are
+        available. For the current level of a variable, use
+        var.current['varname'].
+    """
+    exp.interface.update_Status_Right("Trial {:}".format(exp.run.trials_block), redraw=True)
+    isi = np.zeros(int(psylab.signal.ms2samp(int(exp.user.isi),int(exp.user.fs))))
+    interval_noi = np.zeros(int(exp.user.interval/1000.*exp.user.fs))
+    interval_sig = psylab.signal.tone(float(exp.var.current['frequency']),exp.user.fs,exp.user.interval)
+    interval_sig = psylab.signal.ramps(interval_sig,exp.user.fs)
+    interval_sig = psylab.signal.atten(interval_sig,exp.var.dynamic['max_level']-exp.var.dynamic['value'])
+
+    exp.var.dynamic['correct'] = np.random.randint(1, exp.var.dynamic['alternatives']+1)
+    if exp.var.dynamic['correct'] == 1:
+        exp.stim.out = np.hstack((interval_sig, isi, interval_noi))
     else:
-        stim.out = np.hstack((interval_noi, isi, interval_sig))
-        
-    
-def present_trial(exp, run, var, stim, user):
+        exp.stim.out = np.hstack((interval_noi, isi, interval_sig))
+
+
+def present_trial(exp):
     #pass
     #m.play_array(stim.out,user.fs)
-    exp.interface.button_light([1,2], None)
     time.sleep(.1)
-    s = exp.audiodev.open_array(stim.out,user.fs)
+    exp.interface.show_Notify_Left(False)    # Hide the 'press space' text since they just pressed it
+    exp.interface.show_Notify_Right(True)    # Show the listen text
+    exp.interface.show_Prompt(False)         # Don't show prompt during presentation b/c we don't want a response
+    exp.interface.show_Buttons(True, redraw=True) # Show buttons so user gets visual feedback on interfal playback
+    s = exp.audiodev.open_array(exp.stim.out,exp.user.fs)
     s.play()
-    exp.interface.button_light([1], 'yellow')
-    time.sleep(user.interval/1000.)
-    exp.interface.button_light([1], None)
-    time.sleep(user.isi/1000.)
-    exp.interface.button_light([2], 'yellow')
-    time.sleep(user.interval/1000.)
-    exp.interface.button_light([2], None)
-    time.sleep(.1)
+    for i in range(len(exp.interface.alternatives)):
+        exp.interface.set_border(i, 'Heavy', redraw=True)
+        time.sleep(exp.user.interval/1000.)
+        exp.interface.set_border(i, 'Light', redraw=True)
+        time.sleep(exp.user.isi/1000.)
+    exp.interface.show_Notify_Right(False)
+    exp.interface.show_Prompt(True, redraw=True)
+
 
-def post_trial(exp, run, var, stim, user):
-    exp.interface.button_light([1,2], None)
-    if run.gustav_is_go:
-        if str(var.dynamic['correct']).lower() == run.response.lower():
-            color = 'green'
+def post_trial(exp):
+#    exp.interface.button_light([1,2], None)
+    if exp.run.gustav_is_go:
+        if str(exp.var.dynamic['correct']).lower() == exp.run.response.lower():
+            color = 'Green'
         else:
-            color = 'red'
+            color = 'Red'
         for i in range(3):
-            exp.interface.button_light([var.dynamic['correct']], color)
+            exp.interface.set_color(exp.var.dynamic['correct']-1, color, redraw=True)
             time.sleep(.1)
-            exp.interface.button_light([var.dynamic['correct']], None)
+            exp.interface.set_color(exp.var.dynamic['correct']-1, 'None', redraw=True)
             time.sleep(.05)
 
-def pre_exp(exp,run,var,stim,user):
-    exp.interface = theForm.Interface(exp, run, exp.validKeys.split(","))
+def pre_exp(exp):
     exp.audiodev = m.open_device()
+    exp.interface = theForm.Interface(alternatives = exp.validKeys.split(","))
+    exp.interface.update_Title_Center(exp.note)
+    exp.interface.update_Title_Right("Subject {:}".format(exp.subjID) )
+    exp.interface.show_Buttons(False)
+    exp.interface.show_Notify_Left(False)
+    exp.interface.update_Notify_Right("Listen", show=False)
+    exp.interface.update_Prompt("Press any key to begin", show=True, redraw=True)
+    # Wait for a keypress
+    ret = exp.interface.get_resp()
+    exp.interface.update_Prompt("Which Interval?", show=False, redraw=True)
+
 
-def post_exp(exp,run,var,stim,user):
-    exp.interface.dialog.close()
+def post_exp(exp):
+    exp.interface.destroy()
 
-def pre_block(exp,run,var,stim,user):
-    exp.interface.dialog.blocks.setText("Block %g of %g" % (run.block+1, var.nblocks+1))
+def pre_block(exp):
+    exp.interface.update_Status_Center("Block {:} of {:}".format(exp.run.block+1, exp.var.nblocks+1))
 
 if __name__ == '__main__':
     argv = sys.argv[1:]
-    argv.append("--experimentFile=%s" % os.path.realpath(__file__))
-    psylab.gustav.main(argv)
-#    import inspect
-#    fname = inspect.getfile( inspect.currentframe() )
-#    psylab.gustav.run(settingsFile=fname)
+    argv.append("--experimentFile={}".format(os.path.realpath(__file__)))
+    gustav.main(argv)
```

## Comparing `gustav/user_scripts/gustav__puretone_quietthresholds.py` & `gustav/user_scripts/gustav_exp__adaptive__frequency_discrim.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,127 +1,50 @@
 # -*- coding: utf-8 -*-
 
 # A Gustav settings file!
 
 import os, sys
 import numpy as np
 import time
-import socket
-import psylab
-from gustav_forms import qt_Adaptive as theForm
-#from brian import hears as bh
-#import brian as b
-import medussa as m
-#import signal_io
+import gustav
+from gustav.forms.curses import nafc as theForm
+import psylab                              # https://github.com/cbrown1/psylab
+import medussa as m                        # https://github.com/cbrown1/medussa
 
 def setup(exp):
-
-    if os.name == 'posix':
-        basedir = r'/home/cbrown'
-#        stimdir = r'/home/code-breaker/SpiderOak Hive/Lab/stim'
-    else:
-        basedir = r'C:\Users\code-breaker\Documents\Python'
-        basedir = r'C:\Documents and Settings\cabrown4\My Documents\Python'
-        #basedir = r'P:\Python'
+    # setup gets called before the experiment begins
 
     # General Experimental Variables
-    exp.name = '_quiet_thresholds_'
-    exp.method = 'adaptive' # 'constant' for constant stimuli, or 'adaptive' for a staircase procedure (SRT, etc)
-    exp.prompt = 'Which interval?' # Prompt for subject
-    exp.frontend = 'qt'
-    exp.logFile = os.path.join(basedir,'logs','$name_$date.log')
-    exp.logConsole = True
-    exp.debug = False
-    exp.recordData = True
-    exp.dataFile = os.path.join(basedir,'data','exp_$subj.py')
+    exp.name = 'quiet_thresholds'     # Experiment name. Accessible as $name when logging or recording data
+    exp.method = 'adaptive'             # 'constant' for constant stimuli, or 'adaptive' for a staircase procedure (SRT, etc)
+    exp.prompt = 'Which interval?'      # A prompt for subject
+    exp.frontend = 'tk'                 # The frontend to use when interacting with subject or experimenter. Can be 'term' or 'tk'
+    exp.logFile = './$name__$date.log'   # The path to the logfile
+    exp.logConsole = True               # Whether to direct log info to the console
+    exp.logConsoleDelay = True          # When using a curses form, the console is not available. Set to True to delay print until end of exp when curses form is destroyed.
+    exp.debug = False                   # Currently unused
+    exp.recordData = True               # Whether to record data
+    exp.dataFile = './$name__$subj.py'   # The name of the data file
     exp.dataString_trial = ''
     exp.dataString_block = ''
     exp.dataString_exp = ''
     exp.dataString_header = ''
-    exp.cacheTrials = False
-    exp.validKeys = '1,2';  # comma-delimited list of valid responses
+    exp.cacheTrials = False             # Currently unused
+    exp.validKeys = '1,2';              # comma-delimited list of valid responses
     exp.quitKey = '/'
-    exp.note = "Quiet thresholds of pure tones"
+    exp.note = "Quiet thresholds for pure tones"
     exp.comments = '''\
     '''
 
-    """STIMULUS SETS
-        If you generate all your stimuli on the fly, you don't need any of these.
-
-        The only required property is 'type', which should be either 'manual'
-        or 'files'. If it is manual, the experimenter is responsible for
-        handling it.
-
-        If 'type is set to 'soundfiles', each set needs two additional settings:
-
-        'path' is the full path to the folder containing the files
-
-        'fs' is the playback sampling frequency
-
-        There are several optional settings for soundfiles:
-
-        'text' is the full path to a text file that specifies text for each token.
-                There should be one line per token, and the format can be
-                specified (see below).
-
-        'txtfmt' If you're using a text file, you can specify the format here.
-                  You can specify 3 values, 'file', 'kw', and 'text'. The default
-                  format is 'file,kw,text' which in your file would look like:
-                  'CUNY001,4,They LOOKED UP at the BLUE SKY.' where CUNY001 is
-                  the filename [no extension], 4 is the number of keywords, and
-                  the rest of the line is the text. The text should always be
-                  last on the line, and the delimiter can be a comma or a space.
-
-        'mask' is a list of filemasks (e.g., '*.wav; *.WAV'). default = '*.*'
-
-        'load' is 'manual' to simply keep track of filenames, or 'auto' to load
-                stimuli automatically as well. default is 'auto'
-
-        'order' is the presentation order: 'random', 'natural', or a print
-                range style string, which should be a comma-separated list of
-                values, which can be either a single number, or a colon-delimited
-                range. Make the first item in the list the string 'random' to
-                randomize the list. default is 'natural'
-
-        'repeat' is whether to run through the list again if we run out. If this
-                is True and 'order' is random, a new random order will be
-                generated each time. If this is false, you must ensure that there
-                are enough stimulus files available. default is False
-    """
-
-#    stim.sets['CNC'] = {
-#                              'type':   'files',
-#                              'path':   os.path.join(stimdir,'CNC'),
-#                              'text':   '', #os.path.join(basedir,'stim','CUNYf','CUNY.txt'),
-#                              'txtfmt': 'file kw text',
-#                              'mask':   '*.wav; *.WAV',
-#                              'process':   'auto',  # 'auto' = Load stimuli automatically (default)
-#                              'order':  'r,1:500', #
-#                              'repeat': True,   # If we run out of files, should we start over?
-#                              'equate': 3,  # A custom value
-#                              'gammatone_folder' : os.path.join(stimdir,'gammatone_32','CNC'),
-#                            };
-
-#    stim.sets['Noise'] = {
-#                              'type':   'soundfiles',
-#                              'path':   os.path.join(basedir,'stim','noise','gammatone_32'),
-#                              'fs'  :   44100,
-#                              'text':   '', #os.path.join(basedir,'stim','CUNYf','CUNY.txt'),
-#                              'txtfmt': 'file kw text',
-#                              'mask':   '*.wav; *.WAV',
-#                              'load':   'manual',  # 'auto' = Load stimuli automatically (default)
-#                              'order':  'r,1:50', #
-#                              'repeat': True,    # If we run out of files, should we start over?
-#                              'equate': 3,  # A custom value
-#                            };
-
-    exp.stim.cal = {'250': 112,
-                    '500': 112,
-                    '1000': 112,
-                    '4000': 112}
+    if not exp.subjID:
+        ret = input("Enter Subject ID (Or `\` to quit): ")
+        if ret == '\\':
+            exp.run.gustav_is_go = False
+        else:
+            exp.subjID = ret
 
     """EXPERIMENT VARIABLES
         There are 2 kinds of variables: factorial and ordered
 
         Levels added as 'factvars' variables will be factorialized with each
         other. So, if you have 2 fact variables A & B, each with 3 levels, you
         will end up with 9 conditions: A1B1, A1B2, A1B3, A2B1 etc..
@@ -153,69 +76,58 @@
         'levels' should be a list of strings that identify each level of interest
 
         for file in stim['masker_files']:
             masker,fs,enc = utils.wavread(file)
             stim['masker'] += masker
         stim['masker'] = stim['masker'][0:stim['masker_samples_needed']]
     """
+    # TODO: for python 2.7, change these to ordered dicts, where name is the key
+    # and the dict {type, levels} is the val
 
-    exp.var.factorial['frequency'] = [
-                                        '500',
-                                        '4000',
-                                      ]
-
-#    var.factorial.append( {  'name' : 'target',
-#                            'type' : 'stim',    # This variable will be drawn from stim. 'levels' must be stim set names
-#                          'levels' : [
-#                                        'CNC',
-#                                        #'Noise',
-#                                      ]
-#                        });
-
+    exp.var.factorial['frequency']= [
+                                    '250',
+                                    '1000',
+                                    '4000',
+                                  ]
     def step(exp):
-    	cur_step = exp.var.dynamic['cur_step']
-    	n_reversals = exp.var.dynamic['n_reversals']
-    	print(n_reversals)
-    	print(exp.var.dynamic['steps'])
-    	step = exp.var.dynamic['steps'][n_reversals]
-    	exp.var.dynamic['value'] += cur_step * step
-#        exp.var.dynamic['value'] += exp.var.dynamic['cur_step'] * exp.var.dynamic['steps'][exp.var.dynamic['n_reversals']]
+        # A custom step function for adaptive tracking. This is actually the same as the default one, here for demo purposes
+        exp.var.dynamic['value'] += exp.var.dynamic['cur_step'] * exp.var.dynamic['steps'][exp.var.dynamic['n_reversals']]
         exp.var.dynamic['value'] = max(exp.var.dynamic['value'], exp.var.dynamic['val_floor'])
         exp.var.dynamic['value'] = min(exp.var.dynamic['value'], exp.var.dynamic['val_ceil'])
 
 
-    exp.var.dynamic = { 'name': 'Level',     # Name of the dynamic variable
-                    'units': 'dBSPL',    # Units of the dynamic variable
+    exp.var.dynamic = { 'name': 'fdiff',     # Name of the dynamic variable
+                    'units': 'Hz',       # Units of the dynamic variable
                     'alternatives': 2,   # Number of alternatives
                     'steps': [5, 5, 2, 2, 2, 2, 2, 2], # Stepsizes to use at each reversal (#revs = len)
                     #'steps': [2, 2],    # Stepsizes to use at each reversal (#revs = len)
-                    'downs': 1,          # Number of 'downs'
+                    'downs': 2,          # Number of 'downs'
                     'ups': 1,            # Number of 'ups'
                     'val_start': 50,     # Starting value
                     #'val_start': 0,     # Starting value
                     'val_floor': 0,      # Floor
                     'val_ceil': 70,      # Ceiling
                     'val_floor_n': 3,    # Number of consecutive floor values to quit at
                     'val_ceil_n': 3,     # Number of consecutive ceiling values to quit at
                     'run_n_trials': 0,   # Set to non-zero to run exactly that number of trials
                     'max_trials': 60,    # Maximum number of trials to run
                     'vals_to_avg': 6,    # The number of values to average
-                    'step': step,        # A custom step function. Signature: def step(exp)
+                    'step': step,        # optional. A custom step function. Signature: def step(exp)
                     'max_level': 80,
                    }
 
     """CONDITION PRESENTATION ORDER
         Use 'prompt' to prompt for condition on each block, 'random' to randomize
         condition order, 'menu' to be able to choose from a list of conditions at
         the start of a run, 'natural' to use natural order (1:end), or a
         print-range style string to specify the order ('1-10, 12, 15'). You can
         make the first item in the print range 'random' to randomize the specified
         range.
     """
-    exp.var.order = 'menu'
+    exp.var.order = 'random'
 
     """IGNORE CONDITIONS
         A list of condition numbers to ignore. These conditions will not be
         reflected in the total number of conditions to be run, etc. They will
         simply be skipped as they are encountered during a session.
     """
     exp.var.ignore = []
@@ -231,87 +143,93 @@
     If you want a custom response prompt, define a function for it
     here. run.response should receive the response as a string, and
     if you want to cancel the experiment, set both run.block_on and
     run.pylab_is_go to False
 """
 def prompt_response(exp):
     while True:
-        #ret = exp.utils.getchar()
-        exp.interface.app.processEvents()
         ret = exp.interface.get_resp()
-        if str(ret) in exp.validKeys:
+        if ret in exp.validKeys:
             exp.run.response = ret
             break
-        elif str(ret) in exp.quitKeys:
-            exp.run.block_on = False
+        elif ret in exp.quitKeys:
             exp.run.gustav_is_go = False
             exp.var.dynamic['msg'] = "Cancelled by user"
-            break;
+            break
 
-"""PRE_TRIAL
-    This function gets called on every trial to generate the stimulus, and
-    do any other processing you need. All settings and variables are
-    available. For the current level of a variable, use
-    var.current['varname'].
-"""
 def pre_trial(exp):
-    isi = np.zeros(psylab.signal.ms2samp(exp.user.isi,exp.user.fs))
-    interval_noi = np.zeros(exp.user.interval/1000.*exp.user.fs)
+    """PRE_TRIAL
+        This function gets called on every trial to generate the stimulus, and
+        do any other processing you need. All settings and variables are
+        available. For the current level of a variable, use
+        var.current['varname'].
+    """
+    exp.interface.update_Status_Right("Trial {:}".format(exp.run.trials_block), redraw=True)
+    isi = np.zeros(int(psylab.signal.ms2samp(int(exp.user.isi),int(exp.user.fs))))
+    interval_noi = np.zeros(int(exp.user.interval/1000.*exp.user.fs))
     interval_sig = psylab.signal.tone(float(exp.var.current['frequency']),exp.user.fs,exp.user.interval)
     interval_sig = psylab.signal.ramps(interval_sig,exp.user.fs)
-    #print ("Cal: {}".format(exp.stim.cal[exp.var.current['frequency']]))
-    #print ("Val: {}; Atten: {}".format(exp.var.dynamic['value'], exp.stim.cal[exp.var.current['frequency']]-exp.var.dynamic['value']))
-    interval_sig = psylab.signal.atten(interval_sig,exp.stim.cal[exp.var.current['frequency']]-exp.var.dynamic['value'])
+    interval_sig = psylab.signal.atten(interval_sig,exp.var.dynamic['max_level']-exp.var.dynamic['value'])
 
     exp.var.dynamic['correct'] = np.random.randint(1, exp.var.dynamic['alternatives']+1)
     if exp.var.dynamic['correct'] == 1:
         exp.stim.out = np.hstack((interval_sig, isi, interval_noi))
     else:
         exp.stim.out = np.hstack((interval_noi, isi, interval_sig))
 
 
 def present_trial(exp):
     #pass
     #m.play_array(stim.out,user.fs)
-    exp.interface.button_light([1,2], None)
     time.sleep(.1)
+    exp.interface.show_Notify_Left(False)    # Hide the 'press space' text since they just pressed it
+    exp.interface.show_Notify_Right(True)    # Show the listen text
+    exp.interface.show_Prompt(False)         # Don't show prompt during presentation b/c we don't want a response
+    exp.interface.show_Buttons(True, redraw=True) # Show buttons so user gets visual feedback on interfal playback
     s = exp.audiodev.open_array(exp.stim.out,exp.user.fs)
     s.play()
-    exp.interface.button_light([1], 'yellow')
-    time.sleep(exp.user.interval/1000.)
-    exp.interface.button_light([1], None)
-    time.sleep(exp.user.isi/1000.)
-    exp.interface.button_light([2], 'yellow')
-    time.sleep(exp.user.interval/1000.)
-    exp.interface.button_light([2], None)
-    time.sleep(.1)
+    for i in range(len(exp.interface.alternatives)):
+        exp.interface.set_border(i, 'Heavy', redraw=True)
+        time.sleep(exp.user.interval/1000.)
+        exp.interface.set_border(i, 'Light', redraw=True)
+        time.sleep(exp.user.isi/1000.)
+    exp.interface.show_Notify_Right(False)
+    exp.interface.show_Prompt(True, redraw=True)
+
 
 def post_trial(exp):
-    exp.interface.button_light([1,2], None)
+#    exp.interface.button_light([1,2], None)
     if exp.run.gustav_is_go:
         if str(exp.var.dynamic['correct']).lower() == exp.run.response.lower():
-            color = 'green'
+            color = 'Green'
         else:
-            color = 'red'
+            color = 'Red'
         for i in range(3):
-            exp.interface.button_light([exp.var.dynamic['correct']], color)
+            exp.interface.set_color(exp.var.dynamic['correct']-1, color, redraw=True)
             time.sleep(.1)
-            exp.interface.button_light([exp.var.dynamic['correct']], None)
+            exp.interface.set_color(exp.var.dynamic['correct']-1, 'None', redraw=True)
             time.sleep(.05)
 
 def pre_exp(exp):
-    exp.interface = theForm.Interface(exp.validKeys.split(","))
     exp.audiodev = m.open_device()
+    exp.interface = theForm.Interface(alternatives = exp.validKeys.split(","))
+    exp.interface.update_Title_Center(exp.note)
+    exp.interface.update_Title_Right("Subject {:}".format(exp.subjID) )
+    exp.interface.show_Buttons(False)
+    exp.interface.show_Notify_Left(False)
+    exp.interface.update_Notify_Right("Listen", show=False)
+    exp.interface.update_Prompt("Press any key to begin", show=True, redraw=True)
+    # Wait for a keypress
+    ret = exp.interface.get_resp()
+    exp.interface.update_Prompt("Which Interval?", show=False, redraw=True)
+
 
 def post_exp(exp):
-    exp.interface.dialog.close()
+    exp.interface.destroy()
 
 def pre_block(exp):
-    exp.interface.dialog.blocks.setText("Block %g of %g" % (exp.run.block+1, exp.var.nblocks+1))
+    exp.interface.update_Status_Center("Block {:} of {:}".format(exp.run.block+1, exp.var.nblocks+1))
 
 if __name__ == '__main__':
     argv = sys.argv[1:]
-    argv.append("--experimentFile=%s" % os.path.realpath(__file__))
-    psylab.gustav.main(argv)
-#    import inspect
-#    fname = inspect.getfile( inspect.currentframe() )
-#    psylab.gustav.run(settingsFile=fname)
+    argv.append("--experimentFile={}".format(os.path.realpath(__file__)))
+    gustav.main(argv)
```

## Comparing `gustav-0.4.7.13.dist-info/RECORD` & `gustav-0.8.1.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,31 +1,25 @@
-gustav/__init__.py,sha256=h0PDUhcllaqP-mSYBgQvJ8nA-Kd1pL5PlZU8SXmPFKM,2035
-gustav/dataTemplate_adaptive.py,sha256=AhvsXWKrPc7TxwMpjYtcjUEWZrO5AND49F8N6Ph63yA,1068
-gustav/gustav.py,sha256=ENtBGsH1DOyyXhFQktVSj9teKNkwSQYBY5IsDBwSSOo,8160
-gustav/settings_constant_nogui.py,sha256=acbflrW8Yr2Plie2Fp3o4BsZUwcXh2MtgeKTBjvuBGM,14372
-gustav/utils.py,sha256=qWp4Ml2rHB-D7reTtA03FPydUOUnsENV93_BbgAWOKM,29385
-gustav/frontends/__init__.py,sha256=e4eGXtgxqYwxTjjD6UzMQTOVDrIXyeXilzgJy1J6nH4,828
-gustav/frontends/pylabconfig.py,sha256=WzPQp7WDLV-EPEbS_NoB26qnTbZiYYNo59t41h7i2mU,22086
-gustav/frontends/qt.py,sha256=RXK87XGzhm97uBM20oBkFvZAo9qZ9MfwLJGK6Utq_S4,12334
-gustav/frontends/term.py,sha256=nFSONM9KcZbxbPbuT3fr7anAVTVp-pzwqfVTXNdRftA,5114
-gustav/frontends/tk.py,sha256=XiZS-zaddi8U_jZanzBjU_eK1XfsqouTSI64Bmb-J9w,4865
-gustav/methods/__init__.py,sha256=o_dj7-G_3W3DIjGazto4j-Ya2ENmQ0IX8MFc-Wn73lc,833
-gustav/methods/adaptive.py,sha256=N5ZBFUP-GF33gReQxlI8xvNHlAVwhXfNrWCMeHePJCU,16115
-gustav/methods/constant.py,sha256=RymaAmtf-Z07ZgtxxxybIiI999BcqkR7YgCJlH7n7L4,3183
-gustav/user_scripts/gustav__puretone_quietthresholds.py,sha256=unx-aIlW9WCoFmpH1jHneF01h5HmzBu4TZs1CsANQUA,14050
-gustav/user_scripts/gustav_exp__ClosedSetSpeech.py,sha256=STPjHX5cwz2IAPN6wTU475LAUHFRvZ-PobFFS3CETDE,17247
-gustav/user_scripts/gustav_exp__adaptive_quietthresholds.py,sha256=STxK3pJXVaL5ga4KX9Hpynv93F_MivnjS_Fbviw_KAs,13848
-gustav/user_scripts/gustav_exp__constantStim_gui.py,sha256=A2SOUVMn_LLi3ecAC2-DIU6B67pFaL59xKjhCmuwhjo,16034
-gustav/user_scripts/gustav_exp__constantStim_nogui.py,sha256=xUtxhqyge0oJRkCxC1yMgvliuCkcHDepjIOQAsv8ELw,16744
-gustav/user_scripts/gustav_exp__ild_sensitivity.py,sha256=julAP1_wwJsYLLAaguE95zRY-hqw4rh0OaExiNlftC4,18608
-gustav/user_scripts/gustav_run.py,sha256=1QgVjUCZxeWzfPzEl4cPRtVo-bU4en-CTB_TrFGVf4Y,377
-gustav/user_scripts/test_gustav_adaptiveForm.py,sha256=p6LAcRCdyBW2Y_dspvKloxnsKetYcrGfRxt0jOIKMuo,680
-gustav/user_scripts/test_gustav_closedSetForm.py,sha256=jK-Nr3hLlh0uE2fQe1NlwWn74u0wSPK-tlarVWuSvf8,663
-gustav/user_scripts/test_gustav_lateralizationForm.py,sha256=sfLHgGo06I-U6z82X0SGslzpnV3sevJ7piQqSBT9XoE,479
-gustav/user_scripts/test_gustav_lateralizationForm_Joystick.py,sha256=92R3QUsz6217U7ppS03m4paF__c--kCl90PavGn1Nfw,989
-gustav/user_scripts/test_gustav_speechForm.py,sha256=9JVfb2o3ibOlPVHD4sz46HVlKtvZL7Sh9Dt588divHY,848
-gustav-0.4.7.13.dist-info/DESCRIPTION.rst,sha256=ENqcIBCTieY9jtqfGZLW28rC0TMhY_G_Hf6_3QjCTpY,1701
-gustav-0.4.7.13.dist-info/METADATA,sha256=VYJhE6ya_U676eW51JOgr6fmQwWiYcgp2ZyQ7q0SCEg,1828
-gustav-0.4.7.13.dist-info/RECORD,,
-gustav-0.4.7.13.dist-info/WHEEL,sha256=bee59qcPjkyXfMaxNWjl2CGotqfumWx9pC1hlVLr2mM,92
-gustav-0.4.7.13.dist-info/metadata.json,sha256=CiItYxqzFQkY4HnFs0lw6D387abbOZoPoNDwKCpcp38,273
-gustav-0.4.7.13.dist-info/top_level.txt,sha256=IbqMtDPz6bMNDbHhyvA8gRfl38qr6j5EBOhQFeCut28,7
+gustav/__init__.py,sha256=r--zWYq-4lqLpQG4QeA36ZAQZUSkJ4CRjOVu1KOzk9E,1898
+gustav/dataTemplate_adaptive.py,sha256=AhvsXWKrPc7TxwMpjYtcjUEWZrO5AND49F8N6Ph63yA,1068
+gustav/gustav.py,sha256=AjLJ9ii_CfhXHUIdmYzjeuoyHPpfS24e3KdCcO0BqPE,8291
+gustav/utils.py,sha256=cWxjMqFw59IlmP8wKRCIYEj0RV8YbYPCiF0UXkDGjio,32439
+gustav/forms/__init__.py,sha256=9G8DAJ-WLjW927pthWOzqZTr1j9HgHN1wFRaAYVW4qo,913
+gustav/forms/lateralization.py,sha256=17bLS4qq3cKSBDhjy_xRmPTsdJR13Zu5ZopTmJ2qdNs,56957
+gustav/forms/localization.py,sha256=V79mSWIVYXifJqjkGm1nJP8N0mo7dtqlOvgpGuZEYiI,60675
+gustav/forms/nafc.py,sha256=o7GbN5nrVudnt_7LlJ-XVI_4QD-R4deRv5BnaPTo4HU,53735
+gustav/forms/rt.py,sha256=asf6aKYUFZG_7iaN_YfGP7aawZ2INmQALaHZrH54EJc,46112
+gustav/forms/speech.py,sha256=wy86RfDVR9vumbHq0k570_i3kPiEVKhUtQlV3pGQYco,40942
+gustav/frontends/__init__.py,sha256=n87qZaIBmhHzLol7xPUC6AK13RXhtWLrl4t14MGwBLM,1208
+gustav/frontends/term.py,sha256=Rwz5ZNoLlTB04oc4q1cMVpY2dg4mh4DNMGVhAK2g9ng,4802
+gustav/frontends/tk.py,sha256=nmOfeG-ATCyrB1SOL1OuVSnpZPSi6LnMctzK3j9gWXo,4742
+gustav/methods/__init__.py,sha256=QdKlutb8aquhbSqNmgdf-IyEM4Eux5IvxFZfJsfhwA0,833
+gustav/methods/adaptive.py,sha256=ni3IlcnnzSmW4iQDfkdmQk3-1WDbHsCbHUIpo18glbA,16104
+gustav/methods/constant.py,sha256=JLJz2u5ce2H323HwKPjEh0a1UnZuF7JFoC1j_-E3RlU,3322
+gustav/methods/pest.py,sha256=DwqeYMafGwUf3CtymePBp79mIvugsmsaK1j1q32MK2M,16146
+gustav/user_scripts/gustav_exp__adaptive__frequency_discrim.py,sha256=3qveAMPTuleVn_Ew0-wScBog94aNH0M6QWVmaZM9Lxo,10923
+gustav/user_scripts/gustav_exp__adaptive_quietthresholds.py,sha256=rflaf9lAdp6un_AssuWqCcCIotH5dA9DX6yTo2NMows,10965
+gustav/user_scripts/gustav_exp__lateralization.py,sha256=YxTvgU_WTeD8PU1hbgcwd6TZSYNERAnl7dIgFmJ739c,9890
+gustav-0.8.1.dist-info/LICENSE.md,sha256=Z83GNTJq8cbx2oZmTTr6KH2yyUuaD292vabRCQ070yY,32423
+gustav-0.8.1.dist-info/METADATA,sha256=9lzgt8WudTl4oX3EuWU_8x5LnqY51hNQzml6Smt5-jQ,1085
+gustav-0.8.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+gustav-0.8.1.dist-info/top_level.txt,sha256=IbqMtDPz6bMNDbHhyvA8gRfl38qr6j5EBOhQFeCut28,7
+gustav-0.8.1.dist-info/RECORD,,
```

