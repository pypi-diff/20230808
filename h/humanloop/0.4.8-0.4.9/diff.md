# Comparing `tmp/humanloop-0.4.8.tar.gz` & `tmp/humanloop-0.4.9.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "humanloop-0.4.8.tar", max compression
+gzip compressed data, was "humanloop-0.4.9.tar", max compression
```

## Comparing `humanloop-0.4.8.tar` & `humanloop-0.4.9.tar`

### file list

```diff
@@ -1,410 +1,404 @@
--rw-r--r--   0        0        0     1081 2023-06-12 17:10:44.728904 humanloop-0.4.8/LICENSE
--rw-r--r--   0        0        0     8475 2023-06-12 17:10:44.777657 humanloop-0.4.8/README.md
--rw-r--r--   0        0        0     1235 2023-06-12 17:10:44.645471 humanloop-0.4.8/humanloop/__init__.py
--rw-r--r--   0        0        0    72575 2023-06-12 17:10:44.645777 humanloop-0.4.8/humanloop/api_client.py
--rw-r--r--   0        0        0      663 2023-06-12 17:10:44.645969 humanloop-0.4.8/humanloop/api_response.py
--rw-r--r--   0        0        0      214 2023-06-12 17:10:44.646129 humanloop-0.4.8/humanloop/apis/__init__.py
--rw-r--r--   0        0        0     4698 2023-06-12 17:10:44.646274 humanloop-0.4.8/humanloop/apis/path_to_api.py
--rw-r--r--   0        0        0      236 2023-06-12 17:10:44.646439 humanloop-0.4.8/humanloop/apis/paths/__init__.py
--rw-r--r--   0        0        0       91 2023-06-12 17:10:44.646587 humanloop-0.4.8/humanloop/apis/paths/chat.py
--rw-r--r--   0        0        0      108 2023-06-12 17:10:44.646730 humanloop-0.4.8/humanloop/apis/paths/chat_deployed.py
--rw-r--r--   0        0        0      112 2023-06-12 17:10:44.646883 humanloop-0.4.8/humanloop/apis/paths/chat_experiment.py
--rw-r--r--   0        0        0      115 2023-06-12 17:10:44.647024 humanloop-0.4.8/humanloop/apis/paths/chat_model_config.py
--rw-r--r--   0        0        0      103 2023-06-12 17:10:44.647176 humanloop-0.4.8/humanloop/apis/paths/completion.py
--rw-r--r--   0        0        0      120 2023-06-12 17:10:44.647290 humanloop-0.4.8/humanloop/apis/paths/completion_deployed.py
--rw-r--r--   0        0        0      124 2023-06-12 17:10:44.647431 humanloop-0.4.8/humanloop/apis/paths/completion_experiment.py
--rw-r--r--   0        0        0      127 2023-06-12 17:10:44.647566 humanloop-0.4.8/humanloop/apis/paths/completion_model_config.py
--rw-r--r--   0        0        0      226 2023-06-12 17:10:44.647701 humanloop-0.4.8/humanloop/apis/paths/experiments_experiment_id.py
--rw-r--r--   0        0        0      152 2023-06-12 17:10:44.647852 humanloop-0.4.8/humanloop/apis/paths/experiments_experiment_id_model_config.py
--rw-r--r--   0        0        0       99 2023-06-12 17:10:44.648003 humanloop-0.4.8/humanloop/apis/paths/feedback.py
--rw-r--r--   0        0        0      159 2023-06-12 17:10:44.648143 humanloop-0.4.8/humanloop/apis/paths/logs.py
--rw-r--r--   0        0        0       99 2023-06-12 17:10:44.648286 humanloop-0.4.8/humanloop/apis/paths/logs_id.py
--rw-r--r--   0        0        0      108 2023-06-12 17:10:44.648424 humanloop-0.4.8/humanloop/apis/paths/model_configs.py
--rw-r--r--   0        0        0      110 2023-06-12 17:10:44.648562 humanloop-0.4.8/humanloop/apis/paths/model_configs_id.py
--rw-r--r--   0        0        0      165 2023-06-12 17:10:44.648677 humanloop-0.4.8/humanloop/apis/paths/projects.py
--rw-r--r--   0        0        0      176 2023-06-12 17:10:44.648759 humanloop-0.4.8/humanloop/apis/paths/projects_id.py
--rw-r--r--   0        0        0      219 2023-06-12 17:10:44.648856 humanloop-0.4.8/humanloop/apis/paths/projects_id_active_config.py
--rw-r--r--   0        0        0      144 2023-06-12 17:10:44.648972 humanloop-0.4.8/humanloop/apis/paths/projects_id_active_experiment.py
--rw-r--r--   0        0        0      116 2023-06-12 17:10:44.649122 humanloop-0.4.8/humanloop/apis/paths/projects_id_configs.py
--rw-r--r--   0        0        0      117 2023-06-12 17:10:44.649251 humanloop-0.4.8/humanloop/apis/paths/projects_id_export.py
--rw-r--r--   0        0        0      135 2023-06-12 17:10:44.649356 humanloop-0.4.8/humanloop/apis/paths/projects_id_feedback_types.py
--rw-r--r--   0        0        0      231 2023-06-12 17:10:44.649518 humanloop-0.4.8/humanloop/apis/paths/projects_project_id_experiments.py
--rw-r--r--   0        0        0      165 2023-06-12 17:10:44.649657 humanloop-0.4.8/humanloop/apis/paths/sessions.py
--rw-r--r--   0        0        0      101 2023-06-12 17:10:44.649802 humanloop-0.4.8/humanloop/apis/paths/sessions_id.py
--rw-r--r--   0        0        0       95 2023-06-12 17:10:44.649932 humanloop-0.4.8/humanloop/apis/paths/traces.py
--rw-r--r--   0        0        0     1654 2023-06-12 17:10:44.650067 humanloop-0.4.8/humanloop/apis/tag_to_api.py
--rw-r--r--   0        0        0      572 2023-06-12 17:10:44.650215 humanloop-0.4.8/humanloop/apis/tags/__init__.py
--rw-r--r--   0        0        0     1182 2023-06-12 17:10:44.650401 humanloop-0.4.8/humanloop/apis/tags/chats_api.py
--rw-r--r--   0        0        0     1196 2023-06-12 17:10:44.650627 humanloop-0.4.8/humanloop/apis/tags/completions_api.py
--rw-r--r--   0        0        0     1267 2023-06-12 17:10:44.650762 humanloop-0.4.8/humanloop/apis/tags/experiments_api.py
--rw-r--r--   0        0        0      897 2023-06-12 17:10:44.650934 humanloop-0.4.8/humanloop/apis/tags/feedback_api.py
--rw-r--r--   0        0        0     1028 2023-06-12 17:10:44.651085 humanloop-0.4.8/humanloop/apis/tags/logs_api.py
--rw-r--r--   0        0        0      979 2023-06-12 17:10:44.651245 humanloop-0.4.8/humanloop/apis/tags/model_configurations_api.py
--rw-r--r--   0        0        0     1662 2023-06-12 17:10:44.651385 humanloop-0.4.8/humanloop/apis/tags/projects_api.py
--rw-r--r--   0        0        0     1010 2023-06-12 17:10:44.651520 humanloop-0.4.8/humanloop/apis/tags/sessions_api.py
--rw-r--r--   0        0        0      893 2023-06-12 17:10:44.651660 humanloop-0.4.8/humanloop/apis/tags/traces_api.py
--rw-r--r--   0        0        0    28838 2023-06-12 17:10:44.651884 humanloop-0.4.8/humanloop/client.py
--rw-r--r--   0        0        0    28838 2023-06-12 17:10:44.652148 humanloop-0.4.8/humanloop/client.pyi
--rw-r--r--   0        0        0     6780 2023-06-12 17:10:44.728227 humanloop-0.4.8/humanloop/client_custom.py
--rw-r--r--   0        0        0    19154 2023-06-12 17:10:44.652597 humanloop-0.4.8/humanloop/configuration.py
--rw-r--r--   0        0        0     8215 2023-06-12 17:10:44.652820 humanloop-0.4.8/humanloop/exceptions.py
--rw-r--r--   0        0        0     2274 2023-06-12 17:10:44.653051 humanloop-0.4.8/humanloop/exceptions_base.py
--rw-r--r--   0        0        0      343 2023-06-12 17:10:44.653305 humanloop-0.4.8/humanloop/model/__init__.py
--rw-r--r--   0        0        0     9316 2023-06-12 17:10:44.653520 humanloop-0.4.8/humanloop/model/agent_config_request.py
--rw-r--r--   0        0        0     9151 2023-06-12 17:10:44.653758 humanloop-0.4.8/humanloop/model/agent_config_request.pyi
--rw-r--r--   0        0        0     9818 2023-06-12 17:10:44.653935 humanloop-0.4.8/humanloop/model/agent_config_response.py
--rw-r--r--   0        0        0     9653 2023-06-12 17:10:44.654070 humanloop-0.4.8/humanloop/model/agent_config_response.pyi
--rw-r--r--   0        0        0     6555 2023-06-12 17:10:44.654190 humanloop-0.4.8/humanloop/model/base_metric_response.py
--rw-r--r--   0        0        0     6555 2023-06-12 17:10:44.654274 humanloop-0.4.8/humanloop/model/base_metric_response.pyi
--rw-r--r--   0        0        0     5326 2023-06-12 17:10:44.654392 humanloop-0.4.8/humanloop/model/categorical_feedback_label.py
--rw-r--r--   0        0        0     5326 2023-06-12 17:10:44.654506 humanloop-0.4.8/humanloop/model/categorical_feedback_label.pyi
--rw-r--r--   0        0        0     9133 2023-06-12 17:10:44.654620 humanloop-0.4.8/humanloop/model/chat_data_response.py
--rw-r--r--   0        0        0     9133 2023-06-12 17:10:44.654745 humanloop-0.4.8/humanloop/model/chat_data_response.pyi
--rw-r--r--   0        0        0    10174 2023-06-12 17:10:44.654865 humanloop-0.4.8/humanloop/model/chat_deployed_request.py
--rw-r--r--   0        0        0    10174 2023-06-12 17:10:44.654984 humanloop-0.4.8/humanloop/model/chat_deployed_request.pyi
--rw-r--r--   0        0        0    10835 2023-06-12 17:10:44.655090 humanloop-0.4.8/humanloop/model/chat_experiment_request.py
--rw-r--r--   0        0        0    10835 2023-06-12 17:10:44.655198 humanloop-0.4.8/humanloop/model/chat_experiment_request.pyi
--rw-r--r--   0        0        0     3878 2023-06-12 17:10:44.655299 humanloop-0.4.8/humanloop/model/chat_message.py
--rw-r--r--   0        0        0     3878 2023-06-12 17:10:44.655388 humanloop-0.4.8/humanloop/model/chat_message.pyi
--rw-r--r--   0        0        0    10869 2023-06-12 17:10:44.655535 humanloop-0.4.8/humanloop/model/chat_model_config_request.py
--rw-r--r--   0        0        0    10869 2023-06-12 17:10:44.655735 humanloop-0.4.8/humanloop/model/chat_model_config_request.pyi
--rw-r--r--   0        0        0    12732 2023-06-12 17:10:44.655965 humanloop-0.4.8/humanloop/model/chat_request.py
--rw-r--r--   0        0        0    12732 2023-06-12 17:10:44.656521 humanloop-0.4.8/humanloop/model/chat_request.pyi
--rw-r--r--   0        0        0    11252 2023-06-12 17:10:44.656735 humanloop-0.4.8/humanloop/model/chat_response.py
--rw-r--r--   0        0        0    11252 2023-06-12 17:10:44.656950 humanloop-0.4.8/humanloop/model/chat_response.pyi
--rw-r--r--   0        0        0     1622 2023-06-12 17:10:44.657123 humanloop-0.4.8/humanloop/model/chat_role.py
--rw-r--r--   0        0        0     1461 2023-06-12 17:10:44.657255 humanloop-0.4.8/humanloop/model/chat_role.pyi
--rw-r--r--   0        0        0     9850 2023-06-12 17:10:44.657402 humanloop-0.4.8/humanloop/model/completion_deployed_request.py
--rw-r--r--   0        0        0     9850 2023-06-12 17:10:44.657613 humanloop-0.4.8/humanloop/model/completion_deployed_request.pyi
--rw-r--r--   0        0        0    10516 2023-06-12 17:10:44.657816 humanloop-0.4.8/humanloop/model/completion_experiment_request.py
--rw-r--r--   0        0        0    10516 2023-06-12 17:10:44.658043 humanloop-0.4.8/humanloop/model/completion_experiment_request.pyi
--rw-r--r--   0        0        0    10552 2023-06-12 17:10:44.658251 humanloop-0.4.8/humanloop/model/completion_model_config_request.py
--rw-r--r--   0        0        0    10552 2023-06-12 17:10:44.658469 humanloop-0.4.8/humanloop/model/completion_model_config_request.pyi
--rw-r--r--   0        0        0    12434 2023-06-12 17:10:44.658714 humanloop-0.4.8/humanloop/model/completion_request.py
--rw-r--r--   0        0        0    12434 2023-06-12 17:10:44.658947 humanloop-0.4.8/humanloop/model/completion_request.pyi
--rw-r--r--   0        0        0    11193 2023-06-12 17:10:44.659152 humanloop-0.4.8/humanloop/model/completion_response.py
--rw-r--r--   0        0        0    11193 2023-06-12 17:10:44.659376 humanloop-0.4.8/humanloop/model/completion_response.pyi
--rw-r--r--   0        0        0     3636 2023-06-12 17:10:44.659574 humanloop-0.4.8/humanloop/model/config_response.py
--rw-r--r--   0        0        0     3636 2023-06-12 17:10:44.659722 humanloop-0.4.8/humanloop/model/config_response.pyi
--rw-r--r--   0        0        0     1722 2023-06-12 17:10:44.659872 humanloop-0.4.8/humanloop/model/config_type.py
--rw-r--r--   0        0        0     1537 2023-06-12 17:10:44.660014 humanloop-0.4.8/humanloop/model/config_type.pyi
--rw-r--r--   0        0        0     6372 2023-06-12 17:10:44.660188 humanloop-0.4.8/humanloop/model/create_experiment_request.py
--rw-r--r--   0        0        0     6372 2023-06-12 17:10:44.660375 humanloop-0.4.8/humanloop/model/create_experiment_request.pyi
--rw-r--r--   0        0        0     3375 2023-06-12 17:10:44.660521 humanloop-0.4.8/humanloop/model/create_log_response.py
--rw-r--r--   0        0        0     3375 2023-06-12 17:10:44.660659 humanloop-0.4.8/humanloop/model/create_log_response.pyi
--rw-r--r--   0        0        0     4442 2023-06-12 17:10:44.660796 humanloop-0.4.8/humanloop/model/create_project_request.py
--rw-r--r--   0        0        0     4442 2023-06-12 17:10:44.660953 humanloop-0.4.8/humanloop/model/create_project_request.pyi
--rw-r--r--   0        0        0     2811 2023-06-12 17:10:44.661093 humanloop-0.4.8/humanloop/model/create_session_response.py
--rw-r--r--   0        0        0     2811 2023-06-12 17:10:44.661234 humanloop-0.4.8/humanloop/model/create_session_response.pyi
--rw-r--r--   0        0        0     3408 2023-06-12 17:10:44.661369 humanloop-0.4.8/humanloop/model/create_trace_request.py
--rw-r--r--   0        0        0     3408 2023-06-12 17:10:44.661507 humanloop-0.4.8/humanloop/model/create_trace_request.pyi
--rw-r--r--   0        0        0     3505 2023-06-12 17:10:44.661630 humanloop-0.4.8/humanloop/model/create_trace_response.py
--rw-r--r--   0        0        0     3505 2023-06-12 17:10:44.661761 humanloop-0.4.8/humanloop/model/create_trace_response.pyi
--rw-r--r--   0        0        0     7631 2023-06-12 17:10:44.661898 humanloop-0.4.8/humanloop/model/data_response.py
--rw-r--r--   0        0        0     7631 2023-06-12 17:10:44.662054 humanloop-0.4.8/humanloop/model/data_response.pyi
--rw-r--r--   0        0        0     9174 2023-06-12 17:10:44.662240 humanloop-0.4.8/humanloop/model/experiment_config_response.py
--rw-r--r--   0        0        0     9174 2023-06-12 17:10:44.662469 humanloop-0.4.8/humanloop/model/experiment_config_response.pyi
--rw-r--r--   0        0        0    13003 2023-06-12 17:10:44.662725 humanloop-0.4.8/humanloop/model/experiment_response.py
--rw-r--r--   0        0        0    13003 2023-06-12 17:10:44.662990 humanloop-0.4.8/humanloop/model/experiment_response.pyi
--rw-r--r--   0        0        0     1552 2023-06-12 17:10:44.663244 humanloop-0.4.8/humanloop/model/experiment_status.py
--rw-r--r--   0        0        0     1405 2023-06-12 17:10:44.663401 humanloop-0.4.8/humanloop/model/experiment_status.pyi
--rw-r--r--   0        0        0     1861 2023-06-12 17:10:44.663572 humanloop-0.4.8/humanloop/model/experiments_list_response.py
--rw-r--r--   0        0        0     1861 2023-06-12 17:10:44.663756 humanloop-0.4.8/humanloop/model/experiments_list_response.pyi
--rw-r--r--   0        0        0     6857 2023-06-12 17:10:44.663953 humanloop-0.4.8/humanloop/model/feedback.py
--rw-r--r--   0        0        0     6857 2023-06-12 17:10:44.664086 humanloop-0.4.8/humanloop/model/feedback.pyi
--rw-r--r--   0        0        0     1639 2023-06-12 17:10:44.664211 humanloop-0.4.8/humanloop/model/feedback_class.py
--rw-r--r--   0        0        0     1472 2023-06-12 17:10:44.664367 humanloop-0.4.8/humanloop/model/feedback_class.pyi
--rw-r--r--   0        0        0     3510 2023-06-12 17:10:44.664500 humanloop-0.4.8/humanloop/model/feedback_label_request.py
--rw-r--r--   0        0        0     3510 2023-06-12 17:10:44.664627 humanloop-0.4.8/humanloop/model/feedback_label_request.pyi
--rw-r--r--   0        0        0     7365 2023-06-12 17:10:44.664865 humanloop-0.4.8/humanloop/model/feedback_request.py
--rw-r--r--   0        0        0     7365 2023-06-12 17:10:44.665082 humanloop-0.4.8/humanloop/model/feedback_request.pyi
--rw-r--r--   0        0        0     7317 2023-06-12 17:10:44.665206 humanloop-0.4.8/humanloop/model/feedback_response.py
--rw-r--r--   0        0        0     7317 2023-06-12 17:10:44.665341 humanloop-0.4.8/humanloop/model/feedback_response.pyi
--rw-r--r--   0        0        0     3376 2023-06-12 17:10:44.665478 humanloop-0.4.8/humanloop/model/feedback_submit_request.py
--rw-r--r--   0        0        0     3376 2023-06-12 17:10:44.665593 humanloop-0.4.8/humanloop/model/feedback_submit_request.pyi
--rw-r--r--   0        0        0     3386 2023-06-12 17:10:44.665693 humanloop-0.4.8/humanloop/model/feedback_submit_response.py
--rw-r--r--   0        0        0     3386 2023-06-12 17:10:44.665838 humanloop-0.4.8/humanloop/model/feedback_submit_response.pyi
--rw-r--r--   0        0        0     1866 2023-06-12 17:10:44.665986 humanloop-0.4.8/humanloop/model/feedback_type.py
--rw-r--r--   0        0        0     1635 2023-06-12 17:10:44.666128 humanloop-0.4.8/humanloop/model/feedback_type.pyi
--rw-r--r--   0        0        0     6337 2023-06-12 17:10:44.666272 humanloop-0.4.8/humanloop/model/feedback_type_model.py
--rw-r--r--   0        0        0     6337 2023-06-12 17:10:44.666422 humanloop-0.4.8/humanloop/model/feedback_type_model.pyi
--rw-r--r--   0        0        0     6465 2023-06-12 17:10:44.666579 humanloop-0.4.8/humanloop/model/feedback_type_request.py
--rw-r--r--   0        0        0     6465 2023-06-12 17:10:44.666734 humanloop-0.4.8/humanloop/model/feedback_type_request.pyi
--rw-r--r--   0        0        0     1835 2023-06-12 17:10:44.666886 humanloop-0.4.8/humanloop/model/feedback_types.py
--rw-r--r--   0        0        0     1835 2023-06-12 17:10:44.667036 humanloop-0.4.8/humanloop/model/feedback_types.pyi
--rw-r--r--   0        0        0     4583 2023-06-12 17:10:44.667179 humanloop-0.4.8/humanloop/model/generic_config_request.py
--rw-r--r--   0        0        0     4414 2023-06-12 17:10:44.667327 humanloop-0.4.8/humanloop/model/generic_config_request.pyi
--rw-r--r--   0        0        0     5247 2023-06-12 17:10:44.667466 humanloop-0.4.8/humanloop/model/generic_config_response.py
--rw-r--r--   0        0        0     5078 2023-06-12 17:10:44.667640 humanloop-0.4.8/humanloop/model/generic_config_response.pyi
--rw-r--r--   0        0        0     9795 2023-06-12 17:10:44.667818 humanloop-0.4.8/humanloop/model/get_model_config_response.py
--rw-r--r--   0        0        0     9795 2023-06-12 17:10:44.668030 humanloop-0.4.8/humanloop/model/get_model_config_response.pyi
--rw-r--r--   0        0        0     3787 2023-06-12 17:10:44.668228 humanloop-0.4.8/humanloop/model/http_validation_error.py
--rw-r--r--   0        0        0     3787 2023-06-12 17:10:44.668375 humanloop-0.4.8/humanloop/model/http_validation_error.pyi
--rw-r--r--   0        0        0     1843 2023-06-12 17:10:44.668527 humanloop-0.4.8/humanloop/model/label_sentiment.py
--rw-r--r--   0        0        0     1644 2023-06-12 17:10:44.668669 humanloop-0.4.8/humanloop/model/label_sentiment.pyi
--rw-r--r--   0        0        0     3332 2023-06-12 17:10:44.668815 humanloop-0.4.8/humanloop/model/log_datapoint_request.py
--rw-r--r--   0        0        0     3332 2023-06-12 17:10:44.668904 humanloop-0.4.8/humanloop/model/log_datapoint_request.pyi
--rw-r--r--   0        0        0    17395 2023-06-12 17:10:44.669046 humanloop-0.4.8/humanloop/model/log_model_config_request.py
--rw-r--r--   0        0        0    17395 2023-06-12 17:10:44.669276 humanloop-0.4.8/humanloop/model/log_model_config_request.pyi
--rw-r--r--   0        0        0    17925 2023-06-12 17:10:44.669454 humanloop-0.4.8/humanloop/model/log_request.py
--rw-r--r--   0        0        0    17925 2023-06-12 17:10:44.669633 humanloop-0.4.8/humanloop/model/log_request.pyi
--rw-r--r--   0        0        0    22277 2023-06-12 17:10:44.669843 humanloop-0.4.8/humanloop/model/log_response.py
--rw-r--r--   0        0        0    22277 2023-06-12 17:10:44.670056 humanloop-0.4.8/humanloop/model/log_response.pyi
--rw-r--r--   0        0        0     3381 2023-06-12 17:10:44.670230 humanloop-0.4.8/humanloop/model/logs_log_response.py
--rw-r--r--   0        0        0     3381 2023-06-12 17:10:44.670363 humanloop-0.4.8/humanloop/model/logs_log_response.pyi
--rw-r--r--   0        0        0    16422 2023-06-12 17:10:44.670712 humanloop-0.4.8/humanloop/model/model_config_chat_request.py
--rw-r--r--   0        0        0    16422 2023-06-12 17:10:44.670946 humanloop-0.4.8/humanloop/model/model_config_chat_request.pyi
--rw-r--r--   0        0        0    15562 2023-06-12 17:10:44.671077 humanloop-0.4.8/humanloop/model/model_config_completion_request.py
--rw-r--r--   0        0        0    15562 2023-06-12 17:10:44.671218 humanloop-0.4.8/humanloop/model/model_config_completion_request.pyi
--rw-r--r--   0        0        0     1636 2023-06-12 17:10:44.671395 humanloop-0.4.8/humanloop/model/model_endpoints.py
--rw-r--r--   0        0        0     1481 2023-06-12 17:10:44.671510 humanloop-0.4.8/humanloop/model/model_endpoints.pyi
--rw-r--r--   0        0        0     2123 2023-06-12 17:10:44.671625 humanloop-0.4.8/humanloop/model/model_providers.py
--rw-r--r--   0        0        0     1820 2023-06-12 17:10:44.671718 humanloop-0.4.8/humanloop/model/model_providers.pyi
--rw-r--r--   0        0        0     5320 2023-06-12 17:10:44.671812 humanloop-0.4.8/humanloop/model/paginated_data_log_response.py
--rw-r--r--   0        0        0     5320 2023-06-12 17:10:44.671906 humanloop-0.4.8/humanloop/model/paginated_data_log_response.pyi
--rw-r--r--   0        0        0     5356 2023-06-12 17:10:44.672049 humanloop-0.4.8/humanloop/model/paginated_data_project_response.py
--rw-r--r--   0        0        0     5356 2023-06-12 17:10:44.672161 humanloop-0.4.8/humanloop/model/paginated_data_project_response.pyi
--rw-r--r--   0        0        0     5356 2023-06-12 17:10:44.672316 humanloop-0.4.8/humanloop/model/paginated_data_session_response.py
--rw-r--r--   0        0        0     5356 2023-06-12 17:10:44.672429 humanloop-0.4.8/humanloop/model/paginated_data_session_response.pyi
--rw-r--r--   0        0        0     3319 2023-06-12 17:10:44.672572 humanloop-0.4.8/humanloop/model/positive_label.py
--rw-r--r--   0        0        0     3319 2023-06-12 17:10:44.672726 humanloop-0.4.8/humanloop/model/positive_label.pyi
--rw-r--r--   0        0        0     9076 2023-06-12 17:10:44.672899 humanloop-0.4.8/humanloop/model/project_config_response.py
--rw-r--r--   0        0        0     9076 2023-06-12 17:10:44.673141 humanloop-0.4.8/humanloop/model/project_config_response.pyi
--rw-r--r--   0        0        0    18539 2023-06-12 17:10:44.673453 humanloop-0.4.8/humanloop/model/project_model_config_request.py
--rw-r--r--   0        0        0    18539 2023-06-12 17:10:44.673631 humanloop-0.4.8/humanloop/model/project_model_config_request.pyi
--rw-r--r--   0        0        0    24144 2023-06-12 17:10:44.673806 humanloop-0.4.8/humanloop/model/project_model_config_response.py
--rw-r--r--   0        0        0    24144 2023-06-12 17:10:44.674012 humanloop-0.4.8/humanloop/model/project_model_config_response.pyi
--rw-r--r--   0        0        0    14071 2023-06-12 17:10:44.674251 humanloop-0.4.8/humanloop/model/project_response.py
--rw-r--r--   0        0        0    14071 2023-06-12 17:10:44.674426 humanloop-0.4.8/humanloop/model/project_response.pyi
--rw-r--r--   0        0        0     1647 2023-06-12 17:10:44.674584 humanloop-0.4.8/humanloop/model/project_sort_by.py
--rw-r--r--   0        0        0     1476 2023-06-12 17:10:44.674708 humanloop-0.4.8/humanloop/model/project_sort_by.pyi
--rw-r--r--   0        0        0     3971 2023-06-12 17:10:44.674825 humanloop-0.4.8/humanloop/model/project_user_response.py
--rw-r--r--   0        0        0     3971 2023-06-12 17:10:44.674950 humanloop-0.4.8/humanloop/model/project_user_response.pyi
--rw-r--r--   0        0        0     1889 2023-06-12 17:10:44.675079 humanloop-0.4.8/humanloop/model/projects_get_configs_response.py
--rw-r--r--   0        0        0     1889 2023-06-12 17:10:44.675189 humanloop-0.4.8/humanloop/model/projects_get_configs_response.pyi
--rw-r--r--   0        0        0     1891 2023-06-12 17:10:44.675303 humanloop-0.4.8/humanloop/model/projects_update_feedback_types_request.py
--rw-r--r--   0        0        0     1891 2023-06-12 17:10:44.675398 humanloop-0.4.8/humanloop/model/projects_update_feedback_types_request.pyi
--rw-r--r--   0        0        0     6114 2023-06-12 17:10:44.675500 humanloop-0.4.8/humanloop/model/provider_api_keys.py
--rw-r--r--   0        0        0     6114 2023-06-12 17:10:44.675594 humanloop-0.4.8/humanloop/model/provider_api_keys.pyi
--rw-r--r--   0        0        0     3289 2023-06-12 17:10:44.675691 humanloop-0.4.8/humanloop/model/session_project_response.py
--rw-r--r--   0        0        0     3289 2023-06-12 17:10:44.675787 humanloop-0.4.8/humanloop/model/session_project_response.pyi
--rw-r--r--   0        0        0     6796 2023-06-12 17:10:44.675875 humanloop-0.4.8/humanloop/model/session_response.py
--rw-r--r--   0        0        0     6796 2023-06-12 17:10:44.675980 humanloop-0.4.8/humanloop/model/session_response.pyi
--rw-r--r--   0        0        0     1485 2023-06-12 17:10:44.676076 humanloop-0.4.8/humanloop/model/sort_order.py
--rw-r--r--   0        0        0     1368 2023-06-12 17:10:44.676177 humanloop-0.4.8/humanloop/model/sort_order.pyi
--rw-r--r--   0        0        0    18103 2023-06-12 17:10:44.676296 humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_model_config_response.py
--rw-r--r--   0        0        0    18103 2023-06-12 17:10:44.676430 humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_model_config_response.pyi
--rw-r--r--   0        0        0     5065 2023-06-12 17:10:44.676542 humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response.py
--rw-r--r--   0        0        0     5065 2023-06-12 17:10:44.676647 humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response.pyi
--rw-r--r--   0        0        0    19288 2023-06-12 17:10:44.676772 humanloop-0.4.8/humanloop/model/src_external_app_models_v4_configs_model_config_response.py
--rw-r--r--   0        0        0    19123 2023-06-12 17:10:44.676915 humanloop-0.4.8/humanloop/model/src_external_app_models_v4_configs_model_config_response.pyi
--rw-r--r--   0        0        0     5069 2023-06-12 17:10:44.677042 humanloop-0.4.8/humanloop/model/src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response.py
--rw-r--r--   0        0        0     5069 2023-06-12 17:10:44.677177 humanloop-0.4.8/humanloop/model/src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response.pyi
--rw-r--r--   0        0        0     5124 2023-06-12 17:10:44.677304 humanloop-0.4.8/humanloop/model/tool_config_request.py
--rw-r--r--   0        0        0     4961 2023-06-12 17:10:44.677421 humanloop-0.4.8/humanloop/model/tool_config_request.pyi
--rw-r--r--   0        0        0     5734 2023-06-12 17:10:44.677547 humanloop-0.4.8/humanloop/model/tool_config_response.py
--rw-r--r--   0        0        0     5571 2023-06-12 17:10:44.677664 humanloop-0.4.8/humanloop/model/tool_config_response.pyi
--rw-r--r--   0        0        0     4408 2023-06-12 17:10:44.677786 humanloop-0.4.8/humanloop/model/tool_result_response.py
--rw-r--r--   0        0        0     4408 2023-06-12 17:10:44.677899 humanloop-0.4.8/humanloop/model/tool_result_response.pyi
--rw-r--r--   0        0        0    13253 2023-06-12 17:10:44.678022 humanloop-0.4.8/humanloop/model/trace_log_request.py
--rw-r--r--   0        0        0    13253 2023-06-12 17:10:44.678171 humanloop-0.4.8/humanloop/model/trace_log_request.pyi
--rw-r--r--   0        0        0    19686 2023-06-12 17:10:44.678322 humanloop-0.4.8/humanloop/model/trace_model_config_request.py
--rw-r--r--   0        0        0    19521 2023-06-12 17:10:44.678457 humanloop-0.4.8/humanloop/model/trace_model_config_request.pyi
--rw-r--r--   0        0        0     7478 2023-06-12 17:10:44.678576 humanloop-0.4.8/humanloop/model/update_experiment_request.py
--rw-r--r--   0        0        0     7478 2023-06-12 17:10:44.678687 humanloop-0.4.8/humanloop/model/update_experiment_request.pyi
--rw-r--r--   0        0        0     3876 2023-06-12 17:10:44.678790 humanloop-0.4.8/humanloop/model/update_log_request.py
--rw-r--r--   0        0        0     3876 2023-06-12 17:10:44.678897 humanloop-0.4.8/humanloop/model/update_log_request.pyi
--rw-r--r--   0        0        0     5223 2023-06-12 17:10:44.679012 humanloop-0.4.8/humanloop/model/update_project_request.py
--rw-r--r--   0        0        0     5223 2023-06-12 17:10:44.679133 humanloop-0.4.8/humanloop/model/update_project_request.pyi
--rw-r--r--   0        0        0     4294 2023-06-12 17:10:44.679247 humanloop-0.4.8/humanloop/model/usage.py
--rw-r--r--   0        0        0     4294 2023-06-12 17:10:44.679351 humanloop-0.4.8/humanloop/model/usage.pyi
--rw-r--r--   0        0        0     6981 2023-06-12 17:10:44.679449 humanloop-0.4.8/humanloop/model/validation_error.py
--rw-r--r--   0        0        0     6981 2023-06-12 17:10:44.679550 humanloop-0.4.8/humanloop/model/validation_error.pyi
--rw-r--r--   0        0        0     6580 2023-06-12 17:10:44.679654 humanloop-0.4.8/humanloop/models/__init__.py
--rw-r--r--   0        0        0     1431 2023-06-12 17:10:44.679760 humanloop-0.4.8/humanloop/paths/__init__.py
--rw-r--r--   0        0        0      285 2023-06-12 17:10:44.679856 humanloop-0.4.8/humanloop/paths/chat/__init__.py
--rw-r--r--   0        0        0    18581 2023-06-12 17:10:44.679964 humanloop-0.4.8/humanloop/paths/chat/post.py
--rw-r--r--   0        0        0    18438 2023-06-12 17:10:44.680106 humanloop-0.4.8/humanloop/paths/chat/post.pyi
--rw-r--r--   0        0        0      302 2023-06-12 17:10:44.680228 humanloop-0.4.8/humanloop/paths/chat_deployed/__init__.py
--rw-r--r--   0        0        0    18144 2023-06-12 17:10:44.680359 humanloop-0.4.8/humanloop/paths/chat_deployed/post.py
--rw-r--r--   0        0        0    18001 2023-06-12 17:10:44.680491 humanloop-0.4.8/humanloop/paths/chat_deployed/post.pyi
--rw-r--r--   0        0        0      306 2023-06-12 17:10:44.680610 humanloop-0.4.8/humanloop/paths/chat_experiment/__init__.py
--rw-r--r--   0        0        0    18587 2023-06-12 17:10:44.680713 humanloop-0.4.8/humanloop/paths/chat_experiment/post.py
--rw-r--r--   0        0        0    18444 2023-06-12 17:10:44.680827 humanloop-0.4.8/humanloop/paths/chat_experiment/post.pyi
--rw-r--r--   0        0        0      309 2023-06-12 17:10:44.680935 humanloop-0.4.8/humanloop/paths/chat_model_config/__init__.py
--rw-r--r--   0        0        0    18762 2023-06-12 17:10:44.681037 humanloop-0.4.8/humanloop/paths/chat_model_config/post.py
--rw-r--r--   0        0        0    18619 2023-06-12 17:10:44.681179 humanloop-0.4.8/humanloop/paths/chat_model_config/post.pyi
--rw-r--r--   0        0        0      297 2023-06-12 17:10:44.681308 humanloop-0.4.8/humanloop/paths/completion/__init__.py
--rw-r--r--   0        0        0    18897 2023-06-12 17:10:44.681425 humanloop-0.4.8/humanloop/paths/completion/post.py
--rw-r--r--   0        0        0    18754 2023-06-12 17:10:44.681547 humanloop-0.4.8/humanloop/paths/completion/post.pyi
--rw-r--r--   0        0        0      314 2023-06-12 17:10:44.681660 humanloop-0.4.8/humanloop/paths/completion_deployed/__init__.py
--rw-r--r--   0        0        0    18400 2023-06-12 17:10:44.681772 humanloop-0.4.8/humanloop/paths/completion_deployed/post.py
--rw-r--r--   0        0        0    18257 2023-06-12 17:10:44.681886 humanloop-0.4.8/humanloop/paths/completion_deployed/post.pyi
--rw-r--r--   0        0        0      318 2023-06-12 17:10:44.681990 humanloop-0.4.8/humanloop/paths/completion_experiment/__init__.py
--rw-r--r--   0        0        0    18843 2023-06-12 17:10:44.682095 humanloop-0.4.8/humanloop/paths/completion_experiment/post.py
--rw-r--r--   0        0        0    18700 2023-06-12 17:10:44.682236 humanloop-0.4.8/humanloop/paths/completion_experiment/post.pyi
--rw-r--r--   0        0        0      321 2023-06-12 17:10:44.682350 humanloop-0.4.8/humanloop/paths/completion_model_config/__init__.py
--rw-r--r--   0        0        0    19018 2023-06-12 17:10:44.682460 humanloop-0.4.8/humanloop/paths/completion_model_config/post.py
--rw-r--r--   0        0        0    18875 2023-06-12 17:10:44.682581 humanloop-0.4.8/humanloop/paths/completion_model_config/post.pyi
--rw-r--r--   0        0        0      327 2023-06-12 17:10:44.682718 humanloop-0.4.8/humanloop/paths/experiments_experiment_id/__init__.py
--rw-r--r--   0        0        0    13100 2023-06-12 17:10:44.682841 humanloop-0.4.8/humanloop/paths/experiments_experiment_id/delete.py
--rw-r--r--   0        0        0    12957 2023-06-12 17:10:44.682981 humanloop-0.4.8/humanloop/paths/experiments_experiment_id/delete.pyi
--rw-r--r--   0        0        0    18196 2023-06-12 17:10:44.683132 humanloop-0.4.8/humanloop/paths/experiments_experiment_id/patch.py
--rw-r--r--   0        0        0    18053 2023-06-12 17:10:44.683296 humanloop-0.4.8/humanloop/paths/experiments_experiment_id/patch.pyi
--rw-r--r--   0        0        0      352 2023-06-12 17:10:44.683436 humanloop-0.4.8/humanloop/paths/experiments_experiment_id_model_config/__init__.py
--rw-r--r--   0        0        0    13601 2023-06-12 17:10:44.683537 humanloop-0.4.8/humanloop/paths/experiments_experiment_id_model_config/get.py
--rw-r--r--   0        0        0    13458 2023-06-12 17:10:44.683666 humanloop-0.4.8/humanloop/paths/experiments_experiment_id_model_config/get.pyi
--rw-r--r--   0        0        0      293 2023-06-12 17:10:44.683784 humanloop-0.4.8/humanloop/paths/feedback/__init__.py
--rw-r--r--   0        0        0    16242 2023-06-12 17:10:44.683891 humanloop-0.4.8/humanloop/paths/feedback/post.py
--rw-r--r--   0        0        0    16099 2023-06-12 17:10:44.684013 humanloop-0.4.8/humanloop/paths/feedback/post.pyi
--rw-r--r--   0        0        0      285 2023-06-12 17:10:44.684221 humanloop-0.4.8/humanloop/paths/logs/__init__.py
--rw-r--r--   0        0        0    17419 2023-06-12 17:10:44.684444 humanloop-0.4.8/humanloop/paths/logs/patch.py
--rw-r--r--   0        0        0    17276 2023-06-12 17:10:44.684646 humanloop-0.4.8/humanloop/paths/logs/patch.pyi
--rw-r--r--   0        0        0    23775 2023-06-12 17:10:44.684816 humanloop-0.4.8/humanloop/paths/logs/post.py
--rw-r--r--   0        0        0    23632 2023-06-12 17:10:44.684978 humanloop-0.4.8/humanloop/paths/logs/post.pyi
--rw-r--r--   0        0        0      291 2023-06-12 17:10:44.685104 humanloop-0.4.8/humanloop/paths/logs_id/__init__.py
--rw-r--r--   0        0        0    16485 2023-06-12 17:10:44.685220 humanloop-0.4.8/humanloop/paths/logs_id/patch.py
--rw-r--r--   0        0        0    16342 2023-06-12 17:10:44.685331 humanloop-0.4.8/humanloop/paths/logs_id/patch.pyi
--rw-r--r--   0        0        0      302 2023-06-12 17:10:44.685459 humanloop-0.4.8/humanloop/paths/model_configs/__init__.py
--rw-r--r--   0        0        0    21419 2023-06-12 17:10:44.685580 humanloop-0.4.8/humanloop/paths/model_configs/post.py
--rw-r--r--   0        0        0    21276 2023-06-12 17:10:44.685712 humanloop-0.4.8/humanloop/paths/model_configs/post.pyi
--rw-r--r--   0        0        0      308 2023-06-12 17:10:44.685851 humanloop-0.4.8/humanloop/paths/model_configs_id/__init__.py
--rw-r--r--   0        0        0    13414 2023-06-12 17:10:44.685956 humanloop-0.4.8/humanloop/paths/model_configs_id/get.py
--rw-r--r--   0        0        0    13271 2023-06-12 17:10:44.686084 humanloop-0.4.8/humanloop/paths/model_configs_id/get.pyi
--rw-r--r--   0        0        0      293 2023-06-12 17:10:44.686209 humanloop-0.4.8/humanloop/paths/projects/__init__.py
--rw-r--r--   0        0        0    21623 2023-06-12 17:10:44.686327 humanloop-0.4.8/humanloop/paths/projects/get.py
--rw-r--r--   0        0        0    21480 2023-06-12 17:10:44.686456 humanloop-0.4.8/humanloop/paths/projects/get.pyi
--rw-r--r--   0        0        0    14160 2023-06-12 17:10:44.686573 humanloop-0.4.8/humanloop/paths/projects/post.py
--rw-r--r--   0        0        0    14017 2023-06-12 17:10:44.686691 humanloop-0.4.8/humanloop/paths/projects/post.pyi
--rw-r--r--   0        0        0      299 2023-06-12 17:10:44.686829 humanloop-0.4.8/humanloop/paths/projects_id/__init__.py
--rw-r--r--   0        0        0    13084 2023-06-12 17:10:44.686933 humanloop-0.4.8/humanloop/paths/projects_id/get.py
--rw-r--r--   0        0        0    12941 2023-06-12 17:10:44.687050 humanloop-0.4.8/humanloop/paths/projects_id/get.pyi
--rw-r--r--   0        0        0    17219 2023-06-12 17:10:44.687174 humanloop-0.4.8/humanloop/paths/projects_id/patch.py
--rw-r--r--   0        0        0    17076 2023-06-12 17:10:44.687309 humanloop-0.4.8/humanloop/paths/projects_id/patch.pyi
--rw-r--r--   0        0        0      326 2023-06-12 17:10:44.687435 humanloop-0.4.8/humanloop/paths/projects_id_active_config/__init__.py
--rw-r--r--   0        0        0    13403 2023-06-12 17:10:44.687536 humanloop-0.4.8/humanloop/paths/projects_id_active_config/delete.py
--rw-r--r--   0        0        0    13260 2023-06-12 17:10:44.687666 humanloop-0.4.8/humanloop/paths/projects_id_active_config/delete.pyi
--rw-r--r--   0        0        0    13253 2023-06-12 17:10:44.687807 humanloop-0.4.8/humanloop/paths/projects_id_active_config/get.py
--rw-r--r--   0        0        0    13110 2023-06-12 17:10:44.687964 humanloop-0.4.8/humanloop/paths/projects_id_active_config/get.pyi
--rw-r--r--   0        0        0      334 2023-06-12 17:10:44.688091 humanloop-0.4.8/humanloop/paths/projects_id_active_experiment/__init__.py
--rw-r--r--   0        0        0    13411 2023-06-12 17:10:44.688205 humanloop-0.4.8/humanloop/paths/projects_id_active_experiment/delete.py
--rw-r--r--   0        0        0    13268 2023-06-12 17:10:44.688337 humanloop-0.4.8/humanloop/paths/projects_id_active_experiment/delete.pyi
--rw-r--r--   0        0        0      315 2023-06-12 17:10:44.688457 humanloop-0.4.8/humanloop/paths/projects_id_configs/__init__.py
--rw-r--r--   0        0        0    13287 2023-06-12 17:10:44.688560 humanloop-0.4.8/humanloop/paths/projects_id_configs/get.py
--rw-r--r--   0        0        0    13144 2023-06-12 17:10:44.688663 humanloop-0.4.8/humanloop/paths/projects_id_configs/get.pyi
--rw-r--r--   0        0        0      313 2023-06-12 17:10:44.688788 humanloop-0.4.8/humanloop/paths/projects_id_export/__init__.py
--rw-r--r--   0        0        0    16833 2023-06-12 17:10:44.688902 humanloop-0.4.8/humanloop/paths/projects_id_export/post.py
--rw-r--r--   0        0        0    16690 2023-06-12 17:10:44.689021 humanloop-0.4.8/humanloop/paths/projects_id_export/post.pyi
--rw-r--r--   0        0        0      328 2023-06-12 17:10:44.689138 humanloop-0.4.8/humanloop/paths/projects_id_feedback_types/__init__.py
--rw-r--r--   0        0        0    15951 2023-06-12 17:10:44.689236 humanloop-0.4.8/humanloop/paths/projects_id_feedback_types/patch.py
--rw-r--r--   0        0        0    15808 2023-06-12 17:10:44.689350 humanloop-0.4.8/humanloop/paths/projects_id_feedback_types/patch.pyi
--rw-r--r--   0        0        0      339 2023-06-12 17:10:44.689468 humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/__init__.py
--rw-r--r--   0        0        0    13361 2023-06-12 17:10:44.689569 humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/get.py
--rw-r--r--   0        0        0    13218 2023-06-12 17:10:44.689677 humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/get.pyi
--rw-r--r--   0        0        0    17403 2023-06-12 17:10:44.689819 humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/post.py
--rw-r--r--   0        0        0    17260 2023-06-12 17:10:44.689943 humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/post.pyi
--rw-r--r--   0        0        0      293 2023-06-12 17:10:44.690057 humanloop-0.4.8/humanloop/paths/sessions/__init__.py
--rw-r--r--   0        0        0    15217 2023-06-12 17:10:44.690165 humanloop-0.4.8/humanloop/paths/sessions/get.py
--rw-r--r--   0        0        0    15074 2023-06-12 17:10:44.690283 humanloop-0.4.8/humanloop/paths/sessions/get.pyi
--rw-r--r--   0        0        0    10297 2023-06-12 17:10:44.690398 humanloop-0.4.8/humanloop/paths/sessions/post.py
--rw-r--r--   0        0        0    10184 2023-06-12 17:10:44.690526 humanloop-0.4.8/humanloop/paths/sessions/post.pyi
--rw-r--r--   0        0        0      299 2023-06-12 17:10:44.690668 humanloop-0.4.8/humanloop/paths/sessions_id/__init__.py
--rw-r--r--   0        0        0    13084 2023-06-12 17:10:44.690838 humanloop-0.4.8/humanloop/paths/sessions_id/get.py
--rw-r--r--   0        0        0    12941 2023-06-12 17:10:44.691038 humanloop-0.4.8/humanloop/paths/sessions_id/get.pyi
--rw-r--r--   0        0        0      289 2023-06-12 17:10:44.691226 humanloop-0.4.8/humanloop/paths/traces/__init__.py
--rw-r--r--   0        0        0    13603 2023-06-12 17:10:44.691394 humanloop-0.4.8/humanloop/paths/traces/post.py
--rw-r--r--   0        0        0    13460 2023-06-12 17:10:44.691623 humanloop-0.4.8/humanloop/paths/traces/post.pyi
--rw-r--r--   0        0        0     1187 2023-06-12 17:10:44.691832 humanloop-0.4.8/humanloop/request_after_hook.py
--rw-r--r--   0        0        0     2325 2023-06-12 17:10:44.728424 humanloop-0.4.8/humanloop/request_before_hook.py
--rw-r--r--   0        0        0    11505 2023-06-12 17:10:44.692206 humanloop-0.4.8/humanloop/rest.py
--rw-r--r--   0        0        0    96089 2023-06-12 17:10:44.692577 humanloop-0.4.8/humanloop/schemas.py
--rw-r--r--   0        0        0        0 2023-06-12 17:10:44.692737 humanloop-0.4.8/humanloop/type/__init__.py
--rw-r--r--   0        0        0     1590 2023-06-12 17:10:44.692889 humanloop-0.4.8/humanloop/type/agent_config_request.py
--rw-r--r--   0        0        0     1705 2023-06-12 17:10:44.693069 humanloop-0.4.8/humanloop/type/agent_config_response.py
--rw-r--r--   0        0        0     1584 2023-06-12 17:10:44.693239 humanloop-0.4.8/humanloop/type/base_metric_response.py
--rw-r--r--   0        0        0     1238 2023-06-12 17:10:44.693410 humanloop-0.4.8/humanloop/type/categorical_feedback_label.py
--rw-r--r--   0        0        0     2359 2023-06-12 17:10:44.693553 humanloop-0.4.8/humanloop/type/chat_data_response.py
--rw-r--r--   0        0        0     2166 2023-06-12 17:10:44.693693 humanloop-0.4.8/humanloop/type/chat_deployed_request.py
--rw-r--r--   0        0        0     2411 2023-06-12 17:10:44.693819 humanloop-0.4.8/humanloop/type/chat_experiment_request.py
--rw-r--r--   0        0        0     1095 2023-06-12 17:10:44.694053 humanloop-0.4.8/humanloop/type/chat_message.py
--rw-r--r--   0        0        0     2280 2023-06-12 17:10:44.694226 humanloop-0.4.8/humanloop/type/chat_model_config_request.py
--rw-r--r--   0        0        0     2306 2023-06-12 17:10:44.694366 humanloop-0.4.8/humanloop/type/chat_request.py
--rw-r--r--   0        0        0     1994 2023-06-12 17:10:44.694515 humanloop-0.4.8/humanloop/type/chat_response.py
--rw-r--r--   0        0        0      887 2023-06-12 17:10:44.694663 humanloop-0.4.8/humanloop/type/chat_role.py
--rw-r--r--   0        0        0     2271 2023-06-12 17:10:44.694820 humanloop-0.4.8/humanloop/type/completion_deployed_request.py
--rw-r--r--   0        0        0     2519 2023-06-12 17:10:44.694981 humanloop-0.4.8/humanloop/type/completion_experiment_request.py
--rw-r--r--   0        0        0     2385 2023-06-12 17:10:44.695146 humanloop-0.4.8/humanloop/type/completion_model_config_request.py
--rw-r--r--   0        0        0     2415 2023-06-12 17:10:44.695283 humanloop-0.4.8/humanloop/type/completion_request.py
--rw-r--r--   0        0        0     2040 2023-06-12 17:10:44.695440 humanloop-0.4.8/humanloop/type/completion_response.py
--rw-r--r--   0        0        0     1320 2023-06-12 17:10:44.695594 humanloop-0.4.8/humanloop/type/config_response.py
--rw-r--r--   0        0        0      895 2023-06-12 17:10:44.695737 humanloop-0.4.8/humanloop/type/config_type.py
--rw-r--r--   0        0        0     1538 2023-06-12 17:10:44.695888 humanloop-0.4.8/humanloop/type/create_experiment_request.py
--rw-r--r--   0        0        0     1200 2023-06-12 17:10:44.696044 humanloop-0.4.8/humanloop/type/create_log_response.py
--rw-r--r--   0        0        0     1242 2023-06-12 17:10:44.696178 humanloop-0.4.8/humanloop/type/create_project_request.py
--rw-r--r--   0        0        0     1118 2023-06-12 17:10:44.696323 humanloop-0.4.8/humanloop/type/create_session_response.py
--rw-r--r--   0        0        0     1221 2023-06-12 17:10:44.696480 humanloop-0.4.8/humanloop/type/create_trace_request.py
--rw-r--r--   0        0        0     1174 2023-06-12 17:10:44.696644 humanloop-0.4.8/humanloop/type/create_trace_response.py
--rw-r--r--   0        0        0     2189 2023-06-12 17:10:44.696761 humanloop-0.4.8/humanloop/type/data_response.py
--rw-r--r--   0        0        0     1853 2023-06-12 17:10:44.696866 humanloop-0.4.8/humanloop/type/experiment_config_response.py
--rw-r--r--   0        0        0     1964 2023-06-12 17:10:44.696989 humanloop-0.4.8/humanloop/type/experiment_response.py
--rw-r--r--   0        0        0      894 2023-06-12 17:10:44.697147 humanloop-0.4.8/humanloop/type/experiment_status.py
--rw-r--r--   0        0        0      961 2023-06-12 17:10:44.697283 humanloop-0.4.8/humanloop/type/experiments_list_response.py
--rw-r--r--   0        0        0     1625 2023-06-12 17:10:44.697395 humanloop-0.4.8/humanloop/type/feedback.py
--rw-r--r--   0        0        0      895 2023-06-12 17:10:44.697489 humanloop-0.4.8/humanloop/type/feedback_class.py
--rw-r--r--   0        0        0     1146 2023-06-12 17:10:44.697573 humanloop-0.4.8/humanloop/type/feedback_label_request.py
--rw-r--r--   0        0        0     1722 2023-06-12 17:10:44.697662 humanloop-0.4.8/humanloop/type/feedback_request.py
--rw-r--r--   0        0        0     1754 2023-06-12 17:10:44.697743 humanloop-0.4.8/humanloop/type/feedback_response.py
--rw-r--r--   0        0        0      980 2023-06-12 17:10:44.697835 humanloop-0.4.8/humanloop/type/feedback_submit_request.py
--rw-r--r--   0        0        0      985 2023-06-12 17:10:44.697917 humanloop-0.4.8/humanloop/type/feedback_submit_response.py
--rw-r--r--   0        0        0      914 2023-06-12 17:10:44.698009 humanloop-0.4.8/humanloop/type/feedback_type.py
--rw-r--r--   0        0        0     1483 2023-06-12 17:10:44.698097 humanloop-0.4.8/humanloop/type/feedback_type_model.py
--rw-r--r--   0        0        0     1717 2023-06-12 17:10:44.698202 humanloop-0.4.8/humanloop/type/feedback_type_request.py
--rw-r--r--   0        0        0      949 2023-06-12 17:10:44.698353 humanloop-0.4.8/humanloop/type/feedback_types.py
--rw-r--r--   0        0        0     1240 2023-06-12 17:10:44.698521 humanloop-0.4.8/humanloop/type/generic_config_request.py
--rw-r--r--   0        0        0     1359 2023-06-12 17:10:44.698683 humanloop-0.4.8/humanloop/type/generic_config_response.py
--rw-r--r--   0        0        0     2076 2023-06-12 17:10:44.698847 humanloop-0.4.8/humanloop/type/get_model_config_response.py
--rw-r--r--   0        0        0     1148 2023-06-12 17:10:44.699137 humanloop-0.4.8/humanloop/type/http_validation_error.py
--rw-r--r--   0        0        0      906 2023-06-12 17:10:44.699374 humanloop-0.4.8/humanloop/type/label_sentiment.py
--rw-r--r--   0        0        0      958 2023-06-12 17:10:44.699556 humanloop-0.4.8/humanloop/type/log_datapoint_request.py
--rw-r--r--   0        0        0     3209 2023-06-12 17:10:44.699709 humanloop-0.4.8/humanloop/type/log_model_config_request.py
--rw-r--r--   0        0        0     3857 2023-06-12 17:10:44.699831 humanloop-0.4.8/humanloop/type/log_request.py
--rw-r--r--   0        0        0     4048 2023-06-12 17:10:44.699984 humanloop-0.4.8/humanloop/type/log_response.py
--rw-r--r--   0        0        0      983 2023-06-12 17:10:44.700136 humanloop-0.4.8/humanloop/type/logs_log_response.py
--rw-r--r--   0        0        0     2996 2023-06-12 17:10:44.700282 humanloop-0.4.8/humanloop/type/model_config_chat_request.py
--rw-r--r--   0        0        0     2889 2023-06-12 17:10:44.700433 humanloop-0.4.8/humanloop/type/model_config_completion_request.py
--rw-r--r--   0        0        0      890 2023-06-12 17:10:44.700565 humanloop-0.4.8/humanloop/type/model_endpoints.py
--rw-r--r--   0        0        0      940 2023-06-12 17:10:44.700703 humanloop-0.4.8/humanloop/type/model_providers.py
--rw-r--r--   0        0        0     1208 2023-06-12 17:10:44.700850 humanloop-0.4.8/humanloop/type/paginated_data_log_response.py
--rw-r--r--   0        0        0     1240 2023-06-12 17:10:44.700945 humanloop-0.4.8/humanloop/type/paginated_data_project_response.py
--rw-r--r--   0        0        0     1240 2023-06-12 17:10:44.701079 humanloop-0.4.8/humanloop/type/paginated_data_session_response.py
--rw-r--r--   0        0        0     1047 2023-06-12 17:10:44.701216 humanloop-0.4.8/humanloop/type/positive_label.py
--rw-r--r--   0        0        0     1996 2023-06-12 17:10:44.701355 humanloop-0.4.8/humanloop/type/project_config_response.py
--rw-r--r--   0        0        0     3586 2023-06-12 17:10:44.701499 humanloop-0.4.8/humanloop/type/project_model_config_request.py
--rw-r--r--   0        0        0     4229 2023-06-12 17:10:44.701655 humanloop-0.4.8/humanloop/type/project_model_config_response.py
--rw-r--r--   0        0        0     2208 2023-06-12 17:10:44.701812 humanloop-0.4.8/humanloop/type/project_response.py
--rw-r--r--   0        0        0      897 2023-06-12 17:10:44.701949 humanloop-0.4.8/humanloop/type/project_sort_by.py
--rw-r--r--   0        0        0     1198 2023-06-12 17:10:44.702100 humanloop-0.4.8/humanloop/type/project_user_response.py
--rw-r--r--   0        0        0      974 2023-06-12 17:10:44.702239 humanloop-0.4.8/humanloop/type/projects_get_configs_response.py
--rw-r--r--   0        0        0      976 2023-06-12 17:10:44.702387 humanloop-0.4.8/humanloop/type/projects_update_feedback_types_request.py
--rw-r--r--   0        0        0     1165 2023-06-12 17:10:44.702529 humanloop-0.4.8/humanloop/type/provider_api_keys.py
--rw-r--r--   0        0        0     1161 2023-06-12 17:10:44.702703 humanloop-0.4.8/humanloop/type/session_project_response.py
--rw-r--r--   0        0        0     1618 2023-06-12 17:10:44.702860 humanloop-0.4.8/humanloop/type/session_response.py
--rw-r--r--   0        0        0      872 2023-06-12 17:10:44.703004 humanloop-0.4.8/humanloop/type/sort_order.py
--rw-r--r--   0        0        0     3506 2023-06-12 17:10:44.703166 humanloop-0.4.8/humanloop/type/src_external_app_models_v3_model_configs_model_config_response.py
--rw-r--r--   0        0        0     1417 2023-06-12 17:10:44.703317 humanloop-0.4.8/humanloop/type/src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response.py
--rw-r--r--   0        0        0     3518 2023-06-12 17:10:44.703533 humanloop-0.4.8/humanloop/type/src_external_app_models_v4_configs_model_config_response.py
--rw-r--r--   0        0        0     1427 2023-06-12 17:10:44.703727 humanloop-0.4.8/humanloop/type/src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response.py
--rw-r--r--   0        0        0     1242 2023-06-12 17:10:44.703888 humanloop-0.4.8/humanloop/type/tool_config_request.py
--rw-r--r--   0        0        0     1392 2023-06-12 17:10:44.704033 humanloop-0.4.8/humanloop/type/tool_config_response.py
--rw-r--r--   0        0        0     1106 2023-06-12 17:10:44.704199 humanloop-0.4.8/humanloop/type/tool_result_response.py
--rw-r--r--   0        0        0     2632 2023-06-12 17:10:44.704369 humanloop-0.4.8/humanloop/type/trace_log_request.py
--rw-r--r--   0        0        0     3271 2023-06-12 17:10:44.704554 humanloop-0.4.8/humanloop/type/trace_model_config_request.py
--rw-r--r--   0        0        0     1537 2023-06-12 17:10:44.704749 humanloop-0.4.8/humanloop/type/update_experiment_request.py
--rw-r--r--   0        0        0     1259 2023-06-12 17:10:44.704933 humanloop-0.4.8/humanloop/type/update_log_request.py
--rw-r--r--   0        0        0     1610 2023-06-12 17:10:44.705260 humanloop-0.4.8/humanloop/type/update_project_request.py
--rw-r--r--   0        0        0     1218 2023-06-12 17:10:44.705465 humanloop-0.4.8/humanloop/type/usage.py
--rw-r--r--   0        0        0     1127 2023-06-12 17:10:44.705633 humanloop-0.4.8/humanloop/type/validation_error.py
--rw-r--r--   0        0        0     1044 2023-06-12 17:10:44.705802 humanloop-0.4.8/humanloop/type_util.py
--rw-r--r--   0        0        0     3165 2023-06-12 17:10:44.705976 humanloop-0.4.8/humanloop/validation_metadata.py
--rw-r--r--   0        0        0      714 2023-06-12 17:10:44.706612 humanloop-0.4.8/pyproject.toml
--rw-r--r--   0        0        0     9366 1970-01-01 00:00:00.000000 humanloop-0.4.8/PKG-INFO
+-rw-r--r--   0        0        0     1081 2023-06-13 15:26:54.640769 humanloop-0.4.9/LICENSE
+-rw-r--r--   0        0        0     8475 2023-06-13 15:26:54.691957 humanloop-0.4.9/README.md
+-rw-r--r--   0        0        0     1235 2023-06-13 15:26:54.554201 humanloop-0.4.9/humanloop/__init__.py
+-rw-r--r--   0        0        0    72575 2023-06-13 15:26:54.554588 humanloop-0.4.9/humanloop/api_client.py
+-rw-r--r--   0        0        0      663 2023-06-13 15:26:54.554749 humanloop-0.4.9/humanloop/api_response.py
+-rw-r--r--   0        0        0      214 2023-06-13 15:26:54.554873 humanloop-0.4.9/humanloop/apis/__init__.py
+-rw-r--r--   0        0        0     4698 2023-06-13 15:26:54.555055 humanloop-0.4.9/humanloop/apis/path_to_api.py
+-rw-r--r--   0        0        0      236 2023-06-13 15:26:54.555192 humanloop-0.4.9/humanloop/apis/paths/__init__.py
+-rw-r--r--   0        0        0       91 2023-06-13 15:26:54.555303 humanloop-0.4.9/humanloop/apis/paths/chat.py
+-rw-r--r--   0        0        0      108 2023-06-13 15:26:54.555439 humanloop-0.4.9/humanloop/apis/paths/chat_deployed.py
+-rw-r--r--   0        0        0      112 2023-06-13 15:26:54.555567 humanloop-0.4.9/humanloop/apis/paths/chat_experiment.py
+-rw-r--r--   0        0        0      115 2023-06-13 15:26:54.555700 humanloop-0.4.9/humanloop/apis/paths/chat_model_config.py
+-rw-r--r--   0        0        0      103 2023-06-13 15:26:54.555843 humanloop-0.4.9/humanloop/apis/paths/completion.py
+-rw-r--r--   0        0        0      120 2023-06-13 15:26:54.556203 humanloop-0.4.9/humanloop/apis/paths/completion_deployed.py
+-rw-r--r--   0        0        0      124 2023-06-13 15:26:54.556665 humanloop-0.4.9/humanloop/apis/paths/completion_experiment.py
+-rw-r--r--   0        0        0      127 2023-06-13 15:26:54.556843 humanloop-0.4.9/humanloop/apis/paths/completion_model_config.py
+-rw-r--r--   0        0        0      226 2023-06-13 15:26:54.556983 humanloop-0.4.9/humanloop/apis/paths/experiments_experiment_id.py
+-rw-r--r--   0        0        0      152 2023-06-13 15:26:54.557125 humanloop-0.4.9/humanloop/apis/paths/experiments_experiment_id_model_config.py
+-rw-r--r--   0        0        0       99 2023-06-13 15:26:54.557350 humanloop-0.4.9/humanloop/apis/paths/feedback.py
+-rw-r--r--   0        0        0      159 2023-06-13 15:26:54.557520 humanloop-0.4.9/humanloop/apis/paths/logs.py
+-rw-r--r--   0        0        0       99 2023-06-13 15:26:54.557631 humanloop-0.4.9/humanloop/apis/paths/logs_id.py
+-rw-r--r--   0        0        0      108 2023-06-13 15:26:54.557754 humanloop-0.4.9/humanloop/apis/paths/model_configs.py
+-rw-r--r--   0        0        0      110 2023-06-13 15:26:54.557892 humanloop-0.4.9/humanloop/apis/paths/model_configs_id.py
+-rw-r--r--   0        0        0      165 2023-06-13 15:26:54.558018 humanloop-0.4.9/humanloop/apis/paths/projects.py
+-rw-r--r--   0        0        0      176 2023-06-13 15:26:54.558141 humanloop-0.4.9/humanloop/apis/paths/projects_id.py
+-rw-r--r--   0        0        0      219 2023-06-13 15:26:54.558295 humanloop-0.4.9/humanloop/apis/paths/projects_id_active_config.py
+-rw-r--r--   0        0        0      144 2023-06-13 15:26:54.558452 humanloop-0.4.9/humanloop/apis/paths/projects_id_active_experiment.py
+-rw-r--r--   0        0        0      116 2023-06-13 15:26:54.558948 humanloop-0.4.9/humanloop/apis/paths/projects_id_configs.py
+-rw-r--r--   0        0        0      117 2023-06-13 15:26:54.559157 humanloop-0.4.9/humanloop/apis/paths/projects_id_export.py
+-rw-r--r--   0        0        0      135 2023-06-13 15:26:54.559333 humanloop-0.4.9/humanloop/apis/paths/projects_id_feedback_types.py
+-rw-r--r--   0        0        0      231 2023-06-13 15:26:54.559514 humanloop-0.4.9/humanloop/apis/paths/projects_project_id_experiments.py
+-rw-r--r--   0        0        0      165 2023-06-13 15:26:54.559679 humanloop-0.4.9/humanloop/apis/paths/sessions.py
+-rw-r--r--   0        0        0      101 2023-06-13 15:26:54.559825 humanloop-0.4.9/humanloop/apis/paths/sessions_id.py
+-rw-r--r--   0        0        0       95 2023-06-13 15:26:54.559954 humanloop-0.4.9/humanloop/apis/paths/traces.py
+-rw-r--r--   0        0        0     1654 2023-06-13 15:26:54.560104 humanloop-0.4.9/humanloop/apis/tag_to_api.py
+-rw-r--r--   0        0        0      572 2023-06-13 15:26:54.560218 humanloop-0.4.9/humanloop/apis/tags/__init__.py
+-rw-r--r--   0        0        0     1182 2023-06-13 15:26:54.560430 humanloop-0.4.9/humanloop/apis/tags/chats_api.py
+-rw-r--r--   0        0        0     1196 2023-06-13 15:26:54.560575 humanloop-0.4.9/humanloop/apis/tags/completions_api.py
+-rw-r--r--   0        0        0     1267 2023-06-13 15:26:54.560736 humanloop-0.4.9/humanloop/apis/tags/experiments_api.py
+-rw-r--r--   0        0        0      897 2023-06-13 15:26:54.560878 humanloop-0.4.9/humanloop/apis/tags/feedback_api.py
+-rw-r--r--   0        0        0     1028 2023-06-13 15:26:54.561019 humanloop-0.4.9/humanloop/apis/tags/logs_api.py
+-rw-r--r--   0        0        0      979 2023-06-13 15:26:54.561120 humanloop-0.4.9/humanloop/apis/tags/model_configurations_api.py
+-rw-r--r--   0        0        0     1662 2023-06-13 15:26:54.561216 humanloop-0.4.9/humanloop/apis/tags/projects_api.py
+-rw-r--r--   0        0        0     1010 2023-06-13 15:26:54.561313 humanloop-0.4.9/humanloop/apis/tags/sessions_api.py
+-rw-r--r--   0        0        0      893 2023-06-13 15:26:54.561405 humanloop-0.4.9/humanloop/apis/tags/traces_api.py
+-rw-r--r--   0        0        0    37166 2023-06-13 15:26:54.561536 humanloop-0.4.9/humanloop/client.py
+-rw-r--r--   0        0        0    37166 2023-06-13 15:26:54.561752 humanloop-0.4.9/humanloop/client.pyi
+-rw-r--r--   0        0        0     6780 2023-06-13 15:26:54.639862 humanloop-0.4.9/humanloop/client_custom.py
+-rw-r--r--   0        0        0    19154 2023-06-13 15:26:54.561993 humanloop-0.4.9/humanloop/configuration.py
+-rw-r--r--   0        0        0     8215 2023-06-13 15:26:54.562189 humanloop-0.4.9/humanloop/exceptions.py
+-rw-r--r--   0        0        0     2274 2023-06-13 15:26:54.562384 humanloop-0.4.9/humanloop/exceptions_base.py
+-rw-r--r--   0        0        0      343 2023-06-13 15:26:54.562900 humanloop-0.4.9/humanloop/model/__init__.py
+-rw-r--r--   0        0        0     9316 2023-06-13 15:26:54.563406 humanloop-0.4.9/humanloop/model/agent_config_request.py
+-rw-r--r--   0        0        0     9151 2023-06-13 15:26:54.563653 humanloop-0.4.9/humanloop/model/agent_config_request.pyi
+-rw-r--r--   0        0        0     9818 2023-06-13 15:26:54.563849 humanloop-0.4.9/humanloop/model/agent_config_response.py
+-rw-r--r--   0        0        0     9653 2023-06-13 15:26:54.563988 humanloop-0.4.9/humanloop/model/agent_config_response.pyi
+-rw-r--r--   0        0        0     6555 2023-06-13 15:26:54.564112 humanloop-0.4.9/humanloop/model/base_metric_response.py
+-rw-r--r--   0        0        0     6555 2023-06-13 15:26:54.564235 humanloop-0.4.9/humanloop/model/base_metric_response.pyi
+-rw-r--r--   0        0        0     5326 2023-06-13 15:26:54.564371 humanloop-0.4.9/humanloop/model/categorical_feedback_label.py
+-rw-r--r--   0        0        0     5326 2023-06-13 15:26:54.564520 humanloop-0.4.9/humanloop/model/categorical_feedback_label.pyi
+-rw-r--r--   0        0        0     9133 2023-06-13 15:26:54.564685 humanloop-0.4.9/humanloop/model/chat_data_response.py
+-rw-r--r--   0        0        0     9133 2023-06-13 15:26:54.564906 humanloop-0.4.9/humanloop/model/chat_data_response.pyi
+-rw-r--r--   0        0        0    13457 2023-06-13 15:26:54.565177 humanloop-0.4.9/humanloop/model/chat_deployed_request.py
+-rw-r--r--   0        0        0    13457 2023-06-13 15:26:54.565409 humanloop-0.4.9/humanloop/model/chat_deployed_request.pyi
+-rw-r--r--   0        0        0    14118 2023-06-13 15:26:54.565619 humanloop-0.4.9/humanloop/model/chat_experiment_request.py
+-rw-r--r--   0        0        0    14118 2023-06-13 15:26:54.565832 humanloop-0.4.9/humanloop/model/chat_experiment_request.pyi
+-rw-r--r--   0        0        0     3878 2023-06-13 15:26:54.566050 humanloop-0.4.9/humanloop/model/chat_message.py
+-rw-r--r--   0        0        0     3878 2023-06-13 15:26:54.566210 humanloop-0.4.9/humanloop/model/chat_message.pyi
+-rw-r--r--   0        0        0    14152 2023-06-13 15:26:54.566402 humanloop-0.4.9/humanloop/model/chat_model_config_request.py
+-rw-r--r--   0        0        0    14152 2023-06-13 15:26:54.566641 humanloop-0.4.9/humanloop/model/chat_model_config_request.pyi
+-rw-r--r--   0        0        0    16015 2023-06-13 15:26:54.566902 humanloop-0.4.9/humanloop/model/chat_request.py
+-rw-r--r--   0        0        0    16015 2023-06-13 15:26:54.567154 humanloop-0.4.9/humanloop/model/chat_request.pyi
+-rw-r--r--   0        0        0    11252 2023-06-13 15:26:54.567303 humanloop-0.4.9/humanloop/model/chat_response.py
+-rw-r--r--   0        0        0    11252 2023-06-13 15:26:54.567486 humanloop-0.4.9/humanloop/model/chat_response.pyi
+-rw-r--r--   0        0        0     1622 2023-06-13 15:26:54.567676 humanloop-0.4.9/humanloop/model/chat_role.py
+-rw-r--r--   0        0        0     1461 2023-06-13 15:26:54.567837 humanloop-0.4.9/humanloop/model/chat_role.pyi
+-rw-r--r--   0        0        0    13094 2023-06-13 15:26:54.568024 humanloop-0.4.9/humanloop/model/completion_deployed_request.py
+-rw-r--r--   0        0        0    13094 2023-06-13 15:26:54.568262 humanloop-0.4.9/humanloop/model/completion_deployed_request.pyi
+-rw-r--r--   0        0        0    13796 2023-06-13 15:26:54.568440 humanloop-0.4.9/humanloop/model/completion_experiment_request.py
+-rw-r--r--   0        0        0    13796 2023-06-13 15:26:54.568775 humanloop-0.4.9/humanloop/model/completion_experiment_request.pyi
+-rw-r--r--   0        0        0    13832 2023-06-13 15:26:54.569007 humanloop-0.4.9/humanloop/model/completion_model_config_request.py
+-rw-r--r--   0        0        0    13832 2023-06-13 15:26:54.569144 humanloop-0.4.9/humanloop/model/completion_model_config_request.pyi
+-rw-r--r--   0        0        0    15714 2023-06-13 15:26:54.569275 humanloop-0.4.9/humanloop/model/completion_request.py
+-rw-r--r--   0        0        0    15714 2023-06-13 15:26:54.569399 humanloop-0.4.9/humanloop/model/completion_request.pyi
+-rw-r--r--   0        0        0    11193 2023-06-13 15:26:54.569607 humanloop-0.4.9/humanloop/model/completion_response.py
+-rw-r--r--   0        0        0    11193 2023-06-13 15:26:54.569779 humanloop-0.4.9/humanloop/model/completion_response.pyi
+-rw-r--r--   0        0        0     3636 2023-06-13 15:26:54.569963 humanloop-0.4.9/humanloop/model/config_response.py
+-rw-r--r--   0        0        0     3636 2023-06-13 15:26:54.570107 humanloop-0.4.9/humanloop/model/config_response.pyi
+-rw-r--r--   0        0        0     1722 2023-06-13 15:26:54.570237 humanloop-0.4.9/humanloop/model/config_type.py
+-rw-r--r--   0        0        0     1537 2023-06-13 15:26:54.570383 humanloop-0.4.9/humanloop/model/config_type.pyi
+-rw-r--r--   0        0        0     6372 2023-06-13 15:26:54.570546 humanloop-0.4.9/humanloop/model/create_experiment_request.py
+-rw-r--r--   0        0        0     6372 2023-06-13 15:26:54.570705 humanloop-0.4.9/humanloop/model/create_experiment_request.pyi
+-rw-r--r--   0        0        0     3375 2023-06-13 15:26:54.570849 humanloop-0.4.9/humanloop/model/create_log_response.py
+-rw-r--r--   0        0        0     3375 2023-06-13 15:26:54.570995 humanloop-0.4.9/humanloop/model/create_log_response.pyi
+-rw-r--r--   0        0        0     4442 2023-06-13 15:26:54.571135 humanloop-0.4.9/humanloop/model/create_project_request.py
+-rw-r--r--   0        0        0     4442 2023-06-13 15:26:54.571283 humanloop-0.4.9/humanloop/model/create_project_request.pyi
+-rw-r--r--   0        0        0     2811 2023-06-13 15:26:54.571426 humanloop-0.4.9/humanloop/model/create_session_response.py
+-rw-r--r--   0        0        0     2811 2023-06-13 15:26:54.571559 humanloop-0.4.9/humanloop/model/create_session_response.pyi
+-rw-r--r--   0        0        0     3408 2023-06-13 15:26:54.571719 humanloop-0.4.9/humanloop/model/create_trace_request.py
+-rw-r--r--   0        0        0     3408 2023-06-13 15:26:54.571835 humanloop-0.4.9/humanloop/model/create_trace_request.pyi
+-rw-r--r--   0        0        0     3505 2023-06-13 15:26:54.571954 humanloop-0.4.9/humanloop/model/create_trace_response.py
+-rw-r--r--   0        0        0     3505 2023-06-13 15:26:54.572106 humanloop-0.4.9/humanloop/model/create_trace_response.pyi
+-rw-r--r--   0        0        0     7631 2023-06-13 15:26:54.572225 humanloop-0.4.9/humanloop/model/data_response.py
+-rw-r--r--   0        0        0     7631 2023-06-13 15:26:54.572370 humanloop-0.4.9/humanloop/model/data_response.pyi
+-rw-r--r--   0        0        0     9174 2023-06-13 15:26:54.572494 humanloop-0.4.9/humanloop/model/experiment_config_response.py
+-rw-r--r--   0        0        0     9174 2023-06-13 15:26:54.572723 humanloop-0.4.9/humanloop/model/experiment_config_response.pyi
+-rw-r--r--   0        0        0    13003 2023-06-13 15:26:54.572926 humanloop-0.4.9/humanloop/model/experiment_response.py
+-rw-r--r--   0        0        0    13003 2023-06-13 15:26:54.573169 humanloop-0.4.9/humanloop/model/experiment_response.pyi
+-rw-r--r--   0        0        0     1552 2023-06-13 15:26:54.573371 humanloop-0.4.9/humanloop/model/experiment_status.py
+-rw-r--r--   0        0        0     1405 2023-06-13 15:26:54.573545 humanloop-0.4.9/humanloop/model/experiment_status.pyi
+-rw-r--r--   0        0        0     1861 2023-06-13 15:26:54.573721 humanloop-0.4.9/humanloop/model/experiments_list_response.py
+-rw-r--r--   0        0        0     1861 2023-06-13 15:26:54.574051 humanloop-0.4.9/humanloop/model/experiments_list_response.pyi
+-rw-r--r--   0        0        0     6857 2023-06-13 15:26:54.574221 humanloop-0.4.9/humanloop/model/feedback.py
+-rw-r--r--   0        0        0     6857 2023-06-13 15:26:54.574365 humanloop-0.4.9/humanloop/model/feedback.pyi
+-rw-r--r--   0        0        0     1639 2023-06-13 15:26:54.574514 humanloop-0.4.9/humanloop/model/feedback_class.py
+-rw-r--r--   0        0        0     1472 2023-06-13 15:26:54.574632 humanloop-0.4.9/humanloop/model/feedback_class.pyi
+-rw-r--r--   0        0        0     3510 2023-06-13 15:26:54.574797 humanloop-0.4.9/humanloop/model/feedback_label_request.py
+-rw-r--r--   0        0        0     3510 2023-06-13 15:26:54.575031 humanloop-0.4.9/humanloop/model/feedback_label_request.pyi
+-rw-r--r--   0        0        0     7365 2023-06-13 15:26:54.575197 humanloop-0.4.9/humanloop/model/feedback_request.py
+-rw-r--r--   0        0        0     7365 2023-06-13 15:26:54.575401 humanloop-0.4.9/humanloop/model/feedback_request.pyi
+-rw-r--r--   0        0        0     7317 2023-06-13 15:26:54.575602 humanloop-0.4.9/humanloop/model/feedback_response.py
+-rw-r--r--   0        0        0     7317 2023-06-13 15:26:54.575779 humanloop-0.4.9/humanloop/model/feedback_response.pyi
+-rw-r--r--   0        0        0     3376 2023-06-13 15:26:54.575967 humanloop-0.4.9/humanloop/model/feedback_submit_request.py
+-rw-r--r--   0        0        0     3376 2023-06-13 15:26:54.576178 humanloop-0.4.9/humanloop/model/feedback_submit_request.pyi
+-rw-r--r--   0        0        0     3386 2023-06-13 15:26:54.576345 humanloop-0.4.9/humanloop/model/feedback_submit_response.py
+-rw-r--r--   0        0        0     3386 2023-06-13 15:26:54.576503 humanloop-0.4.9/humanloop/model/feedback_submit_response.pyi
+-rw-r--r--   0        0        0     1866 2023-06-13 15:26:54.576662 humanloop-0.4.9/humanloop/model/feedback_type.py
+-rw-r--r--   0        0        0     1635 2023-06-13 15:26:54.576806 humanloop-0.4.9/humanloop/model/feedback_type.pyi
+-rw-r--r--   0        0        0     6337 2023-06-13 15:26:54.576896 humanloop-0.4.9/humanloop/model/feedback_type_model.py
+-rw-r--r--   0        0        0     6337 2023-06-13 15:26:54.577084 humanloop-0.4.9/humanloop/model/feedback_type_model.pyi
+-rw-r--r--   0        0        0     6465 2023-06-13 15:26:54.577225 humanloop-0.4.9/humanloop/model/feedback_type_request.py
+-rw-r--r--   0        0        0     6465 2023-06-13 15:26:54.577365 humanloop-0.4.9/humanloop/model/feedback_type_request.pyi
+-rw-r--r--   0        0        0     1835 2023-06-13 15:26:54.577535 humanloop-0.4.9/humanloop/model/feedback_types.py
+-rw-r--r--   0        0        0     1835 2023-06-13 15:26:54.577707 humanloop-0.4.9/humanloop/model/feedback_types.pyi
+-rw-r--r--   0        0        0     4583 2023-06-13 15:26:54.577811 humanloop-0.4.9/humanloop/model/generic_config_request.py
+-rw-r--r--   0        0        0     4414 2023-06-13 15:26:54.577910 humanloop-0.4.9/humanloop/model/generic_config_request.pyi
+-rw-r--r--   0        0        0     5247 2023-06-13 15:26:54.578059 humanloop-0.4.9/humanloop/model/generic_config_response.py
+-rw-r--r--   0        0        0     5078 2023-06-13 15:26:54.578194 humanloop-0.4.9/humanloop/model/generic_config_response.pyi
+-rw-r--r--   0        0        0     9572 2023-06-13 15:26:54.578307 humanloop-0.4.9/humanloop/model/get_model_config_response.py
+-rw-r--r--   0        0        0     9572 2023-06-13 15:26:54.578539 humanloop-0.4.9/humanloop/model/get_model_config_response.pyi
+-rw-r--r--   0        0        0     3787 2023-06-13 15:26:54.578715 humanloop-0.4.9/humanloop/model/http_validation_error.py
+-rw-r--r--   0        0        0     3787 2023-06-13 15:26:54.578827 humanloop-0.4.9/humanloop/model/http_validation_error.pyi
+-rw-r--r--   0        0        0     1843 2023-06-13 15:26:54.578971 humanloop-0.4.9/humanloop/model/label_sentiment.py
+-rw-r--r--   0        0        0     1644 2023-06-13 15:26:54.579063 humanloop-0.4.9/humanloop/model/label_sentiment.pyi
+-rw-r--r--   0        0        0     3332 2023-06-13 15:26:54.579156 humanloop-0.4.9/humanloop/model/log_datapoint_request.py
+-rw-r--r--   0        0        0     3332 2023-06-13 15:26:54.579281 humanloop-0.4.9/humanloop/model/log_datapoint_request.pyi
+-rw-r--r--   0        0        0    17395 2023-06-13 15:26:54.579470 humanloop-0.4.9/humanloop/model/log_model_config_request.py
+-rw-r--r--   0        0        0    17395 2023-06-13 15:26:54.579693 humanloop-0.4.9/humanloop/model/log_model_config_request.pyi
+-rw-r--r--   0        0        0    18526 2023-06-13 15:26:54.579881 humanloop-0.4.9/humanloop/model/log_request.py
+-rw-r--r--   0        0        0    18526 2023-06-13 15:26:54.580093 humanloop-0.4.9/humanloop/model/log_request.pyi
+-rw-r--r--   0        0        0    22300 2023-06-13 15:26:54.580323 humanloop-0.4.9/humanloop/model/log_response.py
+-rw-r--r--   0        0        0    22300 2023-06-13 15:26:54.580548 humanloop-0.4.9/humanloop/model/log_response.pyi
+-rw-r--r--   0        0        0     3381 2023-06-13 15:26:54.580731 humanloop-0.4.9/humanloop/model/logs_log_response.py
+-rw-r--r--   0        0        0     3381 2023-06-13 15:26:54.580869 humanloop-0.4.9/humanloop/model/logs_log_response.pyi
+-rw-r--r--   0        0        0    16422 2023-06-13 15:26:54.581066 humanloop-0.4.9/humanloop/model/model_config_chat_request.py
+-rw-r--r--   0        0        0    16422 2023-06-13 15:26:54.581271 humanloop-0.4.9/humanloop/model/model_config_chat_request.pyi
+-rw-r--r--   0        0        0    15562 2023-06-13 15:26:54.581461 humanloop-0.4.9/humanloop/model/model_config_completion_request.py
+-rw-r--r--   0        0        0    15562 2023-06-13 15:26:54.581664 humanloop-0.4.9/humanloop/model/model_config_completion_request.pyi
+-rw-r--r--   0        0        0     1636 2023-06-13 15:26:54.581844 humanloop-0.4.9/humanloop/model/model_endpoints.py
+-rw-r--r--   0        0        0     1481 2023-06-13 15:26:54.581990 humanloop-0.4.9/humanloop/model/model_endpoints.pyi
+-rw-r--r--   0        0        0     2123 2023-06-13 15:26:54.582147 humanloop-0.4.9/humanloop/model/model_providers.py
+-rw-r--r--   0        0        0     1820 2023-06-13 15:26:54.582308 humanloop-0.4.9/humanloop/model/model_providers.pyi
+-rw-r--r--   0        0        0     5320 2023-06-13 15:26:54.582455 humanloop-0.4.9/humanloop/model/paginated_data_log_response.py
+-rw-r--r--   0        0        0     5320 2023-06-13 15:26:54.582614 humanloop-0.4.9/humanloop/model/paginated_data_log_response.pyi
+-rw-r--r--   0        0        0     5356 2023-06-13 15:26:54.582774 humanloop-0.4.9/humanloop/model/paginated_data_project_response.py
+-rw-r--r--   0        0        0     5356 2023-06-13 15:26:54.582937 humanloop-0.4.9/humanloop/model/paginated_data_project_response.pyi
+-rw-r--r--   0        0        0     5356 2023-06-13 15:26:54.583098 humanloop-0.4.9/humanloop/model/paginated_data_session_response.py
+-rw-r--r--   0        0        0     5356 2023-06-13 15:26:54.583257 humanloop-0.4.9/humanloop/model/paginated_data_session_response.pyi
+-rw-r--r--   0        0        0     3319 2023-06-13 15:26:54.583410 humanloop-0.4.9/humanloop/model/positive_label.py
+-rw-r--r--   0        0        0     3319 2023-06-13 15:26:54.583553 humanloop-0.4.9/humanloop/model/positive_label.pyi
+-rw-r--r--   0        0        0     8853 2023-06-13 15:26:54.583723 humanloop-0.4.9/humanloop/model/project_config_response.py
+-rw-r--r--   0        0        0     8853 2023-06-13 15:26:54.584077 humanloop-0.4.9/humanloop/model/project_config_response.pyi
+-rw-r--r--   0        0        0     4997 2023-06-13 15:26:54.584315 humanloop-0.4.9/humanloop/model/project_model_config_feedback_stats_response.py
+-rw-r--r--   0        0        0     4997 2023-06-13 15:26:54.584433 humanloop-0.4.9/humanloop/model/project_model_config_feedback_stats_response.pyi
+-rw-r--r--   0        0        0    18447 2023-06-13 15:26:54.584552 humanloop-0.4.9/humanloop/model/project_model_config_request.py
+-rw-r--r--   0        0        0    18447 2023-06-13 15:26:54.584708 humanloop-0.4.9/humanloop/model/project_model_config_request.pyi
+-rw-r--r--   0        0        0    14071 2023-06-13 15:26:54.584840 humanloop-0.4.9/humanloop/model/project_response.py
+-rw-r--r--   0        0        0    14071 2023-06-13 15:26:54.584982 humanloop-0.4.9/humanloop/model/project_response.pyi
+-rw-r--r--   0        0        0     1647 2023-06-13 15:26:54.585099 humanloop-0.4.9/humanloop/model/project_sort_by.py
+-rw-r--r--   0        0        0     1476 2023-06-13 15:26:54.585211 humanloop-0.4.9/humanloop/model/project_sort_by.pyi
+-rw-r--r--   0        0        0     3971 2023-06-13 15:26:54.585396 humanloop-0.4.9/humanloop/model/project_user_response.py
+-rw-r--r--   0        0        0     3971 2023-06-13 15:26:54.585539 humanloop-0.4.9/humanloop/model/project_user_response.pyi
+-rw-r--r--   0        0        0     1889 2023-06-13 15:26:54.585674 humanloop-0.4.9/humanloop/model/projects_get_configs_response.py
+-rw-r--r--   0        0        0     1889 2023-06-13 15:26:54.585829 humanloop-0.4.9/humanloop/model/projects_get_configs_response.pyi
+-rw-r--r--   0        0        0     1891 2023-06-13 15:26:54.585960 humanloop-0.4.9/humanloop/model/projects_update_feedback_types_request.py
+-rw-r--r--   0        0        0     1891 2023-06-13 15:26:54.586114 humanloop-0.4.9/humanloop/model/projects_update_feedback_types_request.pyi
+-rw-r--r--   0        0        0     6114 2023-06-13 15:26:54.586247 humanloop-0.4.9/humanloop/model/provider_api_keys.py
+-rw-r--r--   0        0        0     6114 2023-06-13 15:26:54.586399 humanloop-0.4.9/humanloop/model/provider_api_keys.pyi
+-rw-r--r--   0        0        0     3289 2023-06-13 15:26:54.586547 humanloop-0.4.9/humanloop/model/session_project_response.py
+-rw-r--r--   0        0        0     3289 2023-06-13 15:26:54.586684 humanloop-0.4.9/humanloop/model/session_project_response.pyi
+-rw-r--r--   0        0        0     6796 2023-06-13 15:26:54.586810 humanloop-0.4.9/humanloop/model/session_response.py
+-rw-r--r--   0        0        0     6796 2023-06-13 15:26:54.586920 humanloop-0.4.9/humanloop/model/session_response.pyi
+-rw-r--r--   0        0        0     1485 2023-06-13 15:26:54.587029 humanloop-0.4.9/humanloop/model/sort_order.py
+-rw-r--r--   0        0        0     1368 2023-06-13 15:26:54.587159 humanloop-0.4.9/humanloop/model/sort_order.pyi
+-rw-r--r--   0        0        0    19288 2023-06-13 15:26:54.587322 humanloop-0.4.9/humanloop/model/src_external_app_models_v4_configs_model_config_response.py
+-rw-r--r--   0        0        0    19123 2023-06-13 15:26:54.587481 humanloop-0.4.9/humanloop/model/src_external_app_models_v4_configs_model_config_response.pyi
+-rw-r--r--   0        0        0    18103 2023-06-13 15:26:54.587636 humanloop-0.4.9/humanloop/model/src_external_app_models_v4_model_configs_model_config_response.py
+-rw-r--r--   0        0        0    18103 2023-06-13 15:26:54.587796 humanloop-0.4.9/humanloop/model/src_external_app_models_v4_model_configs_model_config_response.pyi
+-rw-r--r--   0        0        0     5124 2023-06-13 15:26:54.587926 humanloop-0.4.9/humanloop/model/tool_config_request.py
+-rw-r--r--   0        0        0     4961 2023-06-13 15:26:54.588058 humanloop-0.4.9/humanloop/model/tool_config_request.pyi
+-rw-r--r--   0        0        0     5734 2023-06-13 15:26:54.588168 humanloop-0.4.9/humanloop/model/tool_config_response.py
+-rw-r--r--   0        0        0     5571 2023-06-13 15:26:54.588301 humanloop-0.4.9/humanloop/model/tool_config_response.pyi
+-rw-r--r--   0        0        0     4408 2023-06-13 15:26:54.588399 humanloop-0.4.9/humanloop/model/tool_result_response.py
+-rw-r--r--   0        0        0     4408 2023-06-13 15:26:54.588514 humanloop-0.4.9/humanloop/model/tool_result_response.pyi
+-rw-r--r--   0        0        0    13253 2023-06-13 15:26:54.588621 humanloop-0.4.9/humanloop/model/trace_log_request.py
+-rw-r--r--   0        0        0    13253 2023-06-13 15:26:54.588743 humanloop-0.4.9/humanloop/model/trace_log_request.pyi
+-rw-r--r--   0        0        0    19686 2023-06-13 15:26:54.588873 humanloop-0.4.9/humanloop/model/trace_model_config_request.py
+-rw-r--r--   0        0        0    19521 2023-06-13 15:26:54.588991 humanloop-0.4.9/humanloop/model/trace_model_config_request.pyi
+-rw-r--r--   0        0        0     7478 2023-06-13 15:26:54.589091 humanloop-0.4.9/humanloop/model/update_experiment_request.py
+-rw-r--r--   0        0        0     7478 2023-06-13 15:26:54.589184 humanloop-0.4.9/humanloop/model/update_experiment_request.pyi
+-rw-r--r--   0        0        0     3876 2023-06-13 15:26:54.589277 humanloop-0.4.9/humanloop/model/update_log_request.py
+-rw-r--r--   0        0        0     3876 2023-06-13 15:26:54.589383 humanloop-0.4.9/humanloop/model/update_log_request.pyi
+-rw-r--r--   0        0        0     5223 2023-06-13 15:26:54.589499 humanloop-0.4.9/humanloop/model/update_project_request.py
+-rw-r--r--   0        0        0     5223 2023-06-13 15:26:54.589623 humanloop-0.4.9/humanloop/model/update_project_request.pyi
+-rw-r--r--   0        0        0     4294 2023-06-13 15:26:54.589713 humanloop-0.4.9/humanloop/model/usage.py
+-rw-r--r--   0        0        0     4294 2023-06-13 15:26:54.589856 humanloop-0.4.9/humanloop/model/usage.pyi
+-rw-r--r--   0        0        0     6981 2023-06-13 15:26:54.590016 humanloop-0.4.9/humanloop/model/validation_error.py
+-rw-r--r--   0        0        0     6981 2023-06-13 15:26:54.590130 humanloop-0.4.9/humanloop/model/validation_error.pyi
+-rw-r--r--   0        0        0     6228 2023-06-13 15:26:54.590240 humanloop-0.4.9/humanloop/models/__init__.py
+-rw-r--r--   0        0        0     1431 2023-06-13 15:26:54.590347 humanloop-0.4.9/humanloop/paths/__init__.py
+-rw-r--r--   0        0        0      285 2023-06-13 15:26:54.590438 humanloop-0.4.9/humanloop/paths/chat/__init__.py
+-rw-r--r--   0        0        0    21314 2023-06-13 15:26:54.590566 humanloop-0.4.9/humanloop/paths/chat/post.py
+-rw-r--r--   0        0        0    21171 2023-06-13 15:26:54.590698 humanloop-0.4.9/humanloop/paths/chat/post.pyi
+-rw-r--r--   0        0        0      302 2023-06-13 15:26:54.590816 humanloop-0.4.9/humanloop/paths/chat_deployed/__init__.py
+-rw-r--r--   0        0        0    20877 2023-06-13 15:26:54.590929 humanloop-0.4.9/humanloop/paths/chat_deployed/post.py
+-rw-r--r--   0        0        0    20734 2023-06-13 15:26:54.591052 humanloop-0.4.9/humanloop/paths/chat_deployed/post.pyi
+-rw-r--r--   0        0        0      306 2023-06-13 15:26:54.591169 humanloop-0.4.9/humanloop/paths/chat_experiment/__init__.py
+-rw-r--r--   0        0        0    21320 2023-06-13 15:26:54.591276 humanloop-0.4.9/humanloop/paths/chat_experiment/post.py
+-rw-r--r--   0        0        0    21177 2023-06-13 15:26:54.591390 humanloop-0.4.9/humanloop/paths/chat_experiment/post.pyi
+-rw-r--r--   0        0        0      309 2023-06-13 15:26:54.591506 humanloop-0.4.9/humanloop/paths/chat_model_config/__init__.py
+-rw-r--r--   0        0        0    21495 2023-06-13 15:26:54.591613 humanloop-0.4.9/humanloop/paths/chat_model_config/post.py
+-rw-r--r--   0        0        0    21352 2023-06-13 15:26:54.591781 humanloop-0.4.9/humanloop/paths/chat_model_config/post.pyi
+-rw-r--r--   0        0        0      297 2023-06-13 15:26:54.591930 humanloop-0.4.9/humanloop/paths/completion/__init__.py
+-rw-r--r--   0        0        0    21750 2023-06-13 15:26:54.592082 humanloop-0.4.9/humanloop/paths/completion/post.py
+-rw-r--r--   0        0        0    21607 2023-06-13 15:26:54.592239 humanloop-0.4.9/humanloop/paths/completion/post.pyi
+-rw-r--r--   0        0        0      314 2023-06-13 15:26:54.592379 humanloop-0.4.9/humanloop/paths/completion_deployed/__init__.py
+-rw-r--r--   0        0        0    21253 2023-06-13 15:26:54.592511 humanloop-0.4.9/humanloop/paths/completion_deployed/post.py
+-rw-r--r--   0        0        0    21110 2023-06-13 15:26:54.592666 humanloop-0.4.9/humanloop/paths/completion_deployed/post.pyi
+-rw-r--r--   0        0        0      318 2023-06-13 15:26:54.592800 humanloop-0.4.9/humanloop/paths/completion_experiment/__init__.py
+-rw-r--r--   0        0        0    21696 2023-06-13 15:26:54.593022 humanloop-0.4.9/humanloop/paths/completion_experiment/post.py
+-rw-r--r--   0        0        0    21553 2023-06-13 15:26:54.593184 humanloop-0.4.9/humanloop/paths/completion_experiment/post.pyi
+-rw-r--r--   0        0        0      321 2023-06-13 15:26:54.593343 humanloop-0.4.9/humanloop/paths/completion_model_config/__init__.py
+-rw-r--r--   0        0        0    21871 2023-06-13 15:26:54.593485 humanloop-0.4.9/humanloop/paths/completion_model_config/post.py
+-rw-r--r--   0        0        0    21728 2023-06-13 15:26:54.593634 humanloop-0.4.9/humanloop/paths/completion_model_config/post.pyi
+-rw-r--r--   0        0        0      327 2023-06-13 15:26:54.593762 humanloop-0.4.9/humanloop/paths/experiments_experiment_id/__init__.py
+-rw-r--r--   0        0        0    13100 2023-06-13 15:26:54.593908 humanloop-0.4.9/humanloop/paths/experiments_experiment_id/delete.py
+-rw-r--r--   0        0        0    12957 2023-06-13 15:26:54.594086 humanloop-0.4.9/humanloop/paths/experiments_experiment_id/delete.pyi
+-rw-r--r--   0        0        0    18196 2023-06-13 15:26:54.594241 humanloop-0.4.9/humanloop/paths/experiments_experiment_id/patch.py
+-rw-r--r--   0        0        0    18053 2023-06-13 15:26:54.594393 humanloop-0.4.9/humanloop/paths/experiments_experiment_id/patch.pyi
+-rw-r--r--   0        0        0      352 2023-06-13 15:26:54.594563 humanloop-0.4.9/humanloop/paths/experiments_experiment_id_model_config/__init__.py
+-rw-r--r--   0        0        0    13601 2023-06-13 15:26:54.594803 humanloop-0.4.9/humanloop/paths/experiments_experiment_id_model_config/get.py
+-rw-r--r--   0        0        0    13458 2023-06-13 15:26:54.595008 humanloop-0.4.9/humanloop/paths/experiments_experiment_id_model_config/get.pyi
+-rw-r--r--   0        0        0      293 2023-06-13 15:26:54.595175 humanloop-0.4.9/humanloop/paths/feedback/__init__.py
+-rw-r--r--   0        0        0    16242 2023-06-13 15:26:54.595304 humanloop-0.4.9/humanloop/paths/feedback/post.py
+-rw-r--r--   0        0        0    16099 2023-06-13 15:26:54.595479 humanloop-0.4.9/humanloop/paths/feedback/post.pyi
+-rw-r--r--   0        0        0      285 2023-06-13 15:26:54.596099 humanloop-0.4.9/humanloop/paths/logs/__init__.py
+-rw-r--r--   0        0        0    17419 2023-06-13 15:26:54.596253 humanloop-0.4.9/humanloop/paths/logs/patch.py
+-rw-r--r--   0        0        0    17276 2023-06-13 15:26:54.596391 humanloop-0.4.9/humanloop/paths/logs/patch.pyi
+-rw-r--r--   0        0        0    24240 2023-06-13 15:26:54.596618 humanloop-0.4.9/humanloop/paths/logs/post.py
+-rw-r--r--   0        0        0    24097 2023-06-13 15:26:54.596819 humanloop-0.4.9/humanloop/paths/logs/post.pyi
+-rw-r--r--   0        0        0      291 2023-06-13 15:26:54.596989 humanloop-0.4.9/humanloop/paths/logs_id/__init__.py
+-rw-r--r--   0        0        0    16485 2023-06-13 15:26:54.597109 humanloop-0.4.9/humanloop/paths/logs_id/patch.py
+-rw-r--r--   0        0        0    16342 2023-06-13 15:26:54.597245 humanloop-0.4.9/humanloop/paths/logs_id/patch.pyi
+-rw-r--r--   0        0        0      302 2023-06-13 15:26:54.597445 humanloop-0.4.9/humanloop/paths/model_configs/__init__.py
+-rw-r--r--   0        0        0    21377 2023-06-13 15:26:54.597603 humanloop-0.4.9/humanloop/paths/model_configs/post.py
+-rw-r--r--   0        0        0    21234 2023-06-13 15:26:54.597809 humanloop-0.4.9/humanloop/paths/model_configs/post.pyi
+-rw-r--r--   0        0        0      308 2023-06-13 15:26:54.598013 humanloop-0.4.9/humanloop/paths/model_configs_id/__init__.py
+-rw-r--r--   0        0        0    13414 2023-06-13 15:26:54.598183 humanloop-0.4.9/humanloop/paths/model_configs_id/get.py
+-rw-r--r--   0        0        0    13271 2023-06-13 15:26:54.598440 humanloop-0.4.9/humanloop/paths/model_configs_id/get.pyi
+-rw-r--r--   0        0        0      293 2023-06-13 15:26:54.598633 humanloop-0.4.9/humanloop/paths/projects/__init__.py
+-rw-r--r--   0        0        0    21623 2023-06-13 15:26:54.598806 humanloop-0.4.9/humanloop/paths/projects/get.py
+-rw-r--r--   0        0        0    21480 2023-06-13 15:26:54.599008 humanloop-0.4.9/humanloop/paths/projects/get.pyi
+-rw-r--r--   0        0        0    14160 2023-06-13 15:26:54.599195 humanloop-0.4.9/humanloop/paths/projects/post.py
+-rw-r--r--   0        0        0    14017 2023-06-13 15:26:54.599417 humanloop-0.4.9/humanloop/paths/projects/post.pyi
+-rw-r--r--   0        0        0      299 2023-06-13 15:26:54.599624 humanloop-0.4.9/humanloop/paths/projects_id/__init__.py
+-rw-r--r--   0        0        0    13084 2023-06-13 15:26:54.599790 humanloop-0.4.9/humanloop/paths/projects_id/get.py
+-rw-r--r--   0        0        0    12941 2023-06-13 15:26:54.599997 humanloop-0.4.9/humanloop/paths/projects_id/get.pyi
+-rw-r--r--   0        0        0    17219 2023-06-13 15:26:54.600217 humanloop-0.4.9/humanloop/paths/projects_id/patch.py
+-rw-r--r--   0        0        0    17076 2023-06-13 15:26:54.600433 humanloop-0.4.9/humanloop/paths/projects_id/patch.pyi
+-rw-r--r--   0        0        0      326 2023-06-13 15:26:54.600635 humanloop-0.4.9/humanloop/paths/projects_id_active_config/__init__.py
+-rw-r--r--   0        0        0    13403 2023-06-13 15:26:54.600808 humanloop-0.4.9/humanloop/paths/projects_id_active_config/delete.py
+-rw-r--r--   0        0        0    13260 2023-06-13 15:26:54.601019 humanloop-0.4.9/humanloop/paths/projects_id_active_config/delete.pyi
+-rw-r--r--   0        0        0    13253 2023-06-13 15:26:54.601196 humanloop-0.4.9/humanloop/paths/projects_id_active_config/get.py
+-rw-r--r--   0        0        0    13110 2023-06-13 15:26:54.601302 humanloop-0.4.9/humanloop/paths/projects_id_active_config/get.pyi
+-rw-r--r--   0        0        0      334 2023-06-13 15:26:54.601413 humanloop-0.4.9/humanloop/paths/projects_id_active_experiment/__init__.py
+-rw-r--r--   0        0        0    13411 2023-06-13 15:26:54.601543 humanloop-0.4.9/humanloop/paths/projects_id_active_experiment/delete.py
+-rw-r--r--   0        0        0    13268 2023-06-13 15:26:54.601693 humanloop-0.4.9/humanloop/paths/projects_id_active_experiment/delete.pyi
+-rw-r--r--   0        0        0      315 2023-06-13 15:26:54.601844 humanloop-0.4.9/humanloop/paths/projects_id_configs/__init__.py
+-rw-r--r--   0        0        0    13287 2023-06-13 15:26:54.602004 humanloop-0.4.9/humanloop/paths/projects_id_configs/get.py
+-rw-r--r--   0        0        0    13144 2023-06-13 15:26:54.602206 humanloop-0.4.9/humanloop/paths/projects_id_configs/get.pyi
+-rw-r--r--   0        0        0      313 2023-06-13 15:26:54.602374 humanloop-0.4.9/humanloop/paths/projects_id_export/__init__.py
+-rw-r--r--   0        0        0    16833 2023-06-13 15:26:54.602534 humanloop-0.4.9/humanloop/paths/projects_id_export/post.py
+-rw-r--r--   0        0        0    16690 2023-06-13 15:26:54.602743 humanloop-0.4.9/humanloop/paths/projects_id_export/post.pyi
+-rw-r--r--   0        0        0      328 2023-06-13 15:26:54.602932 humanloop-0.4.9/humanloop/paths/projects_id_feedback_types/__init__.py
+-rw-r--r--   0        0        0    15951 2023-06-13 15:26:54.603094 humanloop-0.4.9/humanloop/paths/projects_id_feedback_types/patch.py
+-rw-r--r--   0        0        0    15808 2023-06-13 15:26:54.603282 humanloop-0.4.9/humanloop/paths/projects_id_feedback_types/patch.pyi
+-rw-r--r--   0        0        0      339 2023-06-13 15:26:54.603482 humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/__init__.py
+-rw-r--r--   0        0        0    13361 2023-06-13 15:26:54.603643 humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/get.py
+-rw-r--r--   0        0        0    13218 2023-06-13 15:26:54.603933 humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/get.pyi
+-rw-r--r--   0        0        0    17403 2023-06-13 15:26:54.604100 humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/post.py
+-rw-r--r--   0        0        0    17260 2023-06-13 15:26:54.604241 humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/post.pyi
+-rw-r--r--   0        0        0      293 2023-06-13 15:26:54.604393 humanloop-0.4.9/humanloop/paths/sessions/__init__.py
+-rw-r--r--   0        0        0    15217 2023-06-13 15:26:54.604571 humanloop-0.4.9/humanloop/paths/sessions/get.py
+-rw-r--r--   0        0        0    15074 2023-06-13 15:26:54.604817 humanloop-0.4.9/humanloop/paths/sessions/get.pyi
+-rw-r--r--   0        0        0    10297 2023-06-13 15:26:54.604975 humanloop-0.4.9/humanloop/paths/sessions/post.py
+-rw-r--r--   0        0        0    10184 2023-06-13 15:26:54.605133 humanloop-0.4.9/humanloop/paths/sessions/post.pyi
+-rw-r--r--   0        0        0      299 2023-06-13 15:26:54.605422 humanloop-0.4.9/humanloop/paths/sessions_id/__init__.py
+-rw-r--r--   0        0        0    13084 2023-06-13 15:26:54.605647 humanloop-0.4.9/humanloop/paths/sessions_id/get.py
+-rw-r--r--   0        0        0    12941 2023-06-13 15:26:54.605808 humanloop-0.4.9/humanloop/paths/sessions_id/get.pyi
+-rw-r--r--   0        0        0      289 2023-06-13 15:26:54.605924 humanloop-0.4.9/humanloop/paths/traces/__init__.py
+-rw-r--r--   0        0        0    13603 2023-06-13 15:26:54.606016 humanloop-0.4.9/humanloop/paths/traces/post.py
+-rw-r--r--   0        0        0    13460 2023-06-13 15:26:54.606120 humanloop-0.4.9/humanloop/paths/traces/post.pyi
+-rw-r--r--   0        0        0     1187 2023-06-13 15:26:54.606233 humanloop-0.4.9/humanloop/request_after_hook.py
+-rw-r--r--   0        0        0     2325 2023-06-13 15:26:54.640233 humanloop-0.4.9/humanloop/request_before_hook.py
+-rw-r--r--   0        0        0    11505 2023-06-13 15:26:54.606489 humanloop-0.4.9/humanloop/rest.py
+-rw-r--r--   0        0        0    96089 2023-06-13 15:26:54.606863 humanloop-0.4.9/humanloop/schemas.py
+-rw-r--r--   0        0        0        0 2023-06-13 15:26:54.607054 humanloop-0.4.9/humanloop/type/__init__.py
+-rw-r--r--   0        0        0     1590 2023-06-13 15:26:54.607225 humanloop-0.4.9/humanloop/type/agent_config_request.py
+-rw-r--r--   0        0        0     1705 2023-06-13 15:26:54.607420 humanloop-0.4.9/humanloop/type/agent_config_response.py
+-rw-r--r--   0        0        0     1584 2023-06-13 15:26:54.607580 humanloop-0.4.9/humanloop/type/base_metric_response.py
+-rw-r--r--   0        0        0     1238 2023-06-13 15:26:54.607717 humanloop-0.4.9/humanloop/type/categorical_feedback_label.py
+-rw-r--r--   0        0        0     2359 2023-06-13 15:26:54.607832 humanloop-0.4.9/humanloop/type/chat_data_response.py
+-rw-r--r--   0        0        0     3210 2023-06-13 15:26:54.607962 humanloop-0.4.9/humanloop/type/chat_deployed_request.py
+-rw-r--r--   0        0        0     3455 2023-06-13 15:26:54.608095 humanloop-0.4.9/humanloop/type/chat_experiment_request.py
+-rw-r--r--   0        0        0     1095 2023-06-13 15:26:54.608235 humanloop-0.4.9/humanloop/type/chat_message.py
+-rw-r--r--   0        0        0     3324 2023-06-13 15:26:54.608377 humanloop-0.4.9/humanloop/type/chat_model_config_request.py
+-rw-r--r--   0        0        0     3350 2023-06-13 15:26:54.608517 humanloop-0.4.9/humanloop/type/chat_request.py
+-rw-r--r--   0        0        0     1994 2023-06-13 15:26:54.608657 humanloop-0.4.9/humanloop/type/chat_response.py
+-rw-r--r--   0        0        0      887 2023-06-13 15:26:54.608798 humanloop-0.4.9/humanloop/type/chat_role.py
+-rw-r--r--   0        0        0     3323 2023-06-13 15:26:54.608946 humanloop-0.4.9/humanloop/type/completion_deployed_request.py
+-rw-r--r--   0        0        0     3561 2023-06-13 15:26:54.609090 humanloop-0.4.9/humanloop/type/completion_experiment_request.py
+-rw-r--r--   0        0        0     3427 2023-06-13 15:26:54.609276 humanloop-0.4.9/humanloop/type/completion_model_config_request.py
+-rw-r--r--   0        0        0     3457 2023-06-13 15:26:54.609417 humanloop-0.4.9/humanloop/type/completion_request.py
+-rw-r--r--   0        0        0     2040 2023-06-13 15:26:54.609561 humanloop-0.4.9/humanloop/type/completion_response.py
+-rw-r--r--   0        0        0     1320 2023-06-13 15:26:54.609698 humanloop-0.4.9/humanloop/type/config_response.py
+-rw-r--r--   0        0        0      895 2023-06-13 15:26:54.609863 humanloop-0.4.9/humanloop/type/config_type.py
+-rw-r--r--   0        0        0     1538 2023-06-13 15:26:54.610000 humanloop-0.4.9/humanloop/type/create_experiment_request.py
+-rw-r--r--   0        0        0     1200 2023-06-13 15:26:54.610141 humanloop-0.4.9/humanloop/type/create_log_response.py
+-rw-r--r--   0        0        0     1242 2023-06-13 15:26:54.610371 humanloop-0.4.9/humanloop/type/create_project_request.py
+-rw-r--r--   0        0        0     1118 2023-06-13 15:26:54.610533 humanloop-0.4.9/humanloop/type/create_session_response.py
+-rw-r--r--   0        0        0     1221 2023-06-13 15:26:54.610690 humanloop-0.4.9/humanloop/type/create_trace_request.py
+-rw-r--r--   0        0        0     1174 2023-06-13 15:26:54.610831 humanloop-0.4.9/humanloop/type/create_trace_response.py
+-rw-r--r--   0        0        0     2189 2023-06-13 15:26:54.610966 humanloop-0.4.9/humanloop/type/data_response.py
+-rw-r--r--   0        0        0     1853 2023-06-13 15:26:54.611095 humanloop-0.4.9/humanloop/type/experiment_config_response.py
+-rw-r--r--   0        0        0     1964 2023-06-13 15:26:54.611209 humanloop-0.4.9/humanloop/type/experiment_response.py
+-rw-r--r--   0        0        0      894 2023-06-13 15:26:54.611445 humanloop-0.4.9/humanloop/type/experiment_status.py
+-rw-r--r--   0        0        0      961 2023-06-13 15:26:54.611693 humanloop-0.4.9/humanloop/type/experiments_list_response.py
+-rw-r--r--   0        0        0     1625 2023-06-13 15:26:54.611861 humanloop-0.4.9/humanloop/type/feedback.py
+-rw-r--r--   0        0        0      895 2023-06-13 15:26:54.612039 humanloop-0.4.9/humanloop/type/feedback_class.py
+-rw-r--r--   0        0        0     1146 2023-06-13 15:26:54.612217 humanloop-0.4.9/humanloop/type/feedback_label_request.py
+-rw-r--r--   0        0        0     1722 2023-06-13 15:26:54.612405 humanloop-0.4.9/humanloop/type/feedback_request.py
+-rw-r--r--   0        0        0     1754 2023-06-13 15:26:54.612552 humanloop-0.4.9/humanloop/type/feedback_response.py
+-rw-r--r--   0        0        0      980 2023-06-13 15:26:54.613245 humanloop-0.4.9/humanloop/type/feedback_submit_request.py
+-rw-r--r--   0        0        0      985 2023-06-13 15:26:54.613459 humanloop-0.4.9/humanloop/type/feedback_submit_response.py
+-rw-r--r--   0        0        0      914 2023-06-13 15:26:54.613808 humanloop-0.4.9/humanloop/type/feedback_type.py
+-rw-r--r--   0        0        0     1483 2023-06-13 15:26:54.614071 humanloop-0.4.9/humanloop/type/feedback_type_model.py
+-rw-r--r--   0        0        0     1717 2023-06-13 15:26:54.614312 humanloop-0.4.9/humanloop/type/feedback_type_request.py
+-rw-r--r--   0        0        0      949 2023-06-13 15:26:54.614537 humanloop-0.4.9/humanloop/type/feedback_types.py
+-rw-r--r--   0        0        0     1240 2023-06-13 15:26:54.614766 humanloop-0.4.9/humanloop/type/generic_config_request.py
+-rw-r--r--   0        0        0     1359 2023-06-13 15:26:54.614973 humanloop-0.4.9/humanloop/type/generic_config_response.py
+-rw-r--r--   0        0        0     1961 2023-06-13 15:26:54.615148 humanloop-0.4.9/humanloop/type/get_model_config_response.py
+-rw-r--r--   0        0        0     1148 2023-06-13 15:26:54.615296 humanloop-0.4.9/humanloop/type/http_validation_error.py
+-rw-r--r--   0        0        0      906 2023-06-13 15:26:54.615437 humanloop-0.4.9/humanloop/type/label_sentiment.py
+-rw-r--r--   0        0        0      958 2023-06-13 15:26:54.615617 humanloop-0.4.9/humanloop/type/log_datapoint_request.py
+-rw-r--r--   0        0        0     3209 2023-06-13 15:26:54.615791 humanloop-0.4.9/humanloop/type/log_model_config_request.py
+-rw-r--r--   0        0        0     3982 2023-06-13 15:26:54.615973 humanloop-0.4.9/humanloop/type/log_request.py
+-rw-r--r--   0        0        0     4244 2023-06-13 15:26:54.616147 humanloop-0.4.9/humanloop/type/log_response.py
+-rw-r--r--   0        0        0      983 2023-06-13 15:26:54.616303 humanloop-0.4.9/humanloop/type/logs_log_response.py
+-rw-r--r--   0        0        0     2996 2023-06-13 15:26:54.616622 humanloop-0.4.9/humanloop/type/model_config_chat_request.py
+-rw-r--r--   0        0        0     2889 2023-06-13 15:26:54.616834 humanloop-0.4.9/humanloop/type/model_config_completion_request.py
+-rw-r--r--   0        0        0      890 2023-06-13 15:26:54.616996 humanloop-0.4.9/humanloop/type/model_endpoints.py
+-rw-r--r--   0        0        0      940 2023-06-13 15:26:54.617152 humanloop-0.4.9/humanloop/type/model_providers.py
+-rw-r--r--   0        0        0     1208 2023-06-13 15:26:54.617290 humanloop-0.4.9/humanloop/type/paginated_data_log_response.py
+-rw-r--r--   0        0        0     1240 2023-06-13 15:26:54.617534 humanloop-0.4.9/humanloop/type/paginated_data_project_response.py
+-rw-r--r--   0        0        0     1240 2023-06-13 15:26:54.617676 humanloop-0.4.9/humanloop/type/paginated_data_session_response.py
+-rw-r--r--   0        0        0     1047 2023-06-13 15:26:54.617806 humanloop-0.4.9/humanloop/type/positive_label.py
+-rw-r--r--   0        0        0     1881 2023-06-13 15:26:54.617955 humanloop-0.4.9/humanloop/type/project_config_response.py
+-rw-r--r--   0        0        0     1247 2023-06-13 15:26:54.618127 humanloop-0.4.9/humanloop/type/project_model_config_feedback_stats_response.py
+-rw-r--r--   0        0        0     3665 2023-06-13 15:26:54.618285 humanloop-0.4.9/humanloop/type/project_model_config_request.py
+-rw-r--r--   0        0        0     2208 2023-06-13 15:26:54.618438 humanloop-0.4.9/humanloop/type/project_response.py
+-rw-r--r--   0        0        0      897 2023-06-13 15:26:54.618542 humanloop-0.4.9/humanloop/type/project_sort_by.py
+-rw-r--r--   0        0        0     1198 2023-06-13 15:26:54.618700 humanloop-0.4.9/humanloop/type/project_user_response.py
+-rw-r--r--   0        0        0      974 2023-06-13 15:26:54.618815 humanloop-0.4.9/humanloop/type/projects_get_configs_response.py
+-rw-r--r--   0        0        0      976 2023-06-13 15:26:54.618941 humanloop-0.4.9/humanloop/type/projects_update_feedback_types_request.py
+-rw-r--r--   0        0        0     1165 2023-06-13 15:26:54.619078 humanloop-0.4.9/humanloop/type/provider_api_keys.py
+-rw-r--r--   0        0        0     1161 2023-06-13 15:26:54.619257 humanloop-0.4.9/humanloop/type/session_project_response.py
+-rw-r--r--   0        0        0     1618 2023-06-13 15:26:54.619436 humanloop-0.4.9/humanloop/type/session_response.py
+-rw-r--r--   0        0        0      872 2023-06-13 15:26:54.619592 humanloop-0.4.9/humanloop/type/sort_order.py
+-rw-r--r--   0        0        0     3518 2023-06-13 15:26:54.619761 humanloop-0.4.9/humanloop/type/src_external_app_models_v4_configs_model_config_response.py
+-rw-r--r--   0        0        0     3526 2023-06-13 15:26:54.619893 humanloop-0.4.9/humanloop/type/src_external_app_models_v4_model_configs_model_config_response.py
+-rw-r--r--   0        0        0     1242 2023-06-13 15:26:54.619984 humanloop-0.4.9/humanloop/type/tool_config_request.py
+-rw-r--r--   0        0        0     1392 2023-06-13 15:26:54.620080 humanloop-0.4.9/humanloop/type/tool_config_response.py
+-rw-r--r--   0        0        0     1106 2023-06-13 15:26:54.620166 humanloop-0.4.9/humanloop/type/tool_result_response.py
+-rw-r--r--   0        0        0     2632 2023-06-13 15:26:54.620253 humanloop-0.4.9/humanloop/type/trace_log_request.py
+-rw-r--r--   0        0        0     3271 2023-06-13 15:26:54.620352 humanloop-0.4.9/humanloop/type/trace_model_config_request.py
+-rw-r--r--   0        0        0     1537 2023-06-13 15:26:54.620456 humanloop-0.4.9/humanloop/type/update_experiment_request.py
+-rw-r--r--   0        0        0     1259 2023-06-13 15:26:54.620558 humanloop-0.4.9/humanloop/type/update_log_request.py
+-rw-r--r--   0        0        0     1610 2023-06-13 15:26:54.620657 humanloop-0.4.9/humanloop/type/update_project_request.py
+-rw-r--r--   0        0        0     1218 2023-06-13 15:26:54.620744 humanloop-0.4.9/humanloop/type/usage.py
+-rw-r--r--   0        0        0     1127 2023-06-13 15:26:54.620838 humanloop-0.4.9/humanloop/type/validation_error.py
+-rw-r--r--   0        0        0     1044 2023-06-13 15:26:54.620935 humanloop-0.4.9/humanloop/type_util.py
+-rw-r--r--   0        0        0     3165 2023-06-13 15:26:54.621024 humanloop-0.4.9/humanloop/validation_metadata.py
+-rw-r--r--   0        0        0      714 2023-06-13 15:26:54.621581 humanloop-0.4.9/pyproject.toml
+-rw-r--r--   0        0        0     9366 1970-01-01 00:00:00.000000 humanloop-0.4.9/PKG-INFO
```

### Comparing `humanloop-0.4.8/LICENSE` & `humanloop-0.4.9/LICENSE`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/README.md` & `humanloop-0.4.9/README.md`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
-# humanloop@0.4.8
+# humanloop@0.4.9
 
 
 ## Requirements
 
 Python >=3.7
 
 ## Installing
 
 ```sh
-pip install humanloop==0.4.8
+pip install humanloop==0.4.9
 ```
 
 ## Getting Started
 
 ```python
 from pprint import pprint
 from humanloop import Humanloop, ApiException
```

### Comparing `humanloop-0.4.8/humanloop/__init__.py` & `humanloop-0.4.9/humanloop/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 
     The Humanloop API allows you to interact with Humanloop from your product or service.  You can do this through HTTP requests from any language or via our official Python or TypeScript SDK.  To install the official [Python SDK](https://pypi.org/project/humanloop/), run the following command:  ```bash pip install humanloop ```  To install the official [TypeScript SDK](https://www.npmjs.com/package/humanloop), run the following command:  ```bash npm i humanloop ```  ---  Guides and further details about key concepts can be found in [our docs](https://docs.humanloop.com/).
 
     The version of the OpenAPI document: 4.0.0
     Generated by: https://konfigthis.com
 """
 
-__version__ = "0.4.8"
+__version__ = "0.4.9"
 
 # import ApiClient
 from humanloop.api_client import ApiClient
 
 # import Configuration
 from humanloop.configuration import Configuration
```

### Comparing `humanloop-0.4.8/humanloop/api_client.py` & `humanloop-0.4.9/humanloop/api_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -2767,15 +2767,15 @@
 0000ace0: 6561 6465 725f 7661 6c75 650a 2020 2020  eader_value.    
 0000acf0: 2020 2020 7365 6c66 2e63 6f6f 6b69 6520      self.cookie 
 0000ad00: 3d20 636f 6f6b 6965 0a20 2020 2020 2020  = cookie.       
 0000ad10: 2023 2053 6574 2064 6566 6175 6c74 2055   # Set default U
 0000ad20: 7365 722d 4167 656e 742e 0a20 2020 2020  ser-Agent..     
 0000ad30: 2020 2073 656c 662e 7573 6572 5f61 6765     self.user_age
 0000ad40: 6e74 203d 2027 4b6f 6e66 6967 2f30 2e34  nt = 'Konfig/0.4
-0000ad50: 2e38 2f70 7974 686f 6e27 0a0a 2020 2020  .8/python'..    
+0000ad50: 2e39 2f70 7974 686f 6e27 0a0a 2020 2020  .9/python'..    
 0000ad60: 6465 6620 5f5f 656e 7465 725f 5f28 7365  def __enter__(se
 0000ad70: 6c66 293a 0a20 2020 2020 2020 2072 6574  lf):.        ret
 0000ad80: 7572 6e20 7365 6c66 0a0a 2020 2020 6465  urn self..    de
 0000ad90: 6620 5f5f 6578 6974 5f5f 2873 656c 662c  f __exit__(self,
 0000ada0: 2065 7863 5f74 7970 652c 2065 7863 5f76   exc_type, exc_v
 0000adb0: 616c 7565 2c20 7472 6163 6562 6163 6b29  alue, traceback)
 0000adc0: 3a0a 2020 2020 2020 2020 7365 6c66 2e63  :.        self.c
```

### Comparing `humanloop-0.4.8/humanloop/api_response.py` & `humanloop-0.4.9/humanloop/api_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/path_to_api.py` & `humanloop-0.4.9/humanloop/apis/path_to_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tag_to_api.py` & `humanloop-0.4.9/humanloop/apis/tag_to_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/__init__.py` & `humanloop-0.4.9/humanloop/apis/tags/__init__.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/chats_api.py` & `humanloop-0.4.9/humanloop/apis/tags/chats_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/completions_api.py` & `humanloop-0.4.9/humanloop/apis/tags/completions_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/experiments_api.py` & `humanloop-0.4.9/humanloop/apis/tags/experiments_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/feedback_api.py` & `humanloop-0.4.9/humanloop/apis/tags/feedback_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/logs_api.py` & `humanloop-0.4.9/humanloop/apis/tags/logs_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/model_configurations_api.py` & `humanloop-0.4.9/humanloop/apis/tags/model_configurations_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/projects_api.py` & `humanloop-0.4.9/humanloop/apis/tags/projects_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/sessions_api.py` & `humanloop-0.4.9/humanloop/apis/tags/sessions_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/apis/tags/traces_api.py` & `humanloop-0.4.9/humanloop/apis/tags/traces_api.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/client.py` & `humanloop-0.4.9/humanloop/client.py`

 * *Files 16% similar despite different names*

```diff
@@ -96,449 +96,609 @@
         self.projects: ProjectsApi = ProjectsApi(api_client)
         self.sessions: SessionsApi = SessionsApi(api_client)
         self.traces: TracesApi = TracesApi(api_client)
 
     @copy_signature(ChatsApi.aresponse)
     async def achat(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse(
-            project=project,
             messages=messages,
             model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response)
     def chat(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response(
-            project=project,
             messages=messages,
             model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.aresponse_deployed)
     async def achat_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse_deployed(
-            project=project,
             messages=messages,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response_deployed)
     def chat_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response_deployed(
-            project=project,
             messages=messages,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.aresponse_experiment)
     async def achat_experiment(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse_experiment(
-            project=project,
             messages=messages,
             experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response_experiment)
     def chat_experiment(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response_experiment(
-            project=project,
             messages=messages,
             experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.aresponse_model_configuration)
     async def achat_model_configuration(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse_model_configuration(
-            project=project,
             messages=messages,
             model_config_id=model_config_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response_model_configuration)
     def chat_model_configuration(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response_model_configuration(
-            project=project,
             messages=messages,
             model_config_id=model_config_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate)
     async def acomplete(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create)
     def complete(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate_deployed)
     async def acomplete_deployed(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate_deployed(
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create_deployed)
     def complete_deployed(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create_deployed(
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate_experiment)
     async def acomplete_experiment(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate_experiment(
+            experiment_id=experiment_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            experiment_id=experiment_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create_experiment)
     def complete_experiment(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create_experiment(
+            experiment_id=experiment_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            experiment_id=experiment_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate_model_configuration)
     async def acomplete_model_configuration(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate_model_configuration(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create_model_configuration)
     def complete_model_configuration(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create_model_configuration(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(FeedbackApi.asubmit)
     async def afeedback(
         self,
         body: typing.Optional[FeedbackSubmitRequest] = None,
         type: typing.Optional[typing.Union[FeedbackType, str]] = None,
@@ -580,87 +740,91 @@
         )
 
     @copy_signature(LogsApi.alog)
     async def alog(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ):
         return await self.logs_api.alog(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
 
     @copy_signature(LogsApi.log)
     def log(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ):
         return self.logs_api.log(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
```

### Comparing `humanloop-0.4.8/humanloop/client.pyi` & `humanloop-0.4.9/humanloop/client.pyi`

 * *Files 16% similar despite different names*

```diff
@@ -96,449 +96,609 @@
         self.projects: ProjectsApi = ProjectsApi(api_client)
         self.sessions: SessionsApi = SessionsApi(api_client)
         self.traces: TracesApi = TracesApi(api_client)
 
     @copy_signature(ChatsApi.aresponse)
     async def achat(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse(
-            project=project,
             messages=messages,
             model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response)
     def chat(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response(
-            project=project,
             messages=messages,
             model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.aresponse_deployed)
     async def achat_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse_deployed(
-            project=project,
             messages=messages,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response_deployed)
     def chat_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response_deployed(
-            project=project,
             messages=messages,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.aresponse_experiment)
     async def achat_experiment(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse_experiment(
-            project=project,
             messages=messages,
             experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response_experiment)
     def chat_experiment(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response_experiment(
-            project=project,
             messages=messages,
             experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.aresponse_model_configuration)
     async def achat_model_configuration(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.chats_api.aresponse_model_configuration(
-            project=project,
             messages=messages,
             model_config_id=model_config_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(ChatsApi.response_model_configuration)
     def chat_model_configuration(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.chats_api.response_model_configuration(
-            project=project,
             messages=messages,
             model_config_id=model_config_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate)
     async def acomplete(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create)
     def complete(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate_deployed)
     async def acomplete_deployed(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate_deployed(
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create_deployed)
     def complete_deployed(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create_deployed(
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate_experiment)
     async def acomplete_experiment(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate_experiment(
+            experiment_id=experiment_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            experiment_id=experiment_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create_experiment)
     def complete_experiment(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create_experiment(
+            experiment_id=experiment_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            experiment_id=experiment_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.acreate_model_configuration)
     async def acomplete_model_configuration(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return await self.completions_api.acreate_model_configuration(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(CompletionsApi.create_model_configuration)
     def complete_model_configuration(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ):
         return self.completions_api.create_model_configuration(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
 
     @copy_signature(FeedbackApi.asubmit)
     async def afeedback(
         self,
         body: typing.Optional[FeedbackSubmitRequest] = None,
         type: typing.Optional[typing.Union[FeedbackType, str]] = None,
@@ -580,87 +740,91 @@
         )
 
     @copy_signature(LogsApi.alog)
     async def alog(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ):
         return await self.logs_api.alog(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
 
     @copy_signature(LogsApi.log)
     def log(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ):
         return self.logs_api.log(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
```

### Comparing `humanloop-0.4.8/humanloop/client_custom.py` & `humanloop-0.4.9/humanloop/client_custom.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/configuration.py` & `humanloop-0.4.9/humanloop/configuration.py`

 * *Files 0% similar despite different names*

```diff
@@ -428,15 +428,15 @@
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
                "Version of the API: 4.0.0\n"\
-               "SDK Package Version: 0.4.8".\
+               "SDK Package Version: 0.4.9".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

### Comparing `humanloop-0.4.8/humanloop/exceptions.py` & `humanloop-0.4.9/humanloop/exceptions.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/exceptions_base.py` & `humanloop-0.4.9/humanloop/exceptions_base.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/agent_config_request.py` & `humanloop-0.4.9/humanloop/model/agent_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/agent_config_request.pyi` & `humanloop-0.4.9/humanloop/model/agent_config_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/agent_config_response.py` & `humanloop-0.4.9/humanloop/model/agent_config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/agent_config_response.pyi` & `humanloop-0.4.9/humanloop/model/agent_config_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/base_metric_response.py` & `humanloop-0.4.9/humanloop/model/base_metric_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/base_metric_response.pyi` & `humanloop-0.4.9/humanloop/model/base_metric_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/categorical_feedback_label.py` & `humanloop-0.4.9/humanloop/model/categorical_feedback_label.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/categorical_feedback_label.pyi` & `humanloop-0.4.9/humanloop/model/categorical_feedback_label.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/chat_data_response.py` & `humanloop-0.4.9/humanloop/model/chat_data_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/chat_data_response.pyi` & `humanloop-0.4.9/humanloop/model/chat_data_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/chat_deployed_request.py` & `humanloop-0.4.9/humanloop/model/completion_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -19,63 +19,87 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatDeployedRequest(
+class CompletionResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    Chat request for active deployment.
     """
 
 
     class MetaOapg:
         required = {
-            "messages",
-            "project",
+            "data",
+            "project_id",
+            "provider_responses",
         }
         
         class properties:
-            project = schemas.StrSchema
+            project_id = schemas.StrSchema
             
             
-            class messages(
+            class data(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['DataResponse']:
+                        return DataResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['DataResponse'], typing.List['DataResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'data':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'DataResponse':
                     return super().__getitem__(i)
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class provider_responses(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'provider_responses':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            num_samples = schemas.IntSchema
+            logprobs = schemas.IntSchema
+            suffix = schemas.StrSchema
+            user = schemas.StrSchema
+            
+            
+            class usage(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -85,135 +109,142 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            Usage,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'usage':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
             metadata = schemas.DictSchema
             __annotations__ = {
-                "project": project,
-                "messages": messages,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
+                "project_id": project_id,
+                "data": data,
+                "provider_responses": provider_responses,
                 "num_samples": num_samples,
-                "stream": stream,
+                "logprobs": logprobs,
+                "suffix": suffix,
                 "user": user,
+                "usage": usage,
                 "metadata": metadata,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    data: MetaOapg.properties.data
+    project_id: MetaOapg.properties.project_id
+    provider_responses: MetaOapg.properties.provider_responses
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
+        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
+        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatDeployedRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'CompletionResponse':
         return super().__new__(
             cls,
             *args,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
+            data=data,
+            project_id=project_id,
+            provider_responses=provider_responses,
             num_samples=num_samples,
-            stream=stream,
+            logprobs=logprobs,
+            suffix=suffix,
             user=user,
+            usage=usage,
             metadata=metadata,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.data_response import DataResponse
+from humanloop.model.usage import Usage
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_deployed_request.pyi` & `humanloop-0.4.9/humanloop/model/completion_response.pyi`

 * *Files 17% similar despite different names*

```diff
@@ -19,63 +19,87 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatDeployedRequest(
+class CompletionResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    Chat request for active deployment.
     """
 
 
     class MetaOapg:
         required = {
-            "messages",
-            "project",
+            "data",
+            "project_id",
+            "provider_responses",
         }
         
         class properties:
-            project = schemas.StrSchema
+            project_id = schemas.StrSchema
             
             
-            class messages(
+            class data(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['DataResponse']:
+                        return DataResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['DataResponse'], typing.List['DataResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'data':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'DataResponse':
                     return super().__getitem__(i)
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class provider_responses(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'provider_responses':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            num_samples = schemas.IntSchema
+            logprobs = schemas.IntSchema
+            suffix = schemas.StrSchema
+            user = schemas.StrSchema
+            
+            
+            class usage(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -85,135 +109,142 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            Usage,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'usage':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
             metadata = schemas.DictSchema
             __annotations__ = {
-                "project": project,
-                "messages": messages,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
+                "project_id": project_id,
+                "data": data,
+                "provider_responses": provider_responses,
                 "num_samples": num_samples,
-                "stream": stream,
+                "logprobs": logprobs,
+                "suffix": suffix,
                 "user": user,
+                "usage": usage,
                 "metadata": metadata,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    data: MetaOapg.properties.data
+    project_id: MetaOapg.properties.project_id
+    provider_responses: MetaOapg.properties.provider_responses
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
+        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
+        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatDeployedRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'CompletionResponse':
         return super().__new__(
             cls,
             *args,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
+            data=data,
+            project_id=project_id,
+            provider_responses=provider_responses,
             num_samples=num_samples,
-            stream=stream,
+            logprobs=logprobs,
+            suffix=suffix,
             user=user,
+            usage=usage,
             metadata=metadata,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.data_response import DataResponse
+from humanloop.model.usage import Usage
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_experiment_request.py` & `humanloop-0.4.9/humanloop/model/get_model_config_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -19,213 +19,199 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatExperimentRequest(
+class GetModelConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Base chat request.
+    A selected model configuration.
+
+If the model configuration was selected in the context of an experiment,
+the response will include a trial_id to associate a subsequent log() call.
     """
 
 
     class MetaOapg:
         required = {
-            "experiment_id",
-            "messages",
-            "project",
+            "updated_at",
+            "project_id",
+            "last_used",
+            "created_at",
+            "project_name",
+            "config",
         }
         
         class properties:
-            project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            project_name = schemas.StrSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            last_used = schemas.DateTimeSchema
+        
+            @staticmethod
+            def config() -> typing.Type['ConfigResponse']:
+                return ConfigResponse
             
             
-            class messages(
+            class feedback_stats(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['ProjectModelConfigFeedbackStatsResponse']:
+                        return ProjectModelConfigFeedbackStatsResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['ProjectModelConfigFeedbackStatsResponse'], typing.List['ProjectModelConfigFeedbackStatsResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'feedback_stats':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'ProjectModelConfigFeedbackStatsResponse':
                     return super().__getitem__(i)
+            num_datapoints = schemas.IntSchema
             experiment_id = schemas.StrSchema
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
-            
-            
-            class provider_api_keys(
-                schemas.ComposedSchema,
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            ProviderApiKeys,
-                        ]
-            
-            
-                def __new__(
-                    cls,
-                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
-                    return super().__new__(
-                        cls,
-                        *args,
-                        _configuration=_configuration,
-                        **kwargs,
-                    )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
-            metadata = schemas.DictSchema
+            trial_id = schemas.StrSchema
             __annotations__ = {
-                "project": project,
-                "messages": messages,
+                "project_id": project_id,
+                "project_name": project_name,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "last_used": last_used,
+                "config": config,
+                "feedback_stats": feedback_stats,
+                "num_datapoints": num_datapoints,
                 "experiment_id": experiment_id,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
-                "num_samples": num_samples,
-                "stream": stream,
-                "user": user,
-                "metadata": metadata,
+                "trial_id": trial_id,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    experiment_id: MetaOapg.properties.experiment_id
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    updated_at: MetaOapg.properties.updated_at
+    project_id: MetaOapg.properties.project_id
+    last_used: MetaOapg.properties.last_used
+    created_at: MetaOapg.properties.created_at
+    project_name: MetaOapg.properties.project_name
+    config: 'ConfigResponse'
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        project_name: typing.Union[MetaOapg.properties.project_name, str, ],
+        config: 'ConfigResponse',
+        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
+        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatExperimentRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'GetModelConfigResponse':
         return super().__new__(
             cls,
             *args,
+            updated_at=updated_at,
+            project_id=project_id,
+            last_used=last_used,
+            created_at=created_at,
+            project_name=project_name,
+            config=config,
+            feedback_stats=feedback_stats,
+            num_datapoints=num_datapoints,
             experiment_id=experiment_id,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            trial_id=trial_id,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.config_response import ConfigResponse
+from humanloop.model.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_experiment_request.pyi` & `humanloop-0.4.9/humanloop/model/get_model_config_response.pyi`

 * *Files 18% similar despite different names*

```diff
@@ -19,213 +19,199 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatExperimentRequest(
+class GetModelConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Base chat request.
+    A selected model configuration.
+
+If the model configuration was selected in the context of an experiment,
+the response will include a trial_id to associate a subsequent log() call.
     """
 
 
     class MetaOapg:
         required = {
-            "experiment_id",
-            "messages",
-            "project",
+            "updated_at",
+            "project_id",
+            "last_used",
+            "created_at",
+            "project_name",
+            "config",
         }
         
         class properties:
-            project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            project_name = schemas.StrSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            last_used = schemas.DateTimeSchema
+        
+            @staticmethod
+            def config() -> typing.Type['ConfigResponse']:
+                return ConfigResponse
             
             
-            class messages(
+            class feedback_stats(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['ProjectModelConfigFeedbackStatsResponse']:
+                        return ProjectModelConfigFeedbackStatsResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['ProjectModelConfigFeedbackStatsResponse'], typing.List['ProjectModelConfigFeedbackStatsResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'feedback_stats':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'ProjectModelConfigFeedbackStatsResponse':
                     return super().__getitem__(i)
+            num_datapoints = schemas.IntSchema
             experiment_id = schemas.StrSchema
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
-            
-            
-            class provider_api_keys(
-                schemas.ComposedSchema,
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            ProviderApiKeys,
-                        ]
-            
-            
-                def __new__(
-                    cls,
-                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
-                    return super().__new__(
-                        cls,
-                        *args,
-                        _configuration=_configuration,
-                        **kwargs,
-                    )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
-            metadata = schemas.DictSchema
+            trial_id = schemas.StrSchema
             __annotations__ = {
-                "project": project,
-                "messages": messages,
+                "project_id": project_id,
+                "project_name": project_name,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "last_used": last_used,
+                "config": config,
+                "feedback_stats": feedback_stats,
+                "num_datapoints": num_datapoints,
                 "experiment_id": experiment_id,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
-                "num_samples": num_samples,
-                "stream": stream,
-                "user": user,
-                "metadata": metadata,
+                "trial_id": trial_id,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    experiment_id: MetaOapg.properties.experiment_id
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    updated_at: MetaOapg.properties.updated_at
+    project_id: MetaOapg.properties.project_id
+    last_used: MetaOapg.properties.last_used
+    created_at: MetaOapg.properties.created_at
+    project_name: MetaOapg.properties.project_name
+    config: 'ConfigResponse'
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        project_name: typing.Union[MetaOapg.properties.project_name, str, ],
+        config: 'ConfigResponse',
+        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
+        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatExperimentRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'GetModelConfigResponse':
         return super().__new__(
             cls,
             *args,
+            updated_at=updated_at,
+            project_id=project_id,
+            last_used=last_used,
+            created_at=created_at,
+            project_name=project_name,
+            config=config,
+            feedback_stats=feedback_stats,
+            num_datapoints=num_datapoints,
             experiment_id=experiment_id,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            trial_id=trial_id,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.config_response import ConfigResponse
+from humanloop.model.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_message.py` & `humanloop-0.4.9/humanloop/model/chat_message.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/chat_message.pyi` & `humanloop-0.4.9/humanloop/model/chat_message.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/chat_model_config_request.py` & `humanloop-0.4.9/humanloop/model/chat_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -19,65 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatModelConfigRequest(
+class ChatResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Base chat request.
+    Overwrite GenerateResponse for chat.
     """
 
 
     class MetaOapg:
         required = {
-            "model_config_id",
-            "messages",
-            "project",
+            "data",
+            "project_id",
+            "provider_responses",
         }
         
         class properties:
-            project = schemas.StrSchema
+            project_id = schemas.StrSchema
             
             
-            class messages(
+            class data(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['ChatDataResponse']:
+                        return ChatDataResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['ChatDataResponse'], typing.List['ChatDataResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'data':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'ChatDataResponse':
                     return super().__getitem__(i)
-            model_config_id = schemas.StrSchema
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class provider_responses(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'provider_responses':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            num_samples = schemas.IntSchema
+            logprobs = schemas.IntSchema
+            suffix = schemas.StrSchema
+            user = schemas.StrSchema
+            
+            
+            class usage(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -87,145 +111,142 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            Usage,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'usage':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
             metadata = schemas.DictSchema
             __annotations__ = {
-                "project": project,
-                "messages": messages,
-                "model_config_id": model_config_id,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
+                "project_id": project_id,
+                "data": data,
+                "provider_responses": provider_responses,
                 "num_samples": num_samples,
-                "stream": stream,
+                "logprobs": logprobs,
+                "suffix": suffix,
                 "user": user,
+                "usage": usage,
                 "metadata": metadata,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    model_config_id: MetaOapg.properties.model_config_id
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    data: MetaOapg.properties.data
+    project_id: MetaOapg.properties.project_id
+    provider_responses: MetaOapg.properties.provider_responses
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        model_config_id: typing.Union[MetaOapg.properties.model_config_id, str, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
+        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
+        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatModelConfigRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ChatResponse':
         return super().__new__(
             cls,
             *args,
-            model_config_id=model_config_id,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
+            data=data,
+            project_id=project_id,
+            provider_responses=provider_responses,
             num_samples=num_samples,
-            stream=stream,
+            logprobs=logprobs,
+            suffix=suffix,
             user=user,
+            usage=usage,
             metadata=metadata,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.chat_data_response import ChatDataResponse
+from humanloop.model.usage import Usage
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_model_config_request.pyi` & `humanloop-0.4.9/humanloop/model/chat_response.pyi`

 * *Files 11% similar despite different names*

```diff
@@ -19,65 +19,89 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatModelConfigRequest(
+class ChatResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Base chat request.
+    Overwrite GenerateResponse for chat.
     """
 
 
     class MetaOapg:
         required = {
-            "model_config_id",
-            "messages",
-            "project",
+            "data",
+            "project_id",
+            "provider_responses",
         }
         
         class properties:
-            project = schemas.StrSchema
+            project_id = schemas.StrSchema
             
             
-            class messages(
+            class data(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['ChatDataResponse']:
+                        return ChatDataResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['ChatDataResponse'], typing.List['ChatDataResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'data':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'ChatDataResponse':
                     return super().__getitem__(i)
-            model_config_id = schemas.StrSchema
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class provider_responses(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.AnyTypeSchema
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'provider_responses':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            num_samples = schemas.IntSchema
+            logprobs = schemas.IntSchema
+            suffix = schemas.StrSchema
+            user = schemas.StrSchema
+            
+            
+            class usage(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -87,145 +111,142 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            Usage,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'usage':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
             metadata = schemas.DictSchema
             __annotations__ = {
-                "project": project,
-                "messages": messages,
-                "model_config_id": model_config_id,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
+                "project_id": project_id,
+                "data": data,
+                "provider_responses": provider_responses,
                 "num_samples": num_samples,
-                "stream": stream,
+                "logprobs": logprobs,
+                "suffix": suffix,
                 "user": user,
+                "usage": usage,
                 "metadata": metadata,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    model_config_id: MetaOapg.properties.model_config_id
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    data: MetaOapg.properties.data
+    project_id: MetaOapg.properties.project_id
+    provider_responses: MetaOapg.properties.provider_responses
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        model_config_id: typing.Union[MetaOapg.properties.model_config_id, str, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
+        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
+        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatModelConfigRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ChatResponse':
         return super().__new__(
             cls,
             *args,
-            model_config_id=model_config_id,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
+            data=data,
+            project_id=project_id,
+            provider_responses=provider_responses,
             num_samples=num_samples,
-            stream=stream,
+            logprobs=logprobs,
+            suffix=suffix,
             user=user,
+            usage=usage,
             metadata=metadata,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.chat_data_response import ChatDataResponse
+from humanloop.model.usage import Usage
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_request.py` & `humanloop-0.4.9/humanloop/model/project_response.py`

 * *Files 16% similar despite different names*

```diff
@@ -19,62 +19,76 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatRequest(
+class ProjectResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    Base chat request.
     """
 
 
     class MetaOapg:
         required = {
-            "model_config",
-            "messages",
-            "project",
+            "feedback_types",
+            "internal_id",
+            "updated_at",
+            "name",
+            "created_at",
+            "id",
+            "team_id",
+            "data_count",
+            "users",
         }
         
         class properties:
-            project = schemas.StrSchema
+            id = schemas.StrSchema
+            internal_id = schemas.IntSchema
+            name = schemas.StrSchema
             
             
-            class messages(
+            class users(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['ProjectUserResponse']:
+                        return ProjectUserResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['ProjectUserResponse'], typing.List['ProjectUserResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'users':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'ProjectUserResponse':
                     return super().__getitem__(i)
+            data_count = schemas.IntSchema
+        
+            @staticmethod
+            def feedback_types() -> typing.Type['FeedbackTypes']:
+                return FeedbackTypes
+            team_id = schemas.StrSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
             
             
-            class model_config(
+            class active_experiment(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -84,35 +98,33 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelConfigChatRequest,
+                            ExperimentResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'model_config':
+                ) -> 'active_experiment':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class active_config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -122,146 +134,181 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            ProjectConfigResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'active_config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
-            metadata = schemas.DictSchema
+        
+            @staticmethod
+            def config_type() -> typing.Type['ConfigType']:
+                return ConfigType
             __annotations__ = {
-                "project": project,
-                "messages": messages,
-                "model_config": model_config,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
-                "num_samples": num_samples,
-                "stream": stream,
-                "user": user,
-                "metadata": metadata,
+                "id": id,
+                "internal_id": internal_id,
+                "name": name,
+                "users": users,
+                "data_count": data_count,
+                "feedback_types": feedback_types,
+                "team_id": team_id,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "active_experiment": active_experiment,
+                "active_config": active_config,
+                "config_type": config_type,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    model_config: MetaOapg.properties.model_config
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    feedback_types: 'FeedbackTypes'
+    internal_id: MetaOapg.properties.internal_id
+    updated_at: MetaOapg.properties.updated_at
+    name: MetaOapg.properties.name
+    created_at: MetaOapg.properties.created_at
+    id: MetaOapg.properties.id
+    team_id: MetaOapg.properties.team_id
+    data_count: MetaOapg.properties.data_count
+    users: MetaOapg.properties.users
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["internal_id"]) -> MetaOapg.properties.internal_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def __getitem__(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["data_count"]) -> MetaOapg.properties.data_count: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["feedback_types"]) -> 'FeedbackTypes': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["team_id"]) -> MetaOapg.properties.team_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["active_experiment"]) -> MetaOapg.properties.active_experiment: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["active_config"]) -> MetaOapg.properties.active_config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["config_type"]) -> 'ConfigType': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "internal_id", "name", "users", "data_count", "feedback_types", "team_id", "created_at", "updated_at", "active_experiment", "active_config", "config_type", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["internal_id"]) -> MetaOapg.properties.internal_id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data_count"]) -> MetaOapg.properties.data_count: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["feedback_types"]) -> 'FeedbackTypes': ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["team_id"]) -> MetaOapg.properties.team_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active_experiment"]) -> typing.Union[MetaOapg.properties.active_experiment, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active_config"]) -> typing.Union[MetaOapg.properties.active_config, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config_type"]) -> typing.Union['ConfigType', schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "internal_id", "name", "users", "data_count", "feedback_types", "team_id", "created_at", "updated_at", "active_experiment", "active_config", "config_type", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        feedback_types: 'FeedbackTypes',
+        internal_id: typing.Union[MetaOapg.properties.internal_id, decimal.Decimal, int, ],
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        team_id: typing.Union[MetaOapg.properties.team_id, str, ],
+        data_count: typing.Union[MetaOapg.properties.data_count, decimal.Decimal, int, ],
+        users: typing.Union[MetaOapg.properties.users, list, tuple, ],
+        active_experiment: typing.Union[MetaOapg.properties.active_experiment, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        active_config: typing.Union[MetaOapg.properties.active_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        config_type: typing.Union['ConfigType', schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ProjectResponse':
         return super().__new__(
             cls,
             *args,
-            model_config=model_config,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            feedback_types=feedback_types,
+            internal_id=internal_id,
+            updated_at=updated_at,
+            name=name,
+            created_at=created_at,
+            id=id,
+            team_id=team_id,
+            data_count=data_count,
+            users=users,
+            active_experiment=active_experiment,
+            active_config=active_config,
+            config_type=config_type,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.model_config_chat_request import ModelConfigChatRequest
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.config_type import ConfigType
+from humanloop.model.experiment_response import ExperimentResponse
+from humanloop.model.feedback_types import FeedbackTypes
+from humanloop.model.project_config_response import ProjectConfigResponse
+from humanloop.model.project_user_response import ProjectUserResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_request.pyi` & `humanloop-0.4.9/humanloop/model/project_response.pyi`

 * *Files 16% similar despite different names*

```diff
@@ -19,62 +19,76 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatRequest(
+class ProjectResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    Base chat request.
     """
 
 
     class MetaOapg:
         required = {
-            "model_config",
-            "messages",
-            "project",
+            "feedback_types",
+            "internal_id",
+            "updated_at",
+            "name",
+            "created_at",
+            "id",
+            "team_id",
+            "data_count",
+            "users",
         }
         
         class properties:
-            project = schemas.StrSchema
+            id = schemas.StrSchema
+            internal_id = schemas.IntSchema
+            name = schemas.StrSchema
             
             
-            class messages(
+            class users(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
+                    def items() -> typing.Type['ProjectUserResponse']:
+                        return ProjectUserResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    arg: typing.Union[typing.Tuple['ProjectUserResponse'], typing.List['ProjectUserResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'messages':
+                ) -> 'users':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'ChatMessage':
+                def __getitem__(self, i: int) -> 'ProjectUserResponse':
                     return super().__getitem__(i)
+            data_count = schemas.IntSchema
+        
+            @staticmethod
+            def feedback_types() -> typing.Type['FeedbackTypes']:
+                return FeedbackTypes
+            team_id = schemas.StrSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
             
             
-            class model_config(
+            class active_experiment(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -84,35 +98,33 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelConfigChatRequest,
+                            ExperimentResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'model_config':
+                ) -> 'active_experiment':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            inputs = schemas.DictSchema
-            source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class active_config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -122,146 +134,181 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            ProjectConfigResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'active_config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            stream = schemas.BoolSchema
-            user = schemas.StrSchema
-            metadata = schemas.DictSchema
+        
+            @staticmethod
+            def config_type() -> typing.Type['ConfigType']:
+                return ConfigType
             __annotations__ = {
-                "project": project,
-                "messages": messages,
-                "model_config": model_config,
-                "inputs": inputs,
-                "source": source,
-                "provider_api_keys": provider_api_keys,
-                "num_samples": num_samples,
-                "stream": stream,
-                "user": user,
-                "metadata": metadata,
+                "id": id,
+                "internal_id": internal_id,
+                "name": name,
+                "users": users,
+                "data_count": data_count,
+                "feedback_types": feedback_types,
+                "team_id": team_id,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "active_experiment": active_experiment,
+                "active_config": active_config,
+                "config_type": config_type,
             }
-        additional_properties = schemas.NotAnyTypeSchema
     
-    model_config: MetaOapg.properties.model_config
-    messages: MetaOapg.properties.messages
-    project: MetaOapg.properties.project
+    feedback_types: 'FeedbackTypes'
+    internal_id: MetaOapg.properties.internal_id
+    updated_at: MetaOapg.properties.updated_at
+    name: MetaOapg.properties.name
+    created_at: MetaOapg.properties.created_at
+    id: MetaOapg.properties.id
+    team_id: MetaOapg.properties.team_id
+    data_count: MetaOapg.properties.data_count
+    users: MetaOapg.properties.users
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["internal_id"]) -> MetaOapg.properties.internal_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def __getitem__(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["data_count"]) -> MetaOapg.properties.data_count: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["feedback_types"]) -> 'FeedbackTypes': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["team_id"]) -> MetaOapg.properties.team_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["active_experiment"]) -> MetaOapg.properties.active_experiment: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["active_config"]) -> MetaOapg.properties.active_config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["config_type"]) -> 'ConfigType': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "internal_id", "name", "users", "data_count", "feedback_types", "team_id", "created_at", "updated_at", "active_experiment", "active_config", "config_type", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["internal_id"]) -> MetaOapg.properties.internal_id: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["users"]) -> MetaOapg.properties.users: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["data_count"]) -> MetaOapg.properties.data_count: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["feedback_types"]) -> 'FeedbackTypes': ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["team_id"]) -> MetaOapg.properties.team_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active_experiment"]) -> typing.Union[MetaOapg.properties.active_experiment, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active_config"]) -> typing.Union[MetaOapg.properties.active_config, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config_type"]) -> typing.Union['ConfigType', schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "internal_id", "name", "users", "data_count", "feedback_types", "team_id", "created_at", "updated_at", "active_experiment", "active_config", "config_type", ], str]):
         return super().get_item_oapg(name)
+    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        feedback_types: 'FeedbackTypes',
+        internal_id: typing.Union[MetaOapg.properties.internal_id, decimal.Decimal, int, ],
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        team_id: typing.Union[MetaOapg.properties.team_id, str, ],
+        data_count: typing.Union[MetaOapg.properties.data_count, decimal.Decimal, int, ],
+        users: typing.Union[MetaOapg.properties.users, list, tuple, ],
+        active_experiment: typing.Union[MetaOapg.properties.active_experiment, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        active_config: typing.Union[MetaOapg.properties.active_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        config_type: typing.Union['ConfigType', schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'ChatRequest':
+        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+    ) -> 'ProjectResponse':
         return super().__new__(
             cls,
             *args,
-            model_config=model_config,
-            messages=messages,
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            feedback_types=feedback_types,
+            internal_id=internal_id,
+            updated_at=updated_at,
+            name=name,
+            created_at=created_at,
+            id=id,
+            team_id=team_id,
+            data_count=data_count,
+            users=users,
+            active_experiment=active_experiment,
+            active_config=active_config,
+            config_type=config_type,
             _configuration=_configuration,
+            **kwargs,
         )
 
-from humanloop.model.chat_message import ChatMessage
-from humanloop.model.model_config_chat_request import ModelConfigChatRequest
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.config_type import ConfigType
+from humanloop.model.experiment_response import ExperimentResponse
+from humanloop.model.feedback_types import FeedbackTypes
+from humanloop.model.project_config_response import ProjectConfigResponse
+from humanloop.model.project_user_response import ProjectUserResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_response.py` & `humanloop-0.4.9/humanloop/model/experiment_config_response.py`

 * *Files 18% similar despite different names*

```diff
@@ -19,89 +19,41 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatResponse(
+class ExperimentConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    Overwrite GenerateResponse for chat.
     """
 
 
     class MetaOapg:
         required = {
-            "data",
-            "project_id",
-            "provider_responses",
+            "updated_at",
+            "active",
+            "created_at",
+            "id",
+            "display_name",
+            "config",
+            "trials_count",
         }
         
         class properties:
-            project_id = schemas.StrSchema
-            
-            
-            class data(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['ChatDataResponse']:
-                        return ChatDataResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['ChatDataResponse'], typing.List['ChatDataResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'data':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'ChatDataResponse':
-                    return super().__getitem__(i)
-            
-            
-            class provider_responses(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'provider_responses':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
-            suffix = schemas.StrSchema
-            user = schemas.StrSchema
+            trials_count = schemas.IntSchema
+            active = schemas.BoolSchema
+            id = schemas.StrSchema
+            display_name = schemas.StrSchema
             
             
-            class usage(
+            class config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -111,142 +63,148 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            Usage,
+                            ConfigResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'usage':
+                ) -> 'config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            metadata = schemas.DictSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            mean = schemas.NumberSchema
+            spread = schemas.NumberSchema
             __annotations__ = {
-                "project_id": project_id,
-                "data": data,
-                "provider_responses": provider_responses,
-                "num_samples": num_samples,
-                "logprobs": logprobs,
-                "suffix": suffix,
-                "user": user,
-                "usage": usage,
-                "metadata": metadata,
+                "trials_count": trials_count,
+                "active": active,
+                "id": id,
+                "display_name": display_name,
+                "config": config,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "mean": mean,
+                "spread": spread,
             }
     
-    data: MetaOapg.properties.data
-    project_id: MetaOapg.properties.project_id
-    provider_responses: MetaOapg.properties.provider_responses
+    updated_at: MetaOapg.properties.updated_at
+    active: MetaOapg.properties.active
+    created_at: MetaOapg.properties.created_at
+    id: MetaOapg.properties.id
+    display_name: MetaOapg.properties.display_name
+    config: MetaOapg.properties.config
+    trials_count: MetaOapg.properties.trials_count
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def __getitem__(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
+    def __getitem__(self, name: typing_extensions.Literal["mean"]) -> MetaOapg.properties.mean: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["spread"]) -> MetaOapg.properties.spread: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["mean"]) -> typing.Union[MetaOapg.properties.mean, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["spread"]) -> typing.Union[MetaOapg.properties.spread, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
-        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
-        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        active: typing.Union[MetaOapg.properties.active, bool, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        display_name: typing.Union[MetaOapg.properties.display_name, str, ],
+        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        trials_count: typing.Union[MetaOapg.properties.trials_count, decimal.Decimal, int, ],
+        mean: typing.Union[MetaOapg.properties.mean, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        spread: typing.Union[MetaOapg.properties.spread, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ChatResponse':
+    ) -> 'ExperimentConfigResponse':
         return super().__new__(
             cls,
             *args,
-            data=data,
-            project_id=project_id,
-            provider_responses=provider_responses,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            suffix=suffix,
-            user=user,
-            usage=usage,
-            metadata=metadata,
+            updated_at=updated_at,
+            active=active,
+            created_at=created_at,
+            id=id,
+            display_name=display_name,
+            config=config,
+            trials_count=trials_count,
+            mean=mean,
+            spread=spread,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.chat_data_response import ChatDataResponse
-from humanloop.model.usage import Usage
+from humanloop.model.config_response import ConfigResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_response.pyi` & `humanloop-0.4.9/humanloop/model/experiment_config_response.pyi`

 * *Files 18% similar despite different names*

```diff
@@ -19,89 +19,41 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ChatResponse(
+class ExperimentConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    Overwrite GenerateResponse for chat.
     """
 
 
     class MetaOapg:
         required = {
-            "data",
-            "project_id",
-            "provider_responses",
+            "updated_at",
+            "active",
+            "created_at",
+            "id",
+            "display_name",
+            "config",
+            "trials_count",
         }
         
         class properties:
-            project_id = schemas.StrSchema
-            
-            
-            class data(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['ChatDataResponse']:
-                        return ChatDataResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['ChatDataResponse'], typing.List['ChatDataResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'data':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'ChatDataResponse':
-                    return super().__getitem__(i)
-            
-            
-            class provider_responses(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'provider_responses':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
-            suffix = schemas.StrSchema
-            user = schemas.StrSchema
+            trials_count = schemas.IntSchema
+            active = schemas.BoolSchema
+            id = schemas.StrSchema
+            display_name = schemas.StrSchema
             
             
-            class usage(
+            class config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -111,142 +63,148 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            Usage,
+                            ConfigResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'usage':
+                ) -> 'config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            metadata = schemas.DictSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            mean = schemas.NumberSchema
+            spread = schemas.NumberSchema
             __annotations__ = {
-                "project_id": project_id,
-                "data": data,
-                "provider_responses": provider_responses,
-                "num_samples": num_samples,
-                "logprobs": logprobs,
-                "suffix": suffix,
-                "user": user,
-                "usage": usage,
-                "metadata": metadata,
+                "trials_count": trials_count,
+                "active": active,
+                "id": id,
+                "display_name": display_name,
+                "config": config,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "mean": mean,
+                "spread": spread,
             }
     
-    data: MetaOapg.properties.data
-    project_id: MetaOapg.properties.project_id
-    provider_responses: MetaOapg.properties.provider_responses
+    updated_at: MetaOapg.properties.updated_at
+    active: MetaOapg.properties.active
+    created_at: MetaOapg.properties.created_at
+    id: MetaOapg.properties.id
+    display_name: MetaOapg.properties.display_name
+    config: MetaOapg.properties.config
+    trials_count: MetaOapg.properties.trials_count
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def __getitem__(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
+    def __getitem__(self, name: typing_extensions.Literal["mean"]) -> MetaOapg.properties.mean: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["spread"]) -> MetaOapg.properties.spread: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["mean"]) -> typing.Union[MetaOapg.properties.mean, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["spread"]) -> typing.Union[MetaOapg.properties.spread, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
-        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
-        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        active: typing.Union[MetaOapg.properties.active, bool, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        display_name: typing.Union[MetaOapg.properties.display_name, str, ],
+        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        trials_count: typing.Union[MetaOapg.properties.trials_count, decimal.Decimal, int, ],
+        mean: typing.Union[MetaOapg.properties.mean, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        spread: typing.Union[MetaOapg.properties.spread, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ChatResponse':
+    ) -> 'ExperimentConfigResponse':
         return super().__new__(
             cls,
             *args,
-            data=data,
-            project_id=project_id,
-            provider_responses=provider_responses,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            suffix=suffix,
-            user=user,
-            usage=usage,
-            metadata=metadata,
+            updated_at=updated_at,
+            active=active,
+            created_at=created_at,
+            id=id,
+            display_name=display_name,
+            config=config,
+            trials_count=trials_count,
+            mean=mean,
+            spread=spread,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.chat_data_response import ChatDataResponse
-from humanloop.model.usage import Usage
+from humanloop.model.config_response import ConfigResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/chat_role.py` & `humanloop-0.4.9/humanloop/model/chat_role.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/chat_role.pyi` & `humanloop-0.4.9/humanloop/model/chat_role.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/completion_deployed_request.py` & `humanloop-0.4.9/humanloop/model/chat_deployed_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -19,34 +19,65 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionDeployedRequest(
+class ChatDeployedRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request using the project's active deployment.
+    Chat request for active deployment.
     """
 
 
     class MetaOapg:
         required = {
-            "inputs",
-            "project",
+            "messages",
         }
         
         class properties:
+            
+            
+            class messages(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'messages':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
             project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
             inputs = schemas.DictSchema
             source = schemas.StrSchema
+            metadata = schemas.DictSchema
             
             
             class provider_api_keys(
                 schemas.ComposedSchema,
             ):
             
             
@@ -76,128 +107,161 @@
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
             stream = schemas.BoolSchema
-            suffix = schemas.StrSchema
             user = schemas.StrSchema
-            metadata = schemas.DictSchema
             __annotations__ = {
+                "messages": messages,
                 "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
                 "inputs": inputs,
                 "source": source,
+                "metadata": metadata,
                 "provider_api_keys": provider_api_keys,
                 "num_samples": num_samples,
-                "logprobs": logprobs,
                 "stream": stream,
-                "suffix": suffix,
                 "user": user,
-                "metadata": metadata,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    inputs: MetaOapg.properties.inputs
-    project: MetaOapg.properties.project
+    messages: MetaOapg.properties.messages
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionDeployedRequest':
+    ) -> 'ChatDeployedRequest':
         return super().__new__(
             cls,
             *args,
-            inputs=inputs,
+            messages=messages,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
-            logprobs=logprobs,
             stream=stream,
-            suffix=suffix,
             user=user,
-            metadata=metadata,
             _configuration=_configuration,
         )
 
+from humanloop.model.chat_message import ChatMessage
 from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_deployed_request.pyi` & `humanloop-0.4.9/humanloop/model/chat_deployed_request.pyi`

 * *Files 20% similar despite different names*

```diff
@@ -19,34 +19,65 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionDeployedRequest(
+class ChatDeployedRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request using the project's active deployment.
+    Chat request for active deployment.
     """
 
 
     class MetaOapg:
         required = {
-            "inputs",
-            "project",
+            "messages",
         }
         
         class properties:
+            
+            
+            class messages(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'messages':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
             project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
             inputs = schemas.DictSchema
             source = schemas.StrSchema
+            metadata = schemas.DictSchema
             
             
             class provider_api_keys(
                 schemas.ComposedSchema,
             ):
             
             
@@ -76,128 +107,161 @@
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
             stream = schemas.BoolSchema
-            suffix = schemas.StrSchema
             user = schemas.StrSchema
-            metadata = schemas.DictSchema
             __annotations__ = {
+                "messages": messages,
                 "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
                 "inputs": inputs,
                 "source": source,
+                "metadata": metadata,
                 "provider_api_keys": provider_api_keys,
                 "num_samples": num_samples,
-                "logprobs": logprobs,
                 "stream": stream,
-                "suffix": suffix,
                 "user": user,
-                "metadata": metadata,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    inputs: MetaOapg.properties.inputs
-    project: MetaOapg.properties.project
+    messages: MetaOapg.properties.messages
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionDeployedRequest':
+    ) -> 'ChatDeployedRequest':
         return super().__new__(
             cls,
             *args,
-            inputs=inputs,
+            messages=messages,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
-            logprobs=logprobs,
             stream=stream,
-            suffix=suffix,
             user=user,
-            metadata=metadata,
             _configuration=_configuration,
         )
 
+from humanloop.model.chat_message import ChatMessage
 from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_experiment_request.py` & `humanloop-0.4.9/humanloop/model/chat_model_config_request.py`

 * *Files 18% similar despite different names*

```diff
@@ -19,36 +19,67 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionExperimentRequest(
+class ChatModelConfigRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request for a specific experiment.
+    Base chat request.
     """
 
 
     class MetaOapg:
         required = {
-            "experiment_id",
-            "inputs",
-            "project",
+            "model_config_id",
+            "messages",
         }
         
         class properties:
+            
+            
+            class messages(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'messages':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
+            model_config_id = schemas.StrSchema
             project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
             inputs = schemas.DictSchema
-            experiment_id = schemas.StrSchema
             source = schemas.StrSchema
+            metadata = schemas.DictSchema
             
             
             class provider_api_keys(
                 schemas.ComposedSchema,
             ):
             
             
@@ -78,138 +109,171 @@
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
             stream = schemas.BoolSchema
-            suffix = schemas.StrSchema
             user = schemas.StrSchema
-            metadata = schemas.DictSchema
             __annotations__ = {
+                "messages": messages,
+                "model_config_id": model_config_id,
                 "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
                 "inputs": inputs,
-                "experiment_id": experiment_id,
                 "source": source,
+                "metadata": metadata,
                 "provider_api_keys": provider_api_keys,
                 "num_samples": num_samples,
-                "logprobs": logprobs,
                 "stream": stream,
-                "suffix": suffix,
                 "user": user,
-                "metadata": metadata,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    experiment_id: MetaOapg.properties.experiment_id
-    inputs: MetaOapg.properties.inputs
-    project: MetaOapg.properties.project
+    model_config_id: MetaOapg.properties.model_config_id
+    messages: MetaOapg.properties.messages
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        model_config_id: typing.Union[MetaOapg.properties.model_config_id, str, ],
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionExperimentRequest':
+    ) -> 'ChatModelConfigRequest':
         return super().__new__(
             cls,
             *args,
-            experiment_id=experiment_id,
-            inputs=inputs,
+            model_config_id=model_config_id,
+            messages=messages,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
-            logprobs=logprobs,
             stream=stream,
-            suffix=suffix,
             user=user,
-            metadata=metadata,
             _configuration=_configuration,
         )
 
+from humanloop.model.chat_message import ChatMessage
 from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_experiment_request.pyi` & `humanloop-0.4.9/humanloop/model/chat_model_config_request.pyi`

 * *Files 18% similar despite different names*

```diff
@@ -19,36 +19,67 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionExperimentRequest(
+class ChatModelConfigRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request for a specific experiment.
+    Base chat request.
     """
 
 
     class MetaOapg:
         required = {
-            "experiment_id",
-            "inputs",
-            "project",
+            "model_config_id",
+            "messages",
         }
         
         class properties:
+            
+            
+            class messages(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'messages':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
+            model_config_id = schemas.StrSchema
             project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
             inputs = schemas.DictSchema
-            experiment_id = schemas.StrSchema
             source = schemas.StrSchema
+            metadata = schemas.DictSchema
             
             
             class provider_api_keys(
                 schemas.ComposedSchema,
             ):
             
             
@@ -78,138 +109,171 @@
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
             stream = schemas.BoolSchema
-            suffix = schemas.StrSchema
             user = schemas.StrSchema
-            metadata = schemas.DictSchema
             __annotations__ = {
+                "messages": messages,
+                "model_config_id": model_config_id,
                 "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
                 "inputs": inputs,
-                "experiment_id": experiment_id,
                 "source": source,
+                "metadata": metadata,
                 "provider_api_keys": provider_api_keys,
                 "num_samples": num_samples,
-                "logprobs": logprobs,
                 "stream": stream,
-                "suffix": suffix,
                 "user": user,
-                "metadata": metadata,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    experiment_id: MetaOapg.properties.experiment_id
-    inputs: MetaOapg.properties.inputs
-    project: MetaOapg.properties.project
+    model_config_id: MetaOapg.properties.model_config_id
+    messages: MetaOapg.properties.messages
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["experiment_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config_id"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        model_config_id: typing.Union[MetaOapg.properties.model_config_id, str, ],
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionExperimentRequest':
+    ) -> 'ChatModelConfigRequest':
         return super().__new__(
             cls,
             *args,
-            experiment_id=experiment_id,
-            inputs=inputs,
+            model_config_id=model_config_id,
+            messages=messages,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
-            logprobs=logprobs,
             stream=stream,
-            suffix=suffix,
             user=user,
-            metadata=metadata,
             _configuration=_configuration,
         )
 
+from humanloop.model.chat_message import ChatMessage
 from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_model_config_request.py` & `humanloop-0.4.9/humanloop/model/completion_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,36 +19,75 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionModelConfigRequest(
+class CompletionRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request for a specific model config.
+    Completion request with a provided model config.
     """
 
 
     class MetaOapg:
         required = {
-            "inputs",
-            "model_config_id",
-            "project",
+            "model_config",
         }
         
         class properties:
+            
+            
+            class model_config(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ModelConfigCompletionRequest,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'model_config':
+                    return super().__new__(
+                        cls,
+                        *args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
             inputs = schemas.DictSchema
-            model_config_id = schemas.StrSchema
             source = schemas.StrSchema
+            metadata = schemas.DictSchema
             
             
             class provider_api_keys(
                 schemas.ComposedSchema,
             ):
             
             
@@ -82,47 +121,67 @@
                         **kwargs,
                     )
             num_samples = schemas.IntSchema
             logprobs = schemas.IntSchema
             stream = schemas.BoolSchema
             suffix = schemas.StrSchema
             user = schemas.StrSchema
-            metadata = schemas.DictSchema
             __annotations__ = {
+                "model_config": model_config,
                 "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
                 "inputs": inputs,
-                "model_config_id": model_config_id,
                 "source": source,
+                "metadata": metadata,
                 "provider_api_keys": provider_api_keys,
                 "num_samples": num_samples,
                 "logprobs": logprobs,
                 "stream": stream,
                 "suffix": suffix,
                 "user": user,
-                "metadata": metadata,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    inputs: MetaOapg.properties.inputs
-    model_config_id: MetaOapg.properties.model_config_id
-    project: MetaOapg.properties.project
+    model_config: MetaOapg.properties.model_config
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    
+    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
@@ -132,34 +191,49 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["model_config_id"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
@@ -169,47 +243,55 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["model_config_id"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        model_config_id: typing.Union[MetaOapg.properties.model_config_id, str, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
         suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionModelConfigRequest':
+    ) -> 'CompletionRequest':
         return super().__new__(
             cls,
             *args,
-            inputs=inputs,
-            model_config_id=model_config_id,
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
             _configuration=_configuration,
         )
 
+from humanloop.model.model_config_completion_request import ModelConfigCompletionRequest
 from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_model_config_request.pyi` & `humanloop-0.4.9/humanloop/model/completion_request.pyi`

 * *Files 19% similar despite different names*

```diff
@@ -19,36 +19,75 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionModelConfigRequest(
+class CompletionRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request for a specific model config.
+    Completion request with a provided model config.
     """
 
 
     class MetaOapg:
         required = {
-            "inputs",
-            "model_config_id",
-            "project",
+            "model_config",
         }
         
         class properties:
+            
+            
+            class model_config(
+                schemas.ComposedSchema,
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ModelConfigCompletionRequest,
+                        ]
+            
+            
+                def __new__(
+                    cls,
+                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'model_config':
+                    return super().__new__(
+                        cls,
+                        *args,
+                        _configuration=_configuration,
+                        **kwargs,
+                    )
             project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
             inputs = schemas.DictSchema
-            model_config_id = schemas.StrSchema
             source = schemas.StrSchema
+            metadata = schemas.DictSchema
             
             
             class provider_api_keys(
                 schemas.ComposedSchema,
             ):
             
             
@@ -82,47 +121,67 @@
                         **kwargs,
                     )
             num_samples = schemas.IntSchema
             logprobs = schemas.IntSchema
             stream = schemas.BoolSchema
             suffix = schemas.StrSchema
             user = schemas.StrSchema
-            metadata = schemas.DictSchema
             __annotations__ = {
+                "model_config": model_config,
                 "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
                 "inputs": inputs,
-                "model_config_id": model_config_id,
                 "source": source,
+                "metadata": metadata,
                 "provider_api_keys": provider_api_keys,
                 "num_samples": num_samples,
                 "logprobs": logprobs,
                 "stream": stream,
                 "suffix": suffix,
                 "user": user,
-                "metadata": metadata,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    inputs: MetaOapg.properties.inputs
-    model_config_id: MetaOapg.properties.model_config_id
-    project: MetaOapg.properties.project
+    model_config: MetaOapg.properties.model_config
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    
+    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
@@ -132,34 +191,49 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
-    
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["model_config_id"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config_id"]) -> MetaOapg.properties.model_config_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
@@ -169,47 +243,55 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
-    
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["inputs"], typing_extensions.Literal["model_config_id"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        model_config_id: typing.Union[MetaOapg.properties.model_config_id, str, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
         suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionModelConfigRequest':
+    ) -> 'CompletionRequest':
         return super().__new__(
             cls,
             *args,
-            inputs=inputs,
-            model_config_id=model_config_id,
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
             _configuration=_configuration,
         )
 
+from humanloop.model.model_config_completion_request import ModelConfigCompletionRequest
 from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_request.py` & `humanloop-0.4.9/humanloop/model/trace_log_request.py`

 * *Files 9% similar despite different names*

```diff
@@ -19,233 +19,263 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionRequest(
+class TraceLogRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request with a provided model config.
+    Simplified version of LogRequest.
+
+Changes:
+    - Renamed `project` to `function_name`. TODO: Allow either `function_name` or `function_id`.
     """
 
 
     class MetaOapg:
         required = {
-            "model_config",
-            "inputs",
-            "project",
+            "function_name",
         }
         
         class properties:
-            project = schemas.StrSchema
+            function_name = schemas.StrSchema
+            trial_id = schemas.StrSchema
             inputs = schemas.DictSchema
             
             
-            class model_config(
-                schemas.ComposedSchema,
+            class messages(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            ModelConfigCompletionRequest,
-                        ]
-            
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
             
                 def __new__(
                     cls,
-                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'model_config':
+                ) -> 'messages':
                     return super().__new__(
                         cls,
-                        *args,
+                        arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
+            output = schemas.StrSchema
             source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def one_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            TraceModelConfigRequest,
+                            ToolConfigRequest,
+                            GenericConfigRequest,
+                            AgentConfigRequest,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
-            stream = schemas.BoolSchema
-            suffix = schemas.StrSchema
-            user = schemas.StrSchema
             metadata = schemas.DictSchema
+            error = schemas.StrSchema
+            duration = schemas.NumberSchema
+            created_at = schemas.DateTimeSchema
+            
+            
+            class children(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['TraceLogRequest']:
+                        return TraceLogRequest
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['TraceLogRequest'], typing.List['TraceLogRequest']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'children':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'TraceLogRequest':
+                    return super().__getitem__(i)
             __annotations__ = {
-                "project": project,
+                "function_name": function_name,
+                "trial_id": trial_id,
                 "inputs": inputs,
-                "model_config": model_config,
+                "messages": messages,
+                "output": output,
                 "source": source,
-                "provider_api_keys": provider_api_keys,
-                "num_samples": num_samples,
-                "logprobs": logprobs,
-                "stream": stream,
-                "suffix": suffix,
-                "user": user,
+                "config": config,
                 "metadata": metadata,
+                "error": error,
+                "duration": duration,
+                "created_at": created_at,
+                "children": children,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    model_config: MetaOapg.properties.model_config
-    inputs: MetaOapg.properties.inputs
-    project: MetaOapg.properties.project
+    function_name: MetaOapg.properties.function_name
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def __getitem__(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["error"]) -> MetaOapg.properties.error: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["children"]) -> MetaOapg.properties.children: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["error"]) -> typing.Union[MetaOapg.properties.error, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> typing.Union[MetaOapg.properties.duration, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["children"]) -> typing.Union[MetaOapg.properties.children, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        function_name: typing.Union[MetaOapg.properties.function_name, str, ],
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
+        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
+        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
+        duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
+        children: typing.Union[MetaOapg.properties.children, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionRequest':
+    ) -> 'TraceLogRequest':
         return super().__new__(
             cls,
             *args,
-            model_config=model_config,
+            function_name=function_name,
+            trial_id=trial_id,
             inputs=inputs,
-            project=project,
+            messages=messages,
+            output=output,
             source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
+            config=config,
             metadata=metadata,
+            error=error,
+            duration=duration,
+            created_at=created_at,
+            children=children,
             _configuration=_configuration,
         )
 
-from humanloop.model.model_config_completion_request import ModelConfigCompletionRequest
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.agent_config_request import AgentConfigRequest
+from humanloop.model.chat_message import ChatMessage
+from humanloop.model.generic_config_request import GenericConfigRequest
+from humanloop.model.tool_config_request import ToolConfigRequest
+from humanloop.model.trace_model_config_request import TraceModelConfigRequest
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_request.pyi` & `humanloop-0.4.9/humanloop/model/trace_log_request.pyi`

 * *Files 9% similar despite different names*

```diff
@@ -19,233 +19,263 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionRequest(
+class TraceLogRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Completion request with a provided model config.
+    Simplified version of LogRequest.
+
+Changes:
+    - Renamed `project` to `function_name`. TODO: Allow either `function_name` or `function_id`.
     """
 
 
     class MetaOapg:
         required = {
-            "model_config",
-            "inputs",
-            "project",
+            "function_name",
         }
         
         class properties:
-            project = schemas.StrSchema
+            function_name = schemas.StrSchema
+            trial_id = schemas.StrSchema
             inputs = schemas.DictSchema
             
             
-            class model_config(
-                schemas.ComposedSchema,
+            class messages(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            ModelConfigCompletionRequest,
-                        ]
-            
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
             
                 def __new__(
                     cls,
-                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'model_config':
+                ) -> 'messages':
                     return super().__new__(
                         cls,
-                        *args,
+                        arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
+            output = schemas.StrSchema
             source = schemas.StrSchema
             
             
-            class provider_api_keys(
+            class config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def one_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ProviderApiKeys,
+                            TraceModelConfigRequest,
+                            ToolConfigRequest,
+                            GenericConfigRequest,
+                            AgentConfigRequest,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'provider_api_keys':
+                ) -> 'config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
-            stream = schemas.BoolSchema
-            suffix = schemas.StrSchema
-            user = schemas.StrSchema
             metadata = schemas.DictSchema
+            error = schemas.StrSchema
+            duration = schemas.NumberSchema
+            created_at = schemas.DateTimeSchema
+            
+            
+            class children(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['TraceLogRequest']:
+                        return TraceLogRequest
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['TraceLogRequest'], typing.List['TraceLogRequest']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'children':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'TraceLogRequest':
+                    return super().__getitem__(i)
             __annotations__ = {
-                "project": project,
+                "function_name": function_name,
+                "trial_id": trial_id,
                 "inputs": inputs,
-                "model_config": model_config,
+                "messages": messages,
+                "output": output,
                 "source": source,
-                "provider_api_keys": provider_api_keys,
-                "num_samples": num_samples,
-                "logprobs": logprobs,
-                "stream": stream,
-                "suffix": suffix,
-                "user": user,
+                "config": config,
                 "metadata": metadata,
+                "error": error,
+                "duration": duration,
+                "created_at": created_at,
+                "children": children,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    model_config: MetaOapg.properties.model_config
-    inputs: MetaOapg.properties.inputs
-    project: MetaOapg.properties.project
+    function_name: MetaOapg.properties.function_name
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def __getitem__(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
+    def __getitem__(self, name: typing_extensions.Literal["error"]) -> MetaOapg.properties.error: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["children"]) -> MetaOapg.properties.children: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["error"]) -> typing.Union[MetaOapg.properties.error, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> typing.Union[MetaOapg.properties.duration, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["children"]) -> typing.Union[MetaOapg.properties.children, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["inputs"], typing_extensions.Literal["project"], typing_extensions.Literal["source"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["logprobs"], typing_extensions.Literal["stream"], typing_extensions.Literal["suffix"], typing_extensions.Literal["user"], typing_extensions.Literal["metadata"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
+        function_name: typing.Union[MetaOapg.properties.function_name, str, ],
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
+        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
+        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
+        duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
+        children: typing.Union[MetaOapg.properties.children, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'CompletionRequest':
+    ) -> 'TraceLogRequest':
         return super().__new__(
             cls,
             *args,
-            model_config=model_config,
+            function_name=function_name,
+            trial_id=trial_id,
             inputs=inputs,
-            project=project,
+            messages=messages,
+            output=output,
             source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
+            config=config,
             metadata=metadata,
+            error=error,
+            duration=duration,
+            created_at=created_at,
+            children=children,
             _configuration=_configuration,
         )
 
-from humanloop.model.model_config_completion_request import ModelConfigCompletionRequest
-from humanloop.model.provider_api_keys import ProviderApiKeys
+from humanloop.model.agent_config_request import AgentConfigRequest
+from humanloop.model.chat_message import ChatMessage
+from humanloop.model.generic_config_request import GenericConfigRequest
+from humanloop.model.tool_config_request import ToolConfigRequest
+from humanloop.model.trace_model_config_request import TraceModelConfigRequest
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_response.py` & `humanloop-0.4.9/humanloop/model/experiment_response.py`

 * *Files 23% similar despite different names*

```diff
@@ -19,87 +19,77 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionResponse(
+class ExperimentResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
         required = {
-            "data",
+            "positive_labels",
+            "updated_at",
+            "metric",
             "project_id",
-            "provider_responses",
+            "name",
+            "created_at",
+            "id",
+            "status",
         }
         
         class properties:
+            id = schemas.StrSchema
             project_id = schemas.StrSchema
+            name = schemas.StrSchema
             
             
-            class data(
-                schemas.ListSchema
+            class status(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    @staticmethod
-                    def items() -> typing.Type['DataResponse']:
-                        return DataResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['DataResponse'], typing.List['DataResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'data':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'DataResponse':
-                    return super().__getitem__(i)
-            
-            
-            class provider_responses(
-                schemas.ListSchema
-            ):
-            
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ExperimentStatus,
+                        ]
             
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'provider_responses':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'status':
                     return super().__new__(
                         cls,
-                        arg,
+                        *args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
-            suffix = schemas.StrSchema
-            user = schemas.StrSchema
-            
             
-            class usage(
+            class metric(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -109,142 +99,202 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            Usage,
+                            BaseMetricResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'usage':
+                ) -> 'metric':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            metadata = schemas.DictSchema
+            
+            
+            class positive_labels(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['PositiveLabel']:
+                        return PositiveLabel
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['PositiveLabel'], typing.List['PositiveLabel']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'positive_labels':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'PositiveLabel':
+                    return super().__getitem__(i)
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            
+            
+            class configs(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ExperimentConfigResponse']:
+                        return ExperimentConfigResponse
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ExperimentConfigResponse'], typing.List['ExperimentConfigResponse']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'configs':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ExperimentConfigResponse':
+                    return super().__getitem__(i)
             __annotations__ = {
+                "id": id,
                 "project_id": project_id,
-                "data": data,
-                "provider_responses": provider_responses,
-                "num_samples": num_samples,
-                "logprobs": logprobs,
-                "suffix": suffix,
-                "user": user,
-                "usage": usage,
-                "metadata": metadata,
+                "name": name,
+                "status": status,
+                "metric": metric,
+                "positive_labels": positive_labels,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "configs": configs,
             }
     
-    data: MetaOapg.properties.data
+    positive_labels: MetaOapg.properties.positive_labels
+    updated_at: MetaOapg.properties.updated_at
+    metric: MetaOapg.properties.metric
     project_id: MetaOapg.properties.project_id
-    provider_responses: MetaOapg.properties.provider_responses
+    name: MetaOapg.properties.name
+    created_at: MetaOapg.properties.created_at
+    id: MetaOapg.properties.id
+    status: MetaOapg.properties.status
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["status"]) -> MetaOapg.properties.status: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["metric"]) -> MetaOapg.properties.metric: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["configs"]) -> MetaOapg.properties.configs: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "project_id", "name", "status", "metric", "positive_labels", "created_at", "updated_at", "configs", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["status"]) -> MetaOapg.properties.status: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metric"]) -> MetaOapg.properties.metric: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["configs"]) -> typing.Union[MetaOapg.properties.configs, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "project_id", "name", "status", "metric", "positive_labels", "created_at", "updated_at", "configs", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
+        positive_labels: typing.Union[MetaOapg.properties.positive_labels, list, tuple, ],
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        metric: typing.Union[MetaOapg.properties.metric, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         project_id: typing.Union[MetaOapg.properties.project_id, str, ],
-        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        status: typing.Union[MetaOapg.properties.status, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        configs: typing.Union[MetaOapg.properties.configs, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'CompletionResponse':
+    ) -> 'ExperimentResponse':
         return super().__new__(
             cls,
             *args,
-            data=data,
+            positive_labels=positive_labels,
+            updated_at=updated_at,
+            metric=metric,
             project_id=project_id,
-            provider_responses=provider_responses,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            suffix=suffix,
-            user=user,
-            usage=usage,
-            metadata=metadata,
+            name=name,
+            created_at=created_at,
+            id=id,
+            status=status,
+            configs=configs,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.data_response import DataResponse
-from humanloop.model.usage import Usage
+from humanloop.model.base_metric_response import BaseMetricResponse
+from humanloop.model.experiment_config_response import ExperimentConfigResponse
+from humanloop.model.experiment_status import ExperimentStatus
+from humanloop.model.positive_label import PositiveLabel
```

### Comparing `humanloop-0.4.8/humanloop/model/completion_response.pyi` & `humanloop-0.4.9/humanloop/model/experiment_response.pyi`

 * *Files 23% similar despite different names*

```diff
@@ -19,87 +19,77 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class CompletionResponse(
+class ExperimentResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
         required = {
-            "data",
+            "positive_labels",
+            "updated_at",
+            "metric",
             "project_id",
-            "provider_responses",
+            "name",
+            "created_at",
+            "id",
+            "status",
         }
         
         class properties:
+            id = schemas.StrSchema
             project_id = schemas.StrSchema
+            name = schemas.StrSchema
             
             
-            class data(
-                schemas.ListSchema
+            class status(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    @staticmethod
-                    def items() -> typing.Type['DataResponse']:
-                        return DataResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['DataResponse'], typing.List['DataResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'data':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'DataResponse':
-                    return super().__getitem__(i)
-            
-            
-            class provider_responses(
-                schemas.ListSchema
-            ):
-            
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ExperimentStatus,
+                        ]
             
-                class MetaOapg:
-                    items = schemas.AnyTypeSchema
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
+                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'provider_responses':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'status':
                     return super().__new__(
                         cls,
-                        arg,
+                        *args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
             
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            num_samples = schemas.IntSchema
-            logprobs = schemas.IntSchema
-            suffix = schemas.StrSchema
-            user = schemas.StrSchema
-            
             
-            class usage(
+            class metric(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
@@ -109,142 +99,202 @@
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            Usage,
+                            BaseMetricResponse,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'usage':
+                ) -> 'metric':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            metadata = schemas.DictSchema
+            
+            
+            class positive_labels(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['PositiveLabel']:
+                        return PositiveLabel
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['PositiveLabel'], typing.List['PositiveLabel']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'positive_labels':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'PositiveLabel':
+                    return super().__getitem__(i)
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            
+            
+            class configs(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ExperimentConfigResponse']:
+                        return ExperimentConfigResponse
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ExperimentConfigResponse'], typing.List['ExperimentConfigResponse']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'configs':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ExperimentConfigResponse':
+                    return super().__getitem__(i)
             __annotations__ = {
+                "id": id,
                 "project_id": project_id,
-                "data": data,
-                "provider_responses": provider_responses,
-                "num_samples": num_samples,
-                "logprobs": logprobs,
-                "suffix": suffix,
-                "user": user,
-                "usage": usage,
-                "metadata": metadata,
+                "name": name,
+                "status": status,
+                "metric": metric,
+                "positive_labels": positive_labels,
+                "created_at": created_at,
+                "updated_at": updated_at,
+                "configs": configs,
             }
     
-    data: MetaOapg.properties.data
+    positive_labels: MetaOapg.properties.positive_labels
+    updated_at: MetaOapg.properties.updated_at
+    metric: MetaOapg.properties.metric
     project_id: MetaOapg.properties.project_id
-    provider_responses: MetaOapg.properties.provider_responses
+    name: MetaOapg.properties.name
+    created_at: MetaOapg.properties.created_at
+    id: MetaOapg.properties.id
+    status: MetaOapg.properties.status
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
+    def __getitem__(self, name: typing_extensions.Literal["status"]) -> MetaOapg.properties.status: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["logprobs"]) -> MetaOapg.properties.logprobs: ...
+    def __getitem__(self, name: typing_extensions.Literal["metric"]) -> MetaOapg.properties.metric: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["suffix"]) -> MetaOapg.properties.suffix: ...
+    def __getitem__(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["usage"]) -> MetaOapg.properties.usage: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["configs"]) -> MetaOapg.properties.configs: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "project_id", "name", "status", "metric", "positive_labels", "created_at", "updated_at", "configs", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider_responses"]) -> MetaOapg.properties.provider_responses: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["status"]) -> MetaOapg.properties.status: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["logprobs"]) -> typing.Union[MetaOapg.properties.logprobs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metric"]) -> MetaOapg.properties.metric: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["suffix"]) -> typing.Union[MetaOapg.properties.suffix, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["usage"]) -> typing.Union[MetaOapg.properties.usage, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["configs"]) -> typing.Union[MetaOapg.properties.configs, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "data", "provider_responses", "num_samples", "logprobs", "suffix", "user", "usage", "metadata", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "project_id", "name", "status", "metric", "positive_labels", "created_at", "updated_at", "configs", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        data: typing.Union[MetaOapg.properties.data, list, tuple, ],
+        positive_labels: typing.Union[MetaOapg.properties.positive_labels, list, tuple, ],
+        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
+        metric: typing.Union[MetaOapg.properties.metric, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
         project_id: typing.Union[MetaOapg.properties.project_id, str, ],
-        provider_responses: typing.Union[MetaOapg.properties.provider_responses, list, tuple, ],
-        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        logprobs: typing.Union[MetaOapg.properties.logprobs, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        suffix: typing.Union[MetaOapg.properties.suffix, str, schemas.Unset] = schemas.unset,
-        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
-        usage: typing.Union[MetaOapg.properties.usage, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, ],
+        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        status: typing.Union[MetaOapg.properties.status, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        configs: typing.Union[MetaOapg.properties.configs, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'CompletionResponse':
+    ) -> 'ExperimentResponse':
         return super().__new__(
             cls,
             *args,
-            data=data,
+            positive_labels=positive_labels,
+            updated_at=updated_at,
+            metric=metric,
             project_id=project_id,
-            provider_responses=provider_responses,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            suffix=suffix,
-            user=user,
-            usage=usage,
-            metadata=metadata,
+            name=name,
+            created_at=created_at,
+            id=id,
+            status=status,
+            configs=configs,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.data_response import DataResponse
-from humanloop.model.usage import Usage
+from humanloop.model.base_metric_response import BaseMetricResponse
+from humanloop.model.experiment_config_response import ExperimentConfigResponse
+from humanloop.model.experiment_status import ExperimentStatus
+from humanloop.model.positive_label import PositiveLabel
```

### Comparing `humanloop-0.4.8/humanloop/model/config_response.py` & `humanloop-0.4.9/humanloop/model/config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/config_response.pyi` & `humanloop-0.4.9/humanloop/model/config_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/config_type.py` & `humanloop-0.4.9/humanloop/model/config_type.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/config_type.pyi` & `humanloop-0.4.9/humanloop/model/config_type.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_experiment_request.py` & `humanloop-0.4.9/humanloop/model/create_experiment_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_experiment_request.pyi` & `humanloop-0.4.9/humanloop/model/create_experiment_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_log_response.py` & `humanloop-0.4.9/humanloop/model/create_log_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_log_response.pyi` & `humanloop-0.4.9/humanloop/model/create_log_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_project_request.py` & `humanloop-0.4.9/humanloop/model/create_project_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_project_request.pyi` & `humanloop-0.4.9/humanloop/model/create_project_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_session_response.py` & `humanloop-0.4.9/humanloop/model/create_session_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_session_response.pyi` & `humanloop-0.4.9/humanloop/model/create_session_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_trace_request.py` & `humanloop-0.4.9/humanloop/model/create_trace_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_trace_request.pyi` & `humanloop-0.4.9/humanloop/model/create_trace_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_trace_response.py` & `humanloop-0.4.9/humanloop/model/create_trace_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/create_trace_response.pyi` & `humanloop-0.4.9/humanloop/model/create_trace_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/data_response.py` & `humanloop-0.4.9/humanloop/model/data_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/data_response.pyi` & `humanloop-0.4.9/humanloop/model/data_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/experiment_config_response.py` & `humanloop-0.4.9/humanloop/model/project_config_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,192 +19,184 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ExperimentConfigResponse(
+class ProjectConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
         required = {
             "updated_at",
-            "active",
+            "project_id",
+            "last_used",
             "created_at",
-            "id",
-            "display_name",
+            "project_name",
             "config",
-            "trials_count",
         }
         
         class properties:
-            trials_count = schemas.IntSchema
-            active = schemas.BoolSchema
-            id = schemas.StrSchema
-            display_name = schemas.StrSchema
+            project_id = schemas.StrSchema
+            project_name = schemas.StrSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            last_used = schemas.DateTimeSchema
+        
+            @staticmethod
+            def config() -> typing.Type['ConfigResponse']:
+                return ConfigResponse
             
             
-            class config(
-                schemas.ComposedSchema,
+            class feedback_stats(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            ConfigResponse,
-                        ]
-            
+                    @staticmethod
+                    def items() -> typing.Type['ProjectModelConfigFeedbackStatsResponse']:
+                        return ProjectModelConfigFeedbackStatsResponse
             
                 def __new__(
                     cls,
-                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    arg: typing.Union[typing.Tuple['ProjectModelConfigFeedbackStatsResponse'], typing.List['ProjectModelConfigFeedbackStatsResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'config':
+                ) -> 'feedback_stats':
                     return super().__new__(
                         cls,
-                        *args,
+                        arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            mean = schemas.NumberSchema
-            spread = schemas.NumberSchema
+            
+                def __getitem__(self, i: int) -> 'ProjectModelConfigFeedbackStatsResponse':
+                    return super().__getitem__(i)
+            num_datapoints = schemas.IntSchema
+            experiment_id = schemas.StrSchema
             __annotations__ = {
-                "trials_count": trials_count,
-                "active": active,
-                "id": id,
-                "display_name": display_name,
-                "config": config,
+                "project_id": project_id,
+                "project_name": project_name,
                 "created_at": created_at,
                 "updated_at": updated_at,
-                "mean": mean,
-                "spread": spread,
+                "last_used": last_used,
+                "config": config,
+                "feedback_stats": feedback_stats,
+                "num_datapoints": num_datapoints,
+                "experiment_id": experiment_id,
             }
     
     updated_at: MetaOapg.properties.updated_at
-    active: MetaOapg.properties.active
+    project_id: MetaOapg.properties.project_id
+    last_used: MetaOapg.properties.last_used
     created_at: MetaOapg.properties.created_at
-    id: MetaOapg.properties.id
-    display_name: MetaOapg.properties.display_name
-    config: MetaOapg.properties.config
-    trials_count: MetaOapg.properties.trials_count
+    project_name: MetaOapg.properties.project_name
+    config: 'ConfigResponse'
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["mean"]) -> MetaOapg.properties.mean: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["spread"]) -> MetaOapg.properties.spread: ...
+    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["mean"]) -> typing.Union[MetaOapg.properties.mean, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["spread"]) -> typing.Union[MetaOapg.properties.spread, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        active: typing.Union[MetaOapg.properties.active, bool, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        id: typing.Union[MetaOapg.properties.id, str, ],
-        display_name: typing.Union[MetaOapg.properties.display_name, str, ],
-        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        trials_count: typing.Union[MetaOapg.properties.trials_count, decimal.Decimal, int, ],
-        mean: typing.Union[MetaOapg.properties.mean, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        spread: typing.Union[MetaOapg.properties.spread, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        project_name: typing.Union[MetaOapg.properties.project_name, str, ],
+        config: 'ConfigResponse',
+        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
+        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ExperimentConfigResponse':
+    ) -> 'ProjectConfigResponse':
         return super().__new__(
             cls,
             *args,
             updated_at=updated_at,
-            active=active,
+            project_id=project_id,
+            last_used=last_used,
             created_at=created_at,
-            id=id,
-            display_name=display_name,
+            project_name=project_name,
             config=config,
-            trials_count=trials_count,
-            mean=mean,
-            spread=spread,
+            feedback_stats=feedback_stats,
+            num_datapoints=num_datapoints,
+            experiment_id=experiment_id,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.config_response import ConfigResponse
+from humanloop.model.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/experiment_config_response.pyi` & `humanloop-0.4.9/humanloop/model/project_config_response.pyi`

 * *Files 19% similar despite different names*

```diff
@@ -19,192 +19,184 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ExperimentConfigResponse(
+class ProjectConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
         required = {
             "updated_at",
-            "active",
+            "project_id",
+            "last_used",
             "created_at",
-            "id",
-            "display_name",
+            "project_name",
             "config",
-            "trials_count",
         }
         
         class properties:
-            trials_count = schemas.IntSchema
-            active = schemas.BoolSchema
-            id = schemas.StrSchema
-            display_name = schemas.StrSchema
+            project_id = schemas.StrSchema
+            project_name = schemas.StrSchema
+            created_at = schemas.DateTimeSchema
+            updated_at = schemas.DateTimeSchema
+            last_used = schemas.DateTimeSchema
+        
+            @staticmethod
+            def config() -> typing.Type['ConfigResponse']:
+                return ConfigResponse
             
             
-            class config(
-                schemas.ComposedSchema,
+            class feedback_stats(
+                schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @classmethod
-                    @functools.lru_cache()
-                    def all_of(cls):
-                        # we need this here to make our import statements work
-                        # we must store _composed_schemas in here so the code is only run
-                        # when we invoke this method. If we kept this at the class
-                        # level we would get an error because the class level
-                        # code would be run when this module is imported, and these composed
-                        # classes don't exist yet because their module has not finished
-                        # loading
-                        return [
-                            ConfigResponse,
-                        ]
-            
+                    @staticmethod
+                    def items() -> typing.Type['ProjectModelConfigFeedbackStatsResponse']:
+                        return ProjectModelConfigFeedbackStatsResponse
             
                 def __new__(
                     cls,
-                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                    arg: typing.Union[typing.Tuple['ProjectModelConfigFeedbackStatsResponse'], typing.List['ProjectModelConfigFeedbackStatsResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'config':
+                ) -> 'feedback_stats':
                     return super().__new__(
                         cls,
-                        *args,
+                        arg,
                         _configuration=_configuration,
-                        **kwargs,
                     )
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            mean = schemas.NumberSchema
-            spread = schemas.NumberSchema
+            
+                def __getitem__(self, i: int) -> 'ProjectModelConfigFeedbackStatsResponse':
+                    return super().__getitem__(i)
+            num_datapoints = schemas.IntSchema
+            experiment_id = schemas.StrSchema
             __annotations__ = {
-                "trials_count": trials_count,
-                "active": active,
-                "id": id,
-                "display_name": display_name,
-                "config": config,
+                "project_id": project_id,
+                "project_name": project_name,
                 "created_at": created_at,
                 "updated_at": updated_at,
-                "mean": mean,
-                "spread": spread,
+                "last_used": last_used,
+                "config": config,
+                "feedback_stats": feedback_stats,
+                "num_datapoints": num_datapoints,
+                "experiment_id": experiment_id,
             }
     
     updated_at: MetaOapg.properties.updated_at
-    active: MetaOapg.properties.active
+    project_id: MetaOapg.properties.project_id
+    last_used: MetaOapg.properties.last_used
     created_at: MetaOapg.properties.created_at
-    id: MetaOapg.properties.id
-    display_name: MetaOapg.properties.display_name
-    config: MetaOapg.properties.config
-    trials_count: MetaOapg.properties.trials_count
+    project_name: MetaOapg.properties.project_name
+    config: 'ConfigResponse'
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
+    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["mean"]) -> MetaOapg.properties.mean: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["spread"]) -> MetaOapg.properties.spread: ...
+    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trials_count"]) -> MetaOapg.properties.trials_count: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["active"]) -> MetaOapg.properties.active: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["mean"]) -> typing.Union[MetaOapg.properties.mean, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["spread"]) -> typing.Union[MetaOapg.properties.spread, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["trials_count", "active", "id", "display_name", "config", "created_at", "updated_at", "mean", "spread", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project_id", "project_name", "created_at", "updated_at", "last_used", "config", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        active: typing.Union[MetaOapg.properties.active, bool, ],
+        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
+        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        id: typing.Union[MetaOapg.properties.id, str, ],
-        display_name: typing.Union[MetaOapg.properties.display_name, str, ],
-        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
-        trials_count: typing.Union[MetaOapg.properties.trials_count, decimal.Decimal, int, ],
-        mean: typing.Union[MetaOapg.properties.mean, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        spread: typing.Union[MetaOapg.properties.spread, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        project_name: typing.Union[MetaOapg.properties.project_name, str, ],
+        config: 'ConfigResponse',
+        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
+        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ExperimentConfigResponse':
+    ) -> 'ProjectConfigResponse':
         return super().__new__(
             cls,
             *args,
             updated_at=updated_at,
-            active=active,
+            project_id=project_id,
+            last_used=last_used,
             created_at=created_at,
-            id=id,
-            display_name=display_name,
+            project_name=project_name,
             config=config,
-            trials_count=trials_count,
-            mean=mean,
-            spread=spread,
+            feedback_stats=feedback_stats,
+            num_datapoints=num_datapoints,
+            experiment_id=experiment_id,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.config_response import ConfigResponse
+from humanloop.model.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/experiment_status.py` & `humanloop-0.4.9/humanloop/model/experiment_status.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/experiment_status.pyi` & `humanloop-0.4.9/humanloop/model/experiment_status.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/experiments_list_response.py` & `humanloop-0.4.9/humanloop/model/experiments_list_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/experiments_list_response.pyi` & `humanloop-0.4.9/humanloop/model/experiments_list_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback.py` & `humanloop-0.4.9/humanloop/model/feedback.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback.pyi` & `humanloop-0.4.9/humanloop/model/feedback.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_class.py` & `humanloop-0.4.9/humanloop/model/feedback_class.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_class.pyi` & `humanloop-0.4.9/humanloop/model/feedback_class.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_label_request.py` & `humanloop-0.4.9/humanloop/model/feedback_label_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_label_request.pyi` & `humanloop-0.4.9/humanloop/model/feedback_label_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_request.py` & `humanloop-0.4.9/humanloop/model/feedback_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_request.pyi` & `humanloop-0.4.9/humanloop/model/feedback_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_response.py` & `humanloop-0.4.9/humanloop/model/feedback_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_response.pyi` & `humanloop-0.4.9/humanloop/model/feedback_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_submit_request.py` & `humanloop-0.4.9/humanloop/model/feedback_submit_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_submit_request.pyi` & `humanloop-0.4.9/humanloop/model/feedback_submit_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_submit_response.py` & `humanloop-0.4.9/humanloop/model/feedback_submit_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_submit_response.pyi` & `humanloop-0.4.9/humanloop/model/feedback_submit_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_type.py` & `humanloop-0.4.9/humanloop/model/feedback_type.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_type.pyi` & `humanloop-0.4.9/humanloop/model/feedback_type.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_type_model.py` & `humanloop-0.4.9/humanloop/model/feedback_type_model.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_type_model.pyi` & `humanloop-0.4.9/humanloop/model/feedback_type_model.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_type_request.py` & `humanloop-0.4.9/humanloop/model/feedback_type_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_type_request.pyi` & `humanloop-0.4.9/humanloop/model/feedback_type_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_types.py` & `humanloop-0.4.9/humanloop/model/feedback_types.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/feedback_types.pyi` & `humanloop-0.4.9/humanloop/model/feedback_types.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/generic_config_request.py` & `humanloop-0.4.9/humanloop/model/generic_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/generic_config_request.pyi` & `humanloop-0.4.9/humanloop/model/generic_config_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/generic_config_response.py` & `humanloop-0.4.9/humanloop/model/generic_config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/generic_config_response.pyi` & `humanloop-0.4.9/humanloop/model/generic_config_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/get_model_config_response.py` & `humanloop-0.4.9/humanloop/model/session_response.py`

 * *Files 24% similar despite different names*

```diff
@@ -19,195 +19,146 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class GetModelConfigResponse(
+class SessionResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    A selected model configuration.
-
-If the model configuration was selected in the context of an experiment,
-the response will include a trial_id to associate a subsequent log() call.
     """
 
 
     class MetaOapg:
         required = {
-            "updated_at",
-            "last_used",
+            "projects",
             "created_at",
-            "config",
+            "datapoints_count",
+            "id",
         }
         
         class properties:
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            last_used = schemas.DateTimeSchema
-        
-            @staticmethod
-            def config() -> typing.Type['ConfigResponse']:
-                return ConfigResponse
-            project_id = schemas.StrSchema
-            project_name = schemas.StrSchema
+            id = schemas.StrSchema
             
             
-            class feedback_stats(
+            class projects(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']:
-                        return SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+                    def items() -> typing.Type['SessionProjectResponse']:
+                        return SessionProjectResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse'], typing.List['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']],
+                    arg: typing.Union[typing.Tuple['SessionProjectResponse'], typing.List['SessionProjectResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'feedback_stats':
+                ) -> 'projects':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse':
+                def __getitem__(self, i: int) -> 'SessionProjectResponse':
                     return super().__getitem__(i)
-            num_datapoints = schemas.IntSchema
-            experiment_id = schemas.StrSchema
-            trial_id = schemas.StrSchema
+            datapoints_count = schemas.IntSchema
+            created_at = schemas.DateTimeSchema
+            first_inputs = schemas.DictSchema
+            last_output = schemas.StrSchema
             __annotations__ = {
+                "id": id,
+                "projects": projects,
+                "datapoints_count": datapoints_count,
                 "created_at": created_at,
-                "updated_at": updated_at,
-                "last_used": last_used,
-                "config": config,
-                "project_id": project_id,
-                "project_name": project_name,
-                "feedback_stats": feedback_stats,
-                "num_datapoints": num_datapoints,
-                "experiment_id": experiment_id,
-                "trial_id": trial_id,
+                "first_inputs": first_inputs,
+                "last_output": last_output,
             }
     
-    updated_at: MetaOapg.properties.updated_at
-    last_used: MetaOapg.properties.last_used
+    projects: MetaOapg.properties.projects
     created_at: MetaOapg.properties.created_at
-    config: 'ConfigResponse'
+    datapoints_count: MetaOapg.properties.datapoints_count
+    id: MetaOapg.properties.id
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
+    def __getitem__(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["first_inputs"]) -> MetaOapg.properties.first_inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["last_output"]) -> MetaOapg.properties.last_output: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> typing.Union[MetaOapg.properties.project_name, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["first_inputs"]) -> typing.Union[MetaOapg.properties.first_inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["last_output"]) -> typing.Union[MetaOapg.properties.last_output, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
+        projects: typing.Union[MetaOapg.properties.projects, list, tuple, ],
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        config: 'ConfigResponse',
-        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
-        project_name: typing.Union[MetaOapg.properties.project_name, str, schemas.Unset] = schemas.unset,
-        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
-        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        datapoints_count: typing.Union[MetaOapg.properties.datapoints_count, decimal.Decimal, int, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        first_inputs: typing.Union[MetaOapg.properties.first_inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        last_output: typing.Union[MetaOapg.properties.last_output, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'GetModelConfigResponse':
+    ) -> 'SessionResponse':
         return super().__new__(
             cls,
             *args,
-            updated_at=updated_at,
-            last_used=last_used,
+            projects=projects,
             created_at=created_at,
-            config=config,
-            project_id=project_id,
-            project_name=project_name,
-            feedback_stats=feedback_stats,
-            num_datapoints=num_datapoints,
-            experiment_id=experiment_id,
-            trial_id=trial_id,
+            datapoints_count=datapoints_count,
+            id=id,
+            first_inputs=first_inputs,
+            last_output=last_output,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.config_response import ConfigResponse
-from humanloop.model.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.model.session_project_response import SessionProjectResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/get_model_config_response.pyi` & `humanloop-0.4.9/humanloop/model/session_response.pyi`

 * *Files 24% similar despite different names*

```diff
@@ -19,195 +19,146 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class GetModelConfigResponse(
+class SessionResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
-
-    A selected model configuration.
-
-If the model configuration was selected in the context of an experiment,
-the response will include a trial_id to associate a subsequent log() call.
     """
 
 
     class MetaOapg:
         required = {
-            "updated_at",
-            "last_used",
+            "projects",
             "created_at",
-            "config",
+            "datapoints_count",
+            "id",
         }
         
         class properties:
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            last_used = schemas.DateTimeSchema
-        
-            @staticmethod
-            def config() -> typing.Type['ConfigResponse']:
-                return ConfigResponse
-            project_id = schemas.StrSchema
-            project_name = schemas.StrSchema
+            id = schemas.StrSchema
             
             
-            class feedback_stats(
+            class projects(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']:
-                        return SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+                    def items() -> typing.Type['SessionProjectResponse']:
+                        return SessionProjectResponse
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse'], typing.List['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']],
+                    arg: typing.Union[typing.Tuple['SessionProjectResponse'], typing.List['SessionProjectResponse']],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'feedback_stats':
+                ) -> 'projects':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse':
+                def __getitem__(self, i: int) -> 'SessionProjectResponse':
                     return super().__getitem__(i)
-            num_datapoints = schemas.IntSchema
-            experiment_id = schemas.StrSchema
-            trial_id = schemas.StrSchema
+            datapoints_count = schemas.IntSchema
+            created_at = schemas.DateTimeSchema
+            first_inputs = schemas.DictSchema
+            last_output = schemas.StrSchema
             __annotations__ = {
+                "id": id,
+                "projects": projects,
+                "datapoints_count": datapoints_count,
                 "created_at": created_at,
-                "updated_at": updated_at,
-                "last_used": last_used,
-                "config": config,
-                "project_id": project_id,
-                "project_name": project_name,
-                "feedback_stats": feedback_stats,
-                "num_datapoints": num_datapoints,
-                "experiment_id": experiment_id,
-                "trial_id": trial_id,
+                "first_inputs": first_inputs,
+                "last_output": last_output,
             }
     
-    updated_at: MetaOapg.properties.updated_at
-    last_used: MetaOapg.properties.last_used
+    projects: MetaOapg.properties.projects
     created_at: MetaOapg.properties.created_at
-    config: 'ConfigResponse'
+    datapoints_count: MetaOapg.properties.datapoints_count
+    id: MetaOapg.properties.id
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
+    def __getitem__(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
+    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["first_inputs"]) -> MetaOapg.properties.first_inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["last_output"]) -> MetaOapg.properties.last_output: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
+    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> typing.Union[MetaOapg.properties.project_name, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["first_inputs"]) -> typing.Union[MetaOapg.properties.first_inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["last_output"]) -> typing.Union[MetaOapg.properties.last_output, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", "trial_id", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
+        projects: typing.Union[MetaOapg.properties.projects, list, tuple, ],
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        config: 'ConfigResponse',
-        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
-        project_name: typing.Union[MetaOapg.properties.project_name, str, schemas.Unset] = schemas.unset,
-        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
-        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        datapoints_count: typing.Union[MetaOapg.properties.datapoints_count, decimal.Decimal, int, ],
+        id: typing.Union[MetaOapg.properties.id, str, ],
+        first_inputs: typing.Union[MetaOapg.properties.first_inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        last_output: typing.Union[MetaOapg.properties.last_output, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'GetModelConfigResponse':
+    ) -> 'SessionResponse':
         return super().__new__(
             cls,
             *args,
-            updated_at=updated_at,
-            last_used=last_used,
+            projects=projects,
             created_at=created_at,
-            config=config,
-            project_id=project_id,
-            project_name=project_name,
-            feedback_stats=feedback_stats,
-            num_datapoints=num_datapoints,
-            experiment_id=experiment_id,
-            trial_id=trial_id,
+            datapoints_count=datapoints_count,
+            id=id,
+            first_inputs=first_inputs,
+            last_output=last_output,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.config_response import ConfigResponse
-from humanloop.model.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.model.session_project_response import SessionProjectResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/http_validation_error.py` & `humanloop-0.4.9/humanloop/model/http_validation_error.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/http_validation_error.pyi` & `humanloop-0.4.9/humanloop/model/http_validation_error.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/label_sentiment.py` & `humanloop-0.4.9/humanloop/model/label_sentiment.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/label_sentiment.pyi` & `humanloop-0.4.9/humanloop/model/label_sentiment.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/log_datapoint_request.py` & `humanloop-0.4.9/humanloop/model/log_datapoint_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/log_datapoint_request.pyi` & `humanloop-0.4.9/humanloop/model/log_datapoint_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/log_model_config_request.py` & `humanloop-0.4.9/humanloop/model/log_model_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/log_model_config_request.pyi` & `humanloop-0.4.9/humanloop/model/log_model_config_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/log_request.py` & `humanloop-0.4.9/humanloop/model/log_request.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,28 +24,33 @@
 
 
 class LogRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
+
+    Request model for logging a datapoint.
     """
 
 
     class MetaOapg:
         
         class properties:
             project = schemas.StrSchema
-            reference_id = schemas.StrSchema
+            project_id = schemas.StrSchema
             session_id = schemas.StrSchema
             session_reference_id = schemas.StrSchema
             parent_id = schemas.StrSchema
             parent_reference_id = schemas.StrSchema
-            trial_id = schemas.StrSchema
             inputs = schemas.DictSchema
+            source = schemas.StrSchema
+            metadata = schemas.DictSchema
+            reference_id = schemas.StrSchema
+            trial_id = schemas.StrSchema
             
             
             class messages(
                 schemas.ListSchema
             ):
             
             
@@ -65,15 +70,14 @@
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
             output = schemas.StrSchema
-            source = schemas.StrSchema
             
             
             class config(
                 schemas.ComposedSchema,
             ):
             
             
@@ -105,15 +109,14 @@
                 ) -> 'config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            metadata = schemas.DictSchema
             
             
             class feedback(
                 schemas.ComposedSchema,
             ):
             
             
@@ -174,70 +177,74 @@
                         **kwargs,
                     )
             created_at = schemas.DateTimeSchema
             error = schemas.StrSchema
             duration = schemas.NumberSchema
             __annotations__ = {
                 "project": project,
-                "reference_id": reference_id,
+                "project_id": project_id,
                 "session_id": session_id,
                 "session_reference_id": session_reference_id,
                 "parent_id": parent_id,
                 "parent_reference_id": parent_reference_id,
-                "trial_id": trial_id,
                 "inputs": inputs,
+                "source": source,
+                "metadata": metadata,
+                "reference_id": reference_id,
+                "trial_id": trial_id,
                 "messages": messages,
                 "output": output,
-                "source": source,
                 "config": config,
-                "metadata": metadata,
                 "feedback": feedback,
                 "created_at": created_at,
                 "error": error,
                 "duration": duration,
             }
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["feedback"]) -> MetaOapg.properties.feedback: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
@@ -246,57 +253,60 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "config", "metadata", "feedback", "created_at", "error", "duration", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "config", "feedback", "created_at", "error", "duration", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["feedback"]) -> typing.Union[MetaOapg.properties.feedback, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
     
@@ -305,57 +315,59 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> typing.Union[MetaOapg.properties.duration, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "config", "metadata", "feedback", "created_at", "error", "duration", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "config", "feedback", "created_at", "error", "duration", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
-        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
         session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
         session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
         parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
         parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
         output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         feedback: typing.Union[MetaOapg.properties.feedback, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
         error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
         duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
     ) -> 'LogRequest':
         return super().__new__(
             cls,
             *args,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `humanloop-0.4.8/humanloop/model/log_request.pyi` & `humanloop-0.4.9/humanloop/model/log_request.pyi`

 * *Files 2% similar despite different names*

```diff
@@ -24,28 +24,33 @@
 
 
 class LogRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
+
+    Request model for logging a datapoint.
     """
 
 
     class MetaOapg:
         
         class properties:
             project = schemas.StrSchema
-            reference_id = schemas.StrSchema
+            project_id = schemas.StrSchema
             session_id = schemas.StrSchema
             session_reference_id = schemas.StrSchema
             parent_id = schemas.StrSchema
             parent_reference_id = schemas.StrSchema
-            trial_id = schemas.StrSchema
             inputs = schemas.DictSchema
+            source = schemas.StrSchema
+            metadata = schemas.DictSchema
+            reference_id = schemas.StrSchema
+            trial_id = schemas.StrSchema
             
             
             class messages(
                 schemas.ListSchema
             ):
             
             
@@ -65,15 +70,14 @@
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
             output = schemas.StrSchema
-            source = schemas.StrSchema
             
             
             class config(
                 schemas.ComposedSchema,
             ):
             
             
@@ -105,15 +109,14 @@
                 ) -> 'config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            metadata = schemas.DictSchema
             
             
             class feedback(
                 schemas.ComposedSchema,
             ):
             
             
@@ -174,70 +177,74 @@
                         **kwargs,
                     )
             created_at = schemas.DateTimeSchema
             error = schemas.StrSchema
             duration = schemas.NumberSchema
             __annotations__ = {
                 "project": project,
-                "reference_id": reference_id,
+                "project_id": project_id,
                 "session_id": session_id,
                 "session_reference_id": session_reference_id,
                 "parent_id": parent_id,
                 "parent_reference_id": parent_reference_id,
-                "trial_id": trial_id,
                 "inputs": inputs,
+                "source": source,
+                "metadata": metadata,
+                "reference_id": reference_id,
+                "trial_id": trial_id,
                 "messages": messages,
                 "output": output,
-                "source": source,
                 "config": config,
-                "metadata": metadata,
                 "feedback": feedback,
                 "created_at": created_at,
                 "error": error,
                 "duration": duration,
             }
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["feedback"]) -> MetaOapg.properties.feedback: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
@@ -246,57 +253,60 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "config", "metadata", "feedback", "created_at", "error", "duration", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "config", "feedback", "created_at", "error", "duration", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["feedback"]) -> typing.Union[MetaOapg.properties.feedback, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
     
@@ -305,57 +315,59 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> typing.Union[MetaOapg.properties.duration, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "config", "metadata", "feedback", "created_at", "error", "duration", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "config", "feedback", "created_at", "error", "duration", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
-        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
         session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
         session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
         parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
         parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
+        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
         output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         feedback: typing.Union[MetaOapg.properties.feedback, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
         error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
         duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
     ) -> 'LogRequest':
         return super().__new__(
             cls,
             *args,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `humanloop-0.4.8/humanloop/model/log_response.py` & `humanloop-0.4.9/humanloop/model/log_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,40 +24,42 @@
 
 
 class LogResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
+
+    Request model for logging a datapoint.
     """
 
 
     class MetaOapg:
         required = {
-            "project_id",
-            "project",
             "id",
             "config",
         }
         
         class properties:
-            project = schemas.StrSchema
         
             @staticmethod
             def config() -> typing.Type['ConfigResponse']:
                 return ConfigResponse
             id = schemas.StrSchema
+            project = schemas.StrSchema
             project_id = schemas.StrSchema
-            reference_id = schemas.StrSchema
             session_id = schemas.StrSchema
             session_reference_id = schemas.StrSchema
             parent_id = schemas.StrSchema
             parent_reference_id = schemas.StrSchema
-            trial_id = schemas.StrSchema
             inputs = schemas.DictSchema
+            source = schemas.StrSchema
+            metadata = schemas.DictSchema
+            reference_id = schemas.StrSchema
+            trial_id = schemas.StrSchema
             
             
             class messages(
                 schemas.ListSchema
             ):
             
             
@@ -77,16 +79,14 @@
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
             output = schemas.StrSchema
-            source = schemas.StrSchema
-            metadata = schemas.DictSchema
             
             
             class feedback(
                 schemas.ComposedSchema,
             ):
             
             
@@ -187,90 +187,88 @@
                     )
             user = schemas.StrSchema
             provider_response = schemas.DictSchema
             provider_latency = schemas.NumberSchema
             raw_output = schemas.StrSchema
             finish_reason = schemas.StrSchema
             __annotations__ = {
-                "project": project,
                 "config": config,
                 "id": id,
+                "project": project,
                 "project_id": project_id,
-                "reference_id": reference_id,
                 "session_id": session_id,
                 "session_reference_id": session_reference_id,
                 "parent_id": parent_id,
                 "parent_reference_id": parent_reference_id,
-                "trial_id": trial_id,
                 "inputs": inputs,
-                "messages": messages,
-                "output": output,
                 "source": source,
                 "metadata": metadata,
+                "reference_id": reference_id,
+                "trial_id": trial_id,
+                "messages": messages,
+                "output": output,
                 "feedback": feedback,
                 "created_at": created_at,
                 "error": error,
                 "duration": duration,
                 "model_config": model_config,
                 "user": user,
                 "provider_response": provider_response,
                 "provider_latency": provider_latency,
                 "raw_output": raw_output,
                 "finish_reason": finish_reason,
             }
     
-    project_id: MetaOapg.properties.project_id
-    project: MetaOapg.properties.project
     id: MetaOapg.properties.id
     config: 'ConfigResponse'
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["feedback"]) -> MetaOapg.properties.feedback: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
@@ -297,63 +295,63 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["finish_reason"]) -> MetaOapg.properties.finish_reason: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project", "config", "id", "project_id", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "metadata", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["config", "id", "project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["feedback"]) -> typing.Union[MetaOapg.properties.feedback, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
     
@@ -380,36 +378,36 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["finish_reason"]) -> typing.Union[MetaOapg.properties.finish_reason, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project", "config", "id", "project_id", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "metadata", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["config", "id", "project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
         config: 'ConfigResponse',
-        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
         session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
         session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
         parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
         parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
-        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
+        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         feedback: typing.Union[MetaOapg.properties.feedback, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
         error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
         duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
         provider_response: typing.Union[MetaOapg.properties.provider_response, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
@@ -418,29 +416,29 @@
         finish_reason: typing.Union[MetaOapg.properties.finish_reason, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
     ) -> 'LogResponse':
         return super().__new__(
             cls,
             *args,
-            project_id=project_id,
-            project=project,
             id=id,
             config=config,
-            reference_id=reference_id,
+            project=project,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
-            messages=messages,
-            output=output,
             source=source,
             metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
+            messages=messages,
+            output=output,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
             model_config=model_config,
             user=user,
             provider_response=provider_response,
```

### Comparing `humanloop-0.4.8/humanloop/model/log_response.pyi` & `humanloop-0.4.9/humanloop/model/log_response.pyi`

 * *Files 2% similar despite different names*

```diff
@@ -24,40 +24,42 @@
 
 
 class LogResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
+
+    Request model for logging a datapoint.
     """
 
 
     class MetaOapg:
         required = {
-            "project_id",
-            "project",
             "id",
             "config",
         }
         
         class properties:
-            project = schemas.StrSchema
         
             @staticmethod
             def config() -> typing.Type['ConfigResponse']:
                 return ConfigResponse
             id = schemas.StrSchema
+            project = schemas.StrSchema
             project_id = schemas.StrSchema
-            reference_id = schemas.StrSchema
             session_id = schemas.StrSchema
             session_reference_id = schemas.StrSchema
             parent_id = schemas.StrSchema
             parent_reference_id = schemas.StrSchema
-            trial_id = schemas.StrSchema
             inputs = schemas.DictSchema
+            source = schemas.StrSchema
+            metadata = schemas.DictSchema
+            reference_id = schemas.StrSchema
+            trial_id = schemas.StrSchema
             
             
             class messages(
                 schemas.ListSchema
             ):
             
             
@@ -77,16 +79,14 @@
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
             output = schemas.StrSchema
-            source = schemas.StrSchema
-            metadata = schemas.DictSchema
             
             
             class feedback(
                 schemas.ComposedSchema,
             ):
             
             
@@ -187,90 +187,88 @@
                     )
             user = schemas.StrSchema
             provider_response = schemas.DictSchema
             provider_latency = schemas.NumberSchema
             raw_output = schemas.StrSchema
             finish_reason = schemas.StrSchema
             __annotations__ = {
-                "project": project,
                 "config": config,
                 "id": id,
+                "project": project,
                 "project_id": project_id,
-                "reference_id": reference_id,
                 "session_id": session_id,
                 "session_reference_id": session_reference_id,
                 "parent_id": parent_id,
                 "parent_reference_id": parent_reference_id,
-                "trial_id": trial_id,
                 "inputs": inputs,
-                "messages": messages,
-                "output": output,
                 "source": source,
                 "metadata": metadata,
+                "reference_id": reference_id,
+                "trial_id": trial_id,
+                "messages": messages,
+                "output": output,
                 "feedback": feedback,
                 "created_at": created_at,
                 "error": error,
                 "duration": duration,
                 "model_config": model_config,
                 "user": user,
                 "provider_response": provider_response,
                 "provider_latency": provider_latency,
                 "raw_output": raw_output,
                 "finish_reason": finish_reason,
             }
     
-    project_id: MetaOapg.properties.project_id
-    project: MetaOapg.properties.project
     id: MetaOapg.properties.id
     config: 'ConfigResponse'
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    def __getitem__(self, name: typing_extensions.Literal["reference_id"]) -> MetaOapg.properties.reference_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["feedback"]) -> MetaOapg.properties.feedback: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
     
@@ -297,63 +295,63 @@
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["finish_reason"]) -> MetaOapg.properties.finish_reason: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["project", "config", "id", "project_id", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "metadata", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["config", "id", "project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["reference_id"]) -> typing.Union[MetaOapg.properties.reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["feedback"]) -> typing.Union[MetaOapg.properties.feedback, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
     
@@ -380,36 +378,36 @@
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["finish_reason"]) -> typing.Union[MetaOapg.properties.finish_reason, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["project", "config", "id", "project_id", "reference_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "trial_id", "inputs", "messages", "output", "source", "metadata", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["config", "id", "project", "project_id", "session_id", "session_reference_id", "parent_id", "parent_reference_id", "inputs", "source", "metadata", "reference_id", "trial_id", "messages", "output", "feedback", "created_at", "error", "duration", "model_config", "user", "provider_response", "provider_latency", "raw_output", "finish_reason", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        project_id: typing.Union[MetaOapg.properties.project_id, str, ],
-        project: typing.Union[MetaOapg.properties.project, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
         config: 'ConfigResponse',
-        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
         session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
         session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
         parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
         parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
         inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
-        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        reference_id: typing.Union[MetaOapg.properties.reference_id, str, schemas.Unset] = schemas.unset,
+        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
+        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         feedback: typing.Union[MetaOapg.properties.feedback, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
         error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
         duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
         provider_response: typing.Union[MetaOapg.properties.provider_response, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
@@ -418,29 +416,29 @@
         finish_reason: typing.Union[MetaOapg.properties.finish_reason, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
     ) -> 'LogResponse':
         return super().__new__(
             cls,
             *args,
-            project_id=project_id,
-            project=project,
             id=id,
             config=config,
-            reference_id=reference_id,
+            project=project,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
-            messages=messages,
-            output=output,
             source=source,
             metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
+            messages=messages,
+            output=output,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
             model_config=model_config,
             user=user,
             provider_response=provider_response,
```

### Comparing `humanloop-0.4.8/humanloop/model/logs_log_response.py` & `humanloop-0.4.9/humanloop/model/logs_log_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/logs_log_response.pyi` & `humanloop-0.4.9/humanloop/model/logs_log_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_config_chat_request.py` & `humanloop-0.4.9/humanloop/model/model_config_chat_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_config_chat_request.pyi` & `humanloop-0.4.9/humanloop/model/model_config_chat_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_config_completion_request.py` & `humanloop-0.4.9/humanloop/model/model_config_completion_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_config_completion_request.pyi` & `humanloop-0.4.9/humanloop/model/model_config_completion_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_endpoints.py` & `humanloop-0.4.9/humanloop/model/model_endpoints.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_endpoints.pyi` & `humanloop-0.4.9/humanloop/model/model_endpoints.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_providers.py` & `humanloop-0.4.9/humanloop/model/model_providers.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/model_providers.pyi` & `humanloop-0.4.9/humanloop/model/model_providers.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/paginated_data_log_response.py` & `humanloop-0.4.9/humanloop/model/paginated_data_log_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/paginated_data_log_response.pyi` & `humanloop-0.4.9/humanloop/model/paginated_data_log_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/paginated_data_project_response.py` & `humanloop-0.4.9/humanloop/model/paginated_data_project_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/paginated_data_project_response.pyi` & `humanloop-0.4.9/humanloop/model/paginated_data_project_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/paginated_data_session_response.py` & `humanloop-0.4.9/humanloop/model/paginated_data_session_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/paginated_data_session_response.pyi` & `humanloop-0.4.9/humanloop/model/paginated_data_session_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/positive_label.py` & `humanloop-0.4.9/humanloop/model/positive_label.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/positive_label.pyi` & `humanloop-0.4.9/humanloop/model/positive_label.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/project_config_response.py` & `humanloop-0.4.9/humanloop/model/update_experiment_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -19,180 +19,159 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ProjectConfigResponse(
+class UpdateExperimentRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
-        required = {
-            "updated_at",
-            "last_used",
-            "created_at",
-            "config",
-        }
         
         class properties:
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            last_used = schemas.DateTimeSchema
-        
-            @staticmethod
-            def config() -> typing.Type['ConfigResponse']:
-                return ConfigResponse
-            project_id = schemas.StrSchema
-            project_name = schemas.StrSchema
+            name = schemas.StrSchema
             
             
-            class feedback_stats(
+            class positive_labels(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']:
-                        return SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+                    def items() -> typing.Type['PositiveLabel']:
+                        return PositiveLabel
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['PositiveLabel'], typing.List['PositiveLabel']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'positive_labels':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'PositiveLabel':
+                    return super().__getitem__(i)
+            
+            
+            class config_ids_to_register(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.StrSchema
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'config_ids_to_register':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class config_ids_to_deregister(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.StrSchema
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse'], typing.List['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']],
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'feedback_stats':
+                ) -> 'config_ids_to_deregister':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse':
+                def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            num_datapoints = schemas.IntSchema
-            experiment_id = schemas.StrSchema
             __annotations__ = {
-                "created_at": created_at,
-                "updated_at": updated_at,
-                "last_used": last_used,
-                "config": config,
-                "project_id": project_id,
-                "project_name": project_name,
-                "feedback_stats": feedback_stats,
-                "num_datapoints": num_datapoints,
-                "experiment_id": experiment_id,
+                "name": name,
+                "positive_labels": positive_labels,
+                "config_ids_to_register": config_ids_to_register,
+                "config_ids_to_deregister": config_ids_to_deregister,
             }
     
-    updated_at: MetaOapg.properties.updated_at
-    last_used: MetaOapg.properties.last_used
-    created_at: MetaOapg.properties.created_at
-    config: 'ConfigResponse'
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
-    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
+    def __getitem__(self, name: typing_extensions.Literal["config_ids_to_register"]) -> MetaOapg.properties.config_ids_to_register: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["config_ids_to_deregister"]) -> MetaOapg.properties.config_ids_to_deregister: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "positive_labels", "config_ids_to_register", "config_ids_to_deregister", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> typing.Union[MetaOapg.properties.project_name, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["positive_labels"]) -> typing.Union[MetaOapg.properties.positive_labels, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config_ids_to_register"]) -> typing.Union[MetaOapg.properties.config_ids_to_register, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config_ids_to_deregister"]) -> typing.Union[MetaOapg.properties.config_ids_to_deregister, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "positive_labels", "config_ids_to_register", "config_ids_to_deregister", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        config: 'ConfigResponse',
-        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
-        project_name: typing.Union[MetaOapg.properties.project_name, str, schemas.Unset] = schemas.unset,
-        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
-        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
+        positive_labels: typing.Union[MetaOapg.properties.positive_labels, list, tuple, schemas.Unset] = schemas.unset,
+        config_ids_to_register: typing.Union[MetaOapg.properties.config_ids_to_register, list, tuple, schemas.Unset] = schemas.unset,
+        config_ids_to_deregister: typing.Union[MetaOapg.properties.config_ids_to_deregister, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ProjectConfigResponse':
+    ) -> 'UpdateExperimentRequest':
         return super().__new__(
             cls,
             *args,
-            updated_at=updated_at,
-            last_used=last_used,
-            created_at=created_at,
-            config=config,
-            project_id=project_id,
-            project_name=project_name,
-            feedback_stats=feedback_stats,
-            num_datapoints=num_datapoints,
-            experiment_id=experiment_id,
+            name=name,
+            positive_labels=positive_labels,
+            config_ids_to_register=config_ids_to_register,
+            config_ids_to_deregister=config_ids_to_deregister,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.config_response import ConfigResponse
-from humanloop.model.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.model.positive_label import PositiveLabel
```

### Comparing `humanloop-0.4.8/humanloop/model/project_config_response.pyi` & `humanloop-0.4.9/humanloop/model/update_experiment_request.pyi`

 * *Files 24% similar despite different names*

```diff
@@ -19,180 +19,159 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ProjectConfigResponse(
+class UpdateExperimentRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
-        required = {
-            "updated_at",
-            "last_used",
-            "created_at",
-            "config",
-        }
         
         class properties:
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            last_used = schemas.DateTimeSchema
-        
-            @staticmethod
-            def config() -> typing.Type['ConfigResponse']:
-                return ConfigResponse
-            project_id = schemas.StrSchema
-            project_name = schemas.StrSchema
+            name = schemas.StrSchema
             
             
-            class feedback_stats(
+            class positive_labels(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
                     @staticmethod
-                    def items() -> typing.Type['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']:
-                        return SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+                    def items() -> typing.Type['PositiveLabel']:
+                        return PositiveLabel
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['PositiveLabel'], typing.List['PositiveLabel']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'positive_labels':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'PositiveLabel':
+                    return super().__getitem__(i)
+            
+            
+            class config_ids_to_register(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.StrSchema
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'config_ids_to_register':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> MetaOapg.items:
+                    return super().__getitem__(i)
+            
+            
+            class config_ids_to_deregister(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    items = schemas.StrSchema
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse'], typing.List['SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse']],
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'feedback_stats':
+                ) -> 'config_ids_to_deregister':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse':
+                def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            num_datapoints = schemas.IntSchema
-            experiment_id = schemas.StrSchema
             __annotations__ = {
-                "created_at": created_at,
-                "updated_at": updated_at,
-                "last_used": last_used,
-                "config": config,
-                "project_id": project_id,
-                "project_name": project_name,
-                "feedback_stats": feedback_stats,
-                "num_datapoints": num_datapoints,
-                "experiment_id": experiment_id,
+                "name": name,
+                "positive_labels": positive_labels,
+                "config_ids_to_register": config_ids_to_register,
+                "config_ids_to_deregister": config_ids_to_deregister,
             }
     
-    updated_at: MetaOapg.properties.updated_at
-    last_used: MetaOapg.properties.last_used
-    created_at: MetaOapg.properties.created_at
-    config: 'ConfigResponse'
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
-    
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
+    def __getitem__(self, name: typing_extensions.Literal["config_ids_to_register"]) -> MetaOapg.properties.config_ids_to_register: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["config_ids_to_deregister"]) -> MetaOapg.properties.config_ids_to_deregister: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "positive_labels", "config_ids_to_register", "config_ids_to_deregister", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> 'ConfigResponse': ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> typing.Union[MetaOapg.properties.project_name, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["positive_labels"]) -> typing.Union[MetaOapg.properties.positive_labels, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config_ids_to_register"]) -> typing.Union[MetaOapg.properties.config_ids_to_register, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["config_ids_to_deregister"]) -> typing.Union[MetaOapg.properties.config_ids_to_deregister, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["created_at", "updated_at", "last_used", "config", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "positive_labels", "config_ids_to_register", "config_ids_to_deregister", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        config: 'ConfigResponse',
-        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
-        project_name: typing.Union[MetaOapg.properties.project_name, str, schemas.Unset] = schemas.unset,
-        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
-        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
+        positive_labels: typing.Union[MetaOapg.properties.positive_labels, list, tuple, schemas.Unset] = schemas.unset,
+        config_ids_to_register: typing.Union[MetaOapg.properties.config_ids_to_register, list, tuple, schemas.Unset] = schemas.unset,
+        config_ids_to_deregister: typing.Union[MetaOapg.properties.config_ids_to_deregister, list, tuple, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ProjectConfigResponse':
+    ) -> 'UpdateExperimentRequest':
         return super().__new__(
             cls,
             *args,
-            updated_at=updated_at,
-            last_used=last_used,
-            created_at=created_at,
-            config=config,
-            project_id=project_id,
-            project_name=project_name,
-            feedback_stats=feedback_stats,
-            num_datapoints=num_datapoints,
-            experiment_id=experiment_id,
+            name=name,
+            positive_labels=positive_labels,
+            config_ids_to_register=config_ids_to_register,
+            config_ids_to_deregister=config_ids_to_deregister,
             _configuration=_configuration,
             **kwargs,
         )
 
-from humanloop.model.config_response import ConfigResponse
-from humanloop.model.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.model.positive_label import PositiveLabel
```

### Comparing `humanloop-0.4.8/humanloop/model/project_model_config_request.py` & `humanloop-0.4.9/humanloop/model/project_model_config_request.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,16 +25,15 @@
 
 class ProjectModelConfigRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Core ModelConfig request model.
-Following closely: https://beta.openai.com/docs/api-reference/completions/create
+    Model config request
     """
 
 
     class MetaOapg:
         required = {
             "project",
             "model",
@@ -75,50 +74,83 @@
                 ) -> 'provider':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            max_tokens = schemas.IntSchema
+            temperature = schemas.NumberSchema
+            top_p = schemas.NumberSchema
             
             
-            class endpoint(
+            class stop(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.StrSchema
+                    
+                    
+                    class any_of_1(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'any_of_1':
+                            return super().__new__(
+                                cls,
+                                arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelEndpoints,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'endpoint':
+                ) -> 'stop':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            presence_penalty = schemas.NumberSchema
+            frequency_penalty = schemas.NumberSchema
+            other = schemas.DictSchema
+            name = schemas.StrSchema
+            experiment = schemas.StrSchema
             prompt_template = schemas.StrSchema
             
             
             class chat_template(
                 schemas.ListSchema
             ):
             
@@ -138,99 +170,66 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            temperature = schemas.NumberSchema
-            max_tokens = schemas.IntSchema
-            top_p = schemas.NumberSchema
             
             
-            class stop(
+            class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.StrSchema
-                    
-                    
-                    class any_of_1(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'any_of_1':
-                            return super().__new__(
-                                cls,
-                                arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ModelEndpoints,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'stop':
+                ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            presence_penalty = schemas.NumberSchema
-            frequency_penalty = schemas.NumberSchema
-            other = schemas.DictSchema
-            name = schemas.StrSchema
-            experiment = schemas.StrSchema
             __annotations__ = {
                 "model": model,
                 "project": project,
                 "provider": provider,
-                "endpoint": endpoint,
-                "prompt_template": prompt_template,
-                "chat_template": chat_template,
-                "temperature": temperature,
                 "max_tokens": max_tokens,
+                "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
                 "other": other,
                 "name": name,
                 "experiment": experiment,
+                "prompt_template": prompt_template,
+                "chat_template": chat_template,
+                "endpoint": endpoint,
             }
     
     project: MetaOapg.properties.project
     model: MetaOapg.properties.model
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
@@ -238,29 +237,20 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["temperature"]) -> MetaOapg.properties.temperature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["top_p"]) -> MetaOapg.properties.top_p: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["stop"]) -> MetaOapg.properties.stop: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
@@ -274,46 +264,46 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["experiment"]) -> MetaOapg.properties.experiment: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    
+    @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", "prompt_template", "chat_template", "endpoint", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["temperature"]) -> typing.Union[MetaOapg.properties.temperature, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["top_p"]) -> typing.Union[MetaOapg.properties.top_p, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["stop"]) -> typing.Union[MetaOapg.properties.stop, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
@@ -327,59 +317,68 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["experiment"]) -> typing.Union[MetaOapg.properties.experiment, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", "prompt_template", "chat_template", "endpoint", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         project: typing.Union[MetaOapg.properties.project, str, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
-        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
         experiment: typing.Union[MetaOapg.properties.experiment, str, schemas.Unset] = schemas.unset,
+        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
+        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
     ) -> 'ProjectModelConfigRequest':
         return super().__new__(
             cls,
             *args,
             project=project,
             model=model,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             name=name,
             experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
```

### Comparing `humanloop-0.4.8/humanloop/model/project_model_config_request.pyi` & `humanloop-0.4.9/humanloop/model/project_model_config_request.pyi`

 * *Files 1% similar despite different names*

```diff
@@ -25,16 +25,15 @@
 
 class ProjectModelConfigRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Core ModelConfig request model.
-Following closely: https://beta.openai.com/docs/api-reference/completions/create
+    Model config request
     """
 
 
     class MetaOapg:
         required = {
             "project",
             "model",
@@ -75,50 +74,83 @@
                 ) -> 'provider':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            max_tokens = schemas.IntSchema
+            temperature = schemas.NumberSchema
+            top_p = schemas.NumberSchema
             
             
-            class endpoint(
+            class stop(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.StrSchema
+                    
+                    
+                    class any_of_1(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'any_of_1':
+                            return super().__new__(
+                                cls,
+                                arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelEndpoints,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'endpoint':
+                ) -> 'stop':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            presence_penalty = schemas.NumberSchema
+            frequency_penalty = schemas.NumberSchema
+            other = schemas.DictSchema
+            name = schemas.StrSchema
+            experiment = schemas.StrSchema
             prompt_template = schemas.StrSchema
             
             
             class chat_template(
                 schemas.ListSchema
             ):
             
@@ -138,99 +170,66 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            temperature = schemas.NumberSchema
-            max_tokens = schemas.IntSchema
-            top_p = schemas.NumberSchema
             
             
-            class stop(
+            class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.StrSchema
-                    
-                    
-                    class any_of_1(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'any_of_1':
-                            return super().__new__(
-                                cls,
-                                arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ModelEndpoints,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'stop':
+                ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            presence_penalty = schemas.NumberSchema
-            frequency_penalty = schemas.NumberSchema
-            other = schemas.DictSchema
-            name = schemas.StrSchema
-            experiment = schemas.StrSchema
             __annotations__ = {
                 "model": model,
                 "project": project,
                 "provider": provider,
-                "endpoint": endpoint,
-                "prompt_template": prompt_template,
-                "chat_template": chat_template,
-                "temperature": temperature,
                 "max_tokens": max_tokens,
+                "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
                 "other": other,
                 "name": name,
                 "experiment": experiment,
+                "prompt_template": prompt_template,
+                "chat_template": chat_template,
+                "endpoint": endpoint,
             }
     
     project: MetaOapg.properties.project
     model: MetaOapg.properties.model
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
@@ -238,29 +237,20 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["temperature"]) -> MetaOapg.properties.temperature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["top_p"]) -> MetaOapg.properties.top_p: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["stop"]) -> MetaOapg.properties.stop: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
@@ -274,46 +264,46 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["experiment"]) -> MetaOapg.properties.experiment: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    
+    @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", "prompt_template", "chat_template", "endpoint", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["temperature"]) -> typing.Union[MetaOapg.properties.temperature, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["top_p"]) -> typing.Union[MetaOapg.properties.top_p, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["stop"]) -> typing.Union[MetaOapg.properties.stop, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
@@ -327,59 +317,68 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["experiment"]) -> typing.Union[MetaOapg.properties.experiment, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "project", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "name", "experiment", "prompt_template", "chat_template", "endpoint", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         project: typing.Union[MetaOapg.properties.project, str, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
-        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
         experiment: typing.Union[MetaOapg.properties.experiment, str, schemas.Unset] = schemas.unset,
+        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
+        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
     ) -> 'ProjectModelConfigRequest':
         return super().__new__(
             cls,
             *args,
             project=project,
             model=model,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             name=name,
             experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
```

### Comparing `humanloop-0.4.8/humanloop/model/project_model_config_response.py` & `humanloop-0.4.9/humanloop/model/src_external_app_models_v4_configs_model_config_response.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,40 +19,54 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ProjectModelConfigResponse(
+class SrcExternalAppModelsV4ConfigsModelConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Extends the core ModelConfig request object to include Humanloop generated
-identifier and method for serializing response from ModelConfig domain object.
+    Model config request
     """
 
 
     class MetaOapg:
         required = {
-            "updated_at",
-            "last_used",
-            "created_at",
+            "name",
             "model",
             "id",
+            "type",
         }
         
         class properties:
-            model = schemas.StrSchema
             id = schemas.StrSchema
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            last_used = schemas.DateTimeSchema
+            
+            
+            class type(
+                schemas.EnumBase,
+                schemas.StrSchema
+            ):
+            
+            
+                class MetaOapg:
+                    enum_value_to_name = {
+                        "model": "MODEL",
+                    }
+                
+                @schemas.classproperty
+                def MODEL(cls):
+                    return cls("model")
+            name = schemas.StrSchema
+            model = schemas.StrSchema
+            description = schemas.StrSchema
+            other = schemas.DictSchema
             
             
             class provider(
                 schemas.ComposedSchema,
             ):
             
             
@@ -81,50 +95,80 @@
                 ) -> 'provider':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            max_tokens = schemas.IntSchema
+            temperature = schemas.NumberSchema
+            top_p = schemas.NumberSchema
             
             
-            class endpoint(
+            class stop(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.StrSchema
+                    
+                    
+                    class any_of_1(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'any_of_1':
+                            return super().__new__(
+                                cls,
+                                arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelEndpoints,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'endpoint':
+                ) -> 'stop':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            presence_penalty = schemas.NumberSchema
+            frequency_penalty = schemas.NumberSchema
             prompt_template = schemas.StrSchema
             
             
             class chat_template(
                 schemas.ListSchema
             ):
             
@@ -144,344 +188,226 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            temperature = schemas.NumberSchema
-            max_tokens = schemas.IntSchema
-            top_p = schemas.NumberSchema
             
             
-            class stop(
+            class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.StrSchema
-                    
-                    
-                    class any_of_1(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'any_of_1':
-                            return super().__new__(
-                                cls,
-                                arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ModelEndpoints,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'stop':
+                ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            presence_penalty = schemas.NumberSchema
-            frequency_penalty = schemas.NumberSchema
-            other = schemas.DictSchema
-            display_name = schemas.StrSchema
-            project_id = schemas.StrSchema
-            project_name = schemas.StrSchema
-            
-            
-            class feedback_stats(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse']:
-                        return SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse'], typing.List['SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'feedback_stats':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse':
-                    return super().__getitem__(i)
-            num_datapoints = schemas.IntSchema
-            experiment_id = schemas.StrSchema
             __annotations__ = {
-                "model": model,
                 "id": id,
-                "created_at": created_at,
-                "updated_at": updated_at,
-                "last_used": last_used,
+                "type": type,
+                "name": name,
+                "model": model,
+                "description": description,
+                "other": other,
                 "provider": provider,
-                "endpoint": endpoint,
-                "prompt_template": prompt_template,
-                "chat_template": chat_template,
-                "temperature": temperature,
                 "max_tokens": max_tokens,
+                "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
-                "other": other,
-                "display_name": display_name,
-                "project_id": project_id,
-                "project_name": project_name,
-                "feedback_stats": feedback_stats,
-                "num_datapoints": num_datapoints,
-                "experiment_id": experiment_id,
+                "prompt_template": prompt_template,
+                "chat_template": chat_template,
+                "endpoint": endpoint,
             }
     
-    updated_at: MetaOapg.properties.updated_at
-    last_used: MetaOapg.properties.last_used
-    created_at: MetaOapg.properties.created_at
+    name: MetaOapg.properties.name
     model: MetaOapg.properties.model
     id: MetaOapg.properties.id
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
+    type: MetaOapg.properties.type
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
+    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["temperature"]) -> MetaOapg.properties.temperature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["top_p"]) -> MetaOapg.properties.top_p: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["stop"]) -> MetaOapg.properties.stop: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["frequency_penalty"]) -> MetaOapg.properties.frequency_penalty: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "id", "created_at", "updated_at", "last_used", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["temperature"]) -> typing.Union[MetaOapg.properties.temperature, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["top_p"]) -> typing.Union[MetaOapg.properties.top_p, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["stop"]) -> typing.Union[MetaOapg.properties.stop, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["frequency_penalty"]) -> typing.Union[MetaOapg.properties.frequency_penalty, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> typing.Union[MetaOapg.properties.display_name, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> typing.Union[MetaOapg.properties.project_name, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "id", "created_at", "updated_at", "last_used", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
+        type: typing.Union[MetaOapg.properties.type, str, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
+        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
-        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        display_name: typing.Union[MetaOapg.properties.display_name, str, schemas.Unset] = schemas.unset,
-        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
-        project_name: typing.Union[MetaOapg.properties.project_name, str, schemas.Unset] = schemas.unset,
-        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
-        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
+        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
+        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ProjectModelConfigResponse':
+    ) -> 'SrcExternalAppModelsV4ConfigsModelConfigResponse':
         return super().__new__(
             cls,
             *args,
-            updated_at=updated_at,
-            last_used=last_used,
-            created_at=created_at,
+            name=name,
             model=model,
             id=id,
+            type=type,
+            description=description,
+            other=other,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
-            other=other,
-            display_name=display_name,
-            project_id=project_id,
-            project_name=project_name,
-            feedback_stats=feedback_stats,
-            num_datapoints=num_datapoints,
-            experiment_id=experiment_id,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
-from humanloop.model.src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/project_model_config_response.pyi` & `humanloop-0.4.9/humanloop/model/src_external_app_models_v4_configs_model_config_response.pyi`

 * *Files 19% similar despite different names*

```diff
@@ -19,40 +19,48 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ProjectModelConfigResponse(
+class SrcExternalAppModelsV4ConfigsModelConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Extends the core ModelConfig request object to include Humanloop generated
-identifier and method for serializing response from ModelConfig domain object.
+    Model config request
     """
 
 
     class MetaOapg:
         required = {
-            "updated_at",
-            "last_used",
-            "created_at",
+            "name",
             "model",
             "id",
+            "type",
         }
         
         class properties:
-            model = schemas.StrSchema
             id = schemas.StrSchema
-            created_at = schemas.DateTimeSchema
-            updated_at = schemas.DateTimeSchema
-            last_used = schemas.DateTimeSchema
+            
+            
+            class type(
+                schemas.EnumBase,
+                schemas.StrSchema
+            ):
+                
+                @schemas.classproperty
+                def MODEL(cls):
+                    return cls("model")
+            name = schemas.StrSchema
+            model = schemas.StrSchema
+            description = schemas.StrSchema
+            other = schemas.DictSchema
             
             
             class provider(
                 schemas.ComposedSchema,
             ):
             
             
@@ -81,50 +89,80 @@
                 ) -> 'provider':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            max_tokens = schemas.IntSchema
+            temperature = schemas.NumberSchema
+            top_p = schemas.NumberSchema
             
             
-            class endpoint(
+            class stop(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.StrSchema
+                    
+                    
+                    class any_of_1(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'any_of_1':
+                            return super().__new__(
+                                cls,
+                                arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelEndpoints,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'endpoint':
+                ) -> 'stop':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            presence_penalty = schemas.NumberSchema
+            frequency_penalty = schemas.NumberSchema
             prompt_template = schemas.StrSchema
             
             
             class chat_template(
                 schemas.ListSchema
             ):
             
@@ -144,344 +182,226 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            temperature = schemas.NumberSchema
-            max_tokens = schemas.IntSchema
-            top_p = schemas.NumberSchema
             
             
-            class stop(
+            class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.StrSchema
-                    
-                    
-                    class any_of_1(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'any_of_1':
-                            return super().__new__(
-                                cls,
-                                arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ModelEndpoints,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'stop':
+                ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            presence_penalty = schemas.NumberSchema
-            frequency_penalty = schemas.NumberSchema
-            other = schemas.DictSchema
-            display_name = schemas.StrSchema
-            project_id = schemas.StrSchema
-            project_name = schemas.StrSchema
-            
-            
-            class feedback_stats(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse']:
-                        return SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse'], typing.List['SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'feedback_stats':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse':
-                    return super().__getitem__(i)
-            num_datapoints = schemas.IntSchema
-            experiment_id = schemas.StrSchema
             __annotations__ = {
-                "model": model,
                 "id": id,
-                "created_at": created_at,
-                "updated_at": updated_at,
-                "last_used": last_used,
+                "type": type,
+                "name": name,
+                "model": model,
+                "description": description,
+                "other": other,
                 "provider": provider,
-                "endpoint": endpoint,
-                "prompt_template": prompt_template,
-                "chat_template": chat_template,
-                "temperature": temperature,
                 "max_tokens": max_tokens,
+                "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
-                "other": other,
-                "display_name": display_name,
-                "project_id": project_id,
-                "project_name": project_name,
-                "feedback_stats": feedback_stats,
-                "num_datapoints": num_datapoints,
-                "experiment_id": experiment_id,
+                "prompt_template": prompt_template,
+                "chat_template": chat_template,
+                "endpoint": endpoint,
             }
     
-    updated_at: MetaOapg.properties.updated_at
-    last_used: MetaOapg.properties.last_used
-    created_at: MetaOapg.properties.created_at
+    name: MetaOapg.properties.name
     model: MetaOapg.properties.model
     id: MetaOapg.properties.id
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
+    type: MetaOapg.properties.type
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
+    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["temperature"]) -> MetaOapg.properties.temperature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["top_p"]) -> MetaOapg.properties.top_p: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["stop"]) -> MetaOapg.properties.stop: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["frequency_penalty"]) -> MetaOapg.properties.frequency_penalty: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["project_name"]) -> MetaOapg.properties.project_name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["feedback_stats"]) -> MetaOapg.properties.feedback_stats: ...
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["num_datapoints"]) -> MetaOapg.properties.num_datapoints: ...
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["experiment_id"]) -> MetaOapg.properties.experiment_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "id", "created_at", "updated_at", "last_used", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["updated_at"]) -> MetaOapg.properties.updated_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_used"]) -> MetaOapg.properties.last_used: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["temperature"]) -> typing.Union[MetaOapg.properties.temperature, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["top_p"]) -> typing.Union[MetaOapg.properties.top_p, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["stop"]) -> typing.Union[MetaOapg.properties.stop, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["frequency_penalty"]) -> typing.Union[MetaOapg.properties.frequency_penalty, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> typing.Union[MetaOapg.properties.display_name, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["project_name"]) -> typing.Union[MetaOapg.properties.project_name, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["feedback_stats"]) -> typing.Union[MetaOapg.properties.feedback_stats, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["num_datapoints"]) -> typing.Union[MetaOapg.properties.num_datapoints, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["experiment_id"]) -> typing.Union[MetaOapg.properties.experiment_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "id", "created_at", "updated_at", "last_used", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "project_id", "project_name", "feedback_stats", "num_datapoints", "experiment_id", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        updated_at: typing.Union[MetaOapg.properties.updated_at, str, datetime, ],
-        last_used: typing.Union[MetaOapg.properties.last_used, str, datetime, ],
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
+        type: typing.Union[MetaOapg.properties.type, str, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
+        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
-        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        display_name: typing.Union[MetaOapg.properties.display_name, str, schemas.Unset] = schemas.unset,
-        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
-        project_name: typing.Union[MetaOapg.properties.project_name, str, schemas.Unset] = schemas.unset,
-        feedback_stats: typing.Union[MetaOapg.properties.feedback_stats, list, tuple, schemas.Unset] = schemas.unset,
-        num_datapoints: typing.Union[MetaOapg.properties.num_datapoints, decimal.Decimal, int, schemas.Unset] = schemas.unset,
-        experiment_id: typing.Union[MetaOapg.properties.experiment_id, str, schemas.Unset] = schemas.unset,
+        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
+        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ProjectModelConfigResponse':
+    ) -> 'SrcExternalAppModelsV4ConfigsModelConfigResponse':
         return super().__new__(
             cls,
             *args,
-            updated_at=updated_at,
-            last_used=last_used,
-            created_at=created_at,
+            name=name,
             model=model,
             id=id,
+            type=type,
+            description=description,
+            other=other,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
-            other=other,
-            display_name=display_name,
-            project_id=project_id,
-            project_name=project_name,
-            feedback_stats=feedback_stats,
-            num_datapoints=num_datapoints,
-            experiment_id=experiment_id,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
-from humanloop.model.src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/project_sort_by.py` & `humanloop-0.4.9/humanloop/model/project_sort_by.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/project_sort_by.pyi` & `humanloop-0.4.9/humanloop/model/project_sort_by.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/project_user_response.py` & `humanloop-0.4.9/humanloop/model/project_user_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/project_user_response.pyi` & `humanloop-0.4.9/humanloop/model/project_user_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/projects_get_configs_response.py` & `humanloop-0.4.9/humanloop/model/projects_get_configs_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/projects_get_configs_response.pyi` & `humanloop-0.4.9/humanloop/model/projects_get_configs_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/projects_update_feedback_types_request.py` & `humanloop-0.4.9/humanloop/model/projects_update_feedback_types_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/projects_update_feedback_types_request.pyi` & `humanloop-0.4.9/humanloop/model/projects_update_feedback_types_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/provider_api_keys.py` & `humanloop-0.4.9/humanloop/model/provider_api_keys.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/provider_api_keys.pyi` & `humanloop-0.4.9/humanloop/model/provider_api_keys.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/session_project_response.py` & `humanloop-0.4.9/humanloop/model/session_project_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/session_project_response.pyi` & `humanloop-0.4.9/humanloop/model/session_project_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/session_response.py` & `humanloop-0.4.9/humanloop/model/tool_config_response.pyi`

 * *Files 26% similar despite different names*

```diff
@@ -19,146 +19,126 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SessionResponse(
+class ToolConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
         required = {
-            "projects",
-            "created_at",
-            "datapoints_count",
+            "name",
             "id",
+            "type",
         }
         
         class properties:
             id = schemas.StrSchema
             
             
-            class projects(
-                schemas.ListSchema
+            class type(
+                schemas.EnumBase,
+                schemas.StrSchema
             ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['SessionProjectResponse']:
-                        return SessionProjectResponse
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['SessionProjectResponse'], typing.List['SessionProjectResponse']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'projects':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'SessionProjectResponse':
-                    return super().__getitem__(i)
-            datapoints_count = schemas.IntSchema
-            created_at = schemas.DateTimeSchema
-            first_inputs = schemas.DictSchema
-            last_output = schemas.StrSchema
+                
+                @schemas.classproperty
+                def TOOL(cls):
+                    return cls("tool")
+            name = schemas.StrSchema
+            description = schemas.StrSchema
+            other = schemas.DictSchema
+            source = schemas.StrSchema
             __annotations__ = {
                 "id": id,
-                "projects": projects,
-                "datapoints_count": datapoints_count,
-                "created_at": created_at,
-                "first_inputs": first_inputs,
-                "last_output": last_output,
+                "type": type,
+                "name": name,
+                "description": description,
+                "other": other,
+                "source": source,
             }
     
-    projects: MetaOapg.properties.projects
-    created_at: MetaOapg.properties.created_at
-    datapoints_count: MetaOapg.properties.datapoints_count
+    name: MetaOapg.properties.name
     id: MetaOapg.properties.id
+    type: MetaOapg.properties.type
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
+    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["first_inputs"]) -> MetaOapg.properties.first_inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_output"]) -> MetaOapg.properties.last_output: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "description", "other", "source", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["first_inputs"]) -> typing.Union[MetaOapg.properties.first_inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_output"]) -> typing.Union[MetaOapg.properties.last_output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "description", "other", "source", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        projects: typing.Union[MetaOapg.properties.projects, list, tuple, ],
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        datapoints_count: typing.Union[MetaOapg.properties.datapoints_count, decimal.Decimal, int, ],
+        name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
-        first_inputs: typing.Union[MetaOapg.properties.first_inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        last_output: typing.Union[MetaOapg.properties.last_output, str, schemas.Unset] = schemas.unset,
+        type: typing.Union[MetaOapg.properties.type, str, ],
+        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
+        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SessionResponse':
+    ) -> 'ToolConfigResponse':
         return super().__new__(
             cls,
             *args,
-            projects=projects,
-            created_at=created_at,
-            datapoints_count=datapoints_count,
+            name=name,
             id=id,
-            first_inputs=first_inputs,
-            last_output=last_output,
+            type=type,
+            description=description,
+            other=other,
+            source=source,
             _configuration=_configuration,
             **kwargs,
         )
-
-from humanloop.model.session_project_response import SessionProjectResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/session_response.pyi` & `humanloop-0.4.9/humanloop/model/validation_error.py`

 * *Files 26% similar despite different names*

```diff
@@ -19,146 +19,147 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SessionResponse(
+class ValidationError(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
         required = {
-            "projects",
-            "created_at",
-            "datapoints_count",
-            "id",
+            "msg",
+            "loc",
+            "type",
         }
         
         class properties:
-            id = schemas.StrSchema
             
             
-            class projects(
+            class loc(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @staticmethod
-                    def items() -> typing.Type['SessionProjectResponse']:
-                        return SessionProjectResponse
+                    
+                    class items(
+                        schemas.ComposedSchema,
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            any_of_0 = schemas.StrSchema
+                            any_of_1 = schemas.IntSchema
+                            
+                            @classmethod
+                            @functools.lru_cache()
+                            def any_of(cls):
+                                # we need this here to make our import statements work
+                                # we must store _composed_schemas in here so the code is only run
+                                # when we invoke this method. If we kept this at the class
+                                # level we would get an error because the class level
+                                # code would be run when this module is imported, and these composed
+                                # classes don't exist yet because their module has not finished
+                                # loading
+                                return [
+                                    cls.any_of_0,
+                                    cls.any_of_1,
+                                ]
+                    
+                    
+                        def __new__(
+                            cls,
+                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                        ) -> 'items':
+                            return super().__new__(
+                                cls,
+                                *args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['SessionProjectResponse'], typing.List['SessionProjectResponse']],
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'projects':
+                ) -> 'loc':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
-                def __getitem__(self, i: int) -> 'SessionProjectResponse':
+                def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
-            datapoints_count = schemas.IntSchema
-            created_at = schemas.DateTimeSchema
-            first_inputs = schemas.DictSchema
-            last_output = schemas.StrSchema
+            msg = schemas.StrSchema
+            type = schemas.StrSchema
             __annotations__ = {
-                "id": id,
-                "projects": projects,
-                "datapoints_count": datapoints_count,
-                "created_at": created_at,
-                "first_inputs": first_inputs,
-                "last_output": last_output,
+                "loc": loc,
+                "msg": msg,
+                "type": type,
             }
     
-    projects: MetaOapg.properties.projects
-    created_at: MetaOapg.properties.created_at
-    datapoints_count: MetaOapg.properties.datapoints_count
-    id: MetaOapg.properties.id
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
+    msg: MetaOapg.properties.msg
+    loc: MetaOapg.properties.loc
+    type: MetaOapg.properties.type
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["first_inputs"]) -> MetaOapg.properties.first_inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["last_output"]) -> MetaOapg.properties.last_output: ...
+    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["projects"]) -> MetaOapg.properties.projects: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["datapoints_count"]) -> MetaOapg.properties.datapoints_count: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["first_inputs"]) -> typing.Union[MetaOapg.properties.first_inputs, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["last_output"]) -> typing.Union[MetaOapg.properties.last_output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "projects", "datapoints_count", "created_at", "first_inputs", "last_output", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        projects: typing.Union[MetaOapg.properties.projects, list, tuple, ],
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, ],
-        datapoints_count: typing.Union[MetaOapg.properties.datapoints_count, decimal.Decimal, int, ],
-        id: typing.Union[MetaOapg.properties.id, str, ],
-        first_inputs: typing.Union[MetaOapg.properties.first_inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        last_output: typing.Union[MetaOapg.properties.last_output, str, schemas.Unset] = schemas.unset,
+        msg: typing.Union[MetaOapg.properties.msg, str, ],
+        loc: typing.Union[MetaOapg.properties.loc, list, tuple, ],
+        type: typing.Union[MetaOapg.properties.type, str, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SessionResponse':
+    ) -> 'ValidationError':
         return super().__new__(
             cls,
             *args,
-            projects=projects,
-            created_at=created_at,
-            datapoints_count=datapoints_count,
-            id=id,
-            first_inputs=first_inputs,
-            last_output=last_output,
+            msg=msg,
+            loc=loc,
+            type=type,
             _configuration=_configuration,
             **kwargs,
         )
-
-from humanloop.model.session_project_response import SessionProjectResponse
```

### Comparing `humanloop-0.4.8/humanloop/model/sort_order.py` & `humanloop-0.4.9/humanloop/model/sort_order.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/sort_order.pyi` & `humanloop-0.4.9/humanloop/model/sort_order.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_model_config_response.py` & `humanloop-0.4.9/humanloop/model/src_external_app_models_v4_model_configs_model_config_response.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SrcExternalAppModelsV3ModelConfigsModelConfigResponse(
+class SrcExternalAppModelsV4ModelConfigsModelConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
     Extends the core ModelConfig request object to include Humanloop generated
 identifier and method for serializing response from ModelConfig domain object.
@@ -75,50 +75,82 @@
                 ) -> 'provider':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            max_tokens = schemas.IntSchema
+            temperature = schemas.NumberSchema
+            top_p = schemas.NumberSchema
             
             
-            class endpoint(
+            class stop(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.StrSchema
+                    
+                    
+                    class any_of_1(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'any_of_1':
+                            return super().__new__(
+                                cls,
+                                arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelEndpoints,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'endpoint':
+                ) -> 'stop':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            presence_penalty = schemas.NumberSchema
+            frequency_penalty = schemas.NumberSchema
+            other = schemas.DictSchema
+            display_name = schemas.StrSchema
             prompt_template = schemas.StrSchema
             
             
             class chat_template(
                 schemas.ListSchema
             ):
             
@@ -138,97 +170,65 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            temperature = schemas.NumberSchema
-            max_tokens = schemas.IntSchema
-            top_p = schemas.NumberSchema
             
             
-            class stop(
+            class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.StrSchema
-                    
-                    
-                    class any_of_1(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'any_of_1':
-                            return super().__new__(
-                                cls,
-                                arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ModelEndpoints,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'stop':
+                ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            presence_penalty = schemas.NumberSchema
-            frequency_penalty = schemas.NumberSchema
-            other = schemas.DictSchema
-            display_name = schemas.StrSchema
             __annotations__ = {
                 "model": model,
                 "id": id,
                 "provider": provider,
-                "endpoint": endpoint,
-                "prompt_template": prompt_template,
-                "chat_template": chat_template,
-                "temperature": temperature,
                 "max_tokens": max_tokens,
+                "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
                 "other": other,
                 "display_name": display_name,
+                "prompt_template": prompt_template,
+                "chat_template": chat_template,
+                "endpoint": endpoint,
             }
     
     model: MetaOapg.properties.model
     id: MetaOapg.properties.id
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
@@ -236,29 +236,20 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["temperature"]) -> MetaOapg.properties.temperature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["top_p"]) -> MetaOapg.properties.top_p: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["stop"]) -> MetaOapg.properties.stop: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
@@ -269,46 +260,46 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    
+    @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "prompt_template", "chat_template", "endpoint", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["temperature"]) -> typing.Union[MetaOapg.properties.temperature, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["top_p"]) -> typing.Union[MetaOapg.properties.top_p, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["stop"]) -> typing.Union[MetaOapg.properties.stop, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
@@ -319,57 +310,66 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> typing.Union[MetaOapg.properties.display_name, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "prompt_template", "chat_template", "endpoint", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
-        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         display_name: typing.Union[MetaOapg.properties.display_name, str, schemas.Unset] = schemas.unset,
+        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
+        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SrcExternalAppModelsV3ModelConfigsModelConfigResponse':
+    ) -> 'SrcExternalAppModelsV4ModelConfigsModelConfigResponse':
         return super().__new__(
             cls,
             *args,
             model=model,
             id=id,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             display_name=display_name,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
```

### Comparing `humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_model_config_response.pyi` & `humanloop-0.4.9/humanloop/model/src_external_app_models_v4_model_configs_model_config_response.pyi`

 * *Files 1% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SrcExternalAppModelsV3ModelConfigsModelConfigResponse(
+class SrcExternalAppModelsV4ModelConfigsModelConfigResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
     Extends the core ModelConfig request object to include Humanloop generated
 identifier and method for serializing response from ModelConfig domain object.
@@ -75,50 +75,82 @@
                 ) -> 'provider':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            max_tokens = schemas.IntSchema
+            temperature = schemas.NumberSchema
+            top_p = schemas.NumberSchema
             
             
-            class endpoint(
+            class stop(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
+                    any_of_0 = schemas.StrSchema
+                    
+                    
+                    class any_of_1(
+                        schemas.ListSchema
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            items = schemas.StrSchema
+                    
+                        def __new__(
+                            cls,
+                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                        ) -> 'any_of_1':
+                            return super().__new__(
+                                cls,
+                                arg,
+                                _configuration=_configuration,
+                            )
+                    
+                        def __getitem__(self, i: int) -> MetaOapg.items:
+                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def all_of(cls):
+                    def any_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            ModelEndpoints,
+                            cls.any_of_0,
+                            cls.any_of_1,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'endpoint':
+                ) -> 'stop':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            presence_penalty = schemas.NumberSchema
+            frequency_penalty = schemas.NumberSchema
+            other = schemas.DictSchema
+            display_name = schemas.StrSchema
             prompt_template = schemas.StrSchema
             
             
             class chat_template(
                 schemas.ListSchema
             ):
             
@@ -138,97 +170,65 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            temperature = schemas.NumberSchema
-            max_tokens = schemas.IntSchema
-            top_p = schemas.NumberSchema
             
             
-            class stop(
+            class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
-                    any_of_0 = schemas.StrSchema
-                    
-                    
-                    class any_of_1(
-                        schemas.ListSchema
-                    ):
-                    
-                    
-                        class MetaOapg:
-                            items = schemas.StrSchema
-                    
-                        def __new__(
-                            cls,
-                            arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                            _configuration: typing.Optional[schemas.Configuration] = None,
-                        ) -> 'any_of_1':
-                            return super().__new__(
-                                cls,
-                                arg,
-                                _configuration=_configuration,
-                            )
-                    
-                        def __getitem__(self, i: int) -> MetaOapg.items:
-                            return super().__getitem__(i)
                     
                     @classmethod
                     @functools.lru_cache()
-                    def any_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            cls.any_of_0,
-                            cls.any_of_1,
+                            ModelEndpoints,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'stop':
+                ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
-            presence_penalty = schemas.NumberSchema
-            frequency_penalty = schemas.NumberSchema
-            other = schemas.DictSchema
-            display_name = schemas.StrSchema
             __annotations__ = {
                 "model": model,
                 "id": id,
                 "provider": provider,
-                "endpoint": endpoint,
-                "prompt_template": prompt_template,
-                "chat_template": chat_template,
-                "temperature": temperature,
                 "max_tokens": max_tokens,
+                "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
                 "other": other,
                 "display_name": display_name,
+                "prompt_template": prompt_template,
+                "chat_template": chat_template,
+                "endpoint": endpoint,
             }
     
     model: MetaOapg.properties.model
     id: MetaOapg.properties.id
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
@@ -236,29 +236,20 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["temperature"]) -> MetaOapg.properties.temperature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["top_p"]) -> MetaOapg.properties.top_p: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["stop"]) -> MetaOapg.properties.stop: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
@@ -269,46 +260,46 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["display_name"]) -> MetaOapg.properties.display_name: ...
     
     @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    
+    @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "prompt_template", "chat_template", "endpoint", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["temperature"]) -> typing.Union[MetaOapg.properties.temperature, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["top_p"]) -> typing.Union[MetaOapg.properties.top_p, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["stop"]) -> typing.Union[MetaOapg.properties.stop, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
@@ -319,57 +310,66 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["display_name"]) -> typing.Union[MetaOapg.properties.display_name, schemas.Unset]: ...
     
     @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    
+    @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "endpoint", "prompt_template", "chat_template", "temperature", "max_tokens", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model", "id", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "other", "display_name", "prompt_template", "chat_template", "endpoint", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
-        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
-        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
         display_name: typing.Union[MetaOapg.properties.display_name, str, schemas.Unset] = schemas.unset,
+        prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
+        chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SrcExternalAppModelsV3ModelConfigsModelConfigResponse':
+    ) -> 'SrcExternalAppModelsV4ModelConfigsModelConfigResponse':
         return super().__new__(
             cls,
             *args,
             model=model,
             id=id,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             display_name=display_name,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
             _configuration=_configuration,
             **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
```

### Comparing `humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response.py` & `humanloop-0.4.9/humanloop/model/project_model_config_feedback_stats_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse(
+class ProjectModelConfigFeedbackStatsResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
@@ -100,15 +100,15 @@
         *args: typing.Union[dict, frozendict.frozendict, ],
         feedback_value: typing.Union[MetaOapg.properties.feedback_value, str, ],
         feedback_type_id: typing.Union[MetaOapg.properties.feedback_type_id, decimal.Decimal, int, ],
         feedback_type: typing.Union[MetaOapg.properties.feedback_type, str, ],
         feedback_count: typing.Union[MetaOapg.properties.feedback_count, decimal.Decimal, int, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse':
+    ) -> 'ProjectModelConfigFeedbackStatsResponse':
         return super().__new__(
             cls,
             *args,
             feedback_value=feedback_value,
             feedback_type_id=feedback_type_id,
             feedback_type=feedback_type,
             feedback_count=feedback_count,
```

### Comparing `humanloop-0.4.8/humanloop/model/src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response.pyi` & `humanloop-0.4.9/humanloop/model/project_model_config_feedback_stats_response.pyi`

 * *Files 5% similar despite different names*

```diff
@@ -19,15 +19,15 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse(
+class ProjectModelConfigFeedbackStatsResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
@@ -100,15 +100,15 @@
         *args: typing.Union[dict, frozendict.frozendict, ],
         feedback_value: typing.Union[MetaOapg.properties.feedback_value, str, ],
         feedback_type_id: typing.Union[MetaOapg.properties.feedback_type_id, decimal.Decimal, int, ],
         feedback_type: typing.Union[MetaOapg.properties.feedback_type, str, ],
         feedback_count: typing.Union[MetaOapg.properties.feedback_count, decimal.Decimal, int, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse':
+    ) -> 'ProjectModelConfigFeedbackStatsResponse':
         return super().__new__(
             cls,
             *args,
             feedback_value=feedback_value,
             feedback_type_id=feedback_type_id,
             feedback_type=feedback_type,
             feedback_count=feedback_count,
```

### Comparing `humanloop-0.4.8/humanloop/model/src_external_app_models_v4_configs_model_config_response.py` & `humanloop-0.4.9/humanloop/model/trace_model_config_request.py`

 * *Files 8% similar despite different names*

```diff
@@ -19,34 +19,43 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SrcExternalAppModelsV4ConfigsModelConfigResponse(
+class TraceModelConfigRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Model config request
+    Model config request that supports both chat and completion.
+
+Implemented here with the full set of fields from both
+ChatModelConfigRequest and CompletionModelConfigRequest.
+
+Ideally we'd use `Union[ChatModelConfigRequest, CompletionModelConfigRequest]`
+but that seems to cause Pydantic errors, especially with the `type` discriminator.
+
+Validation is done to ensure that only one of `chat_template` and
+`prompt_template` is provided, and that the provided one properly
+corresponds to the endpoint.
+This defaults to `complete` endpoint.
     """
 
 
     class MetaOapg:
         required = {
-            "name",
             "model",
-            "id",
             "type",
         }
         
         class properties:
-            id = schemas.StrSchema
+            model = schemas.StrSchema
             
             
             class type(
                 schemas.EnumBase,
                 schemas.StrSchema
             ):
             
@@ -55,18 +64,16 @@
                     enum_value_to_name = {
                         "model": "MODEL",
                     }
                 
                 @schemas.classproperty
                 def MODEL(cls):
                     return cls("model")
-            name = schemas.StrSchema
-            model = schemas.StrSchema
             description = schemas.StrSchema
-            other = schemas.DictSchema
+            name = schemas.StrSchema
             
             
             class provider(
                 schemas.ComposedSchema,
             ):
             
             
@@ -161,41 +168,15 @@
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             presence_penalty = schemas.NumberSchema
             frequency_penalty = schemas.NumberSchema
-            prompt_template = schemas.StrSchema
-            
-            
-            class chat_template(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'chat_template':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'ChatMessage':
-                    return super().__getitem__(i)
+            other = schemas.DictSchema
             
             
             class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
@@ -224,55 +205,74 @@
                 ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            prompt_template = schemas.StrSchema
+            
+            
+            class chat_template(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'chat_template':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
             __annotations__ = {
-                "id": id,
-                "type": type,
-                "name": name,
                 "model": model,
+                "type": type,
                 "description": description,
-                "other": other,
+                "name": name,
                 "provider": provider,
                 "max_tokens": max_tokens,
                 "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
+                "other": other,
+                "endpoint": endpoint,
                 "prompt_template": prompt_template,
                 "chat_template": chat_template,
-                "endpoint": endpoint,
             }
+        additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
     model: MetaOapg.properties.model
-    id: MetaOapg.properties.id
     type: MetaOapg.properties.type
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
@@ -288,47 +288,40 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["frequency_penalty"]) -> MetaOapg.properties.frequency_penalty: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
     
     @typing.overload
-    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model"], typing_extensions.Literal["type"], typing_extensions.Literal["description"], typing_extensions.Literal["name"], typing_extensions.Literal["provider"], typing_extensions.Literal["max_tokens"], typing_extensions.Literal["temperature"], typing_extensions.Literal["top_p"], typing_extensions.Literal["stop"], typing_extensions.Literal["presence_penalty"], typing_extensions.Literal["frequency_penalty"], typing_extensions.Literal["other"], typing_extensions.Literal["endpoint"], typing_extensions.Literal["prompt_template"], typing_extensions.Literal["chat_template"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
@@ -344,70 +337,65 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["frequency_penalty"]) -> typing.Union[MetaOapg.properties.frequency_penalty, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model"], typing_extensions.Literal["type"], typing_extensions.Literal["description"], typing_extensions.Literal["name"], typing_extensions.Literal["provider"], typing_extensions.Literal["max_tokens"], typing_extensions.Literal["temperature"], typing_extensions.Literal["top_p"], typing_extensions.Literal["stop"], typing_extensions.Literal["presence_penalty"], typing_extensions.Literal["frequency_penalty"], typing_extensions.Literal["other"], typing_extensions.Literal["endpoint"], typing_extensions.Literal["prompt_template"], typing_extensions.Literal["chat_template"], ]):
         return super().get_item_oapg(name)
-    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, ],
         type: typing.Union[MetaOapg.properties.type, str, ],
         description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
-        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
         chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SrcExternalAppModelsV4ConfigsModelConfigResponse':
+    ) -> 'TraceModelConfigRequest':
         return super().__new__(
             cls,
             *args,
-            name=name,
             model=model,
-            id=id,
             type=type,
             description=description,
-            other=other,
+            name=name,
             provider=provider,
             max_tokens=max_tokens,
             temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
+            other=other,
+            endpoint=endpoint,
             prompt_template=prompt_template,
             chat_template=chat_template,
-            endpoint=endpoint,
             _configuration=_configuration,
-            **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
```

### Comparing `humanloop-0.4.8/humanloop/model/src_external_app_models_v4_configs_model_config_response.pyi` & `humanloop-0.4.9/humanloop/model/trace_model_config_request.pyi`

 * *Files 11% similar despite different names*

```diff
@@ -19,48 +19,55 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class SrcExternalAppModelsV4ConfigsModelConfigResponse(
+class TraceModelConfigRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Model config request
+    Model config request that supports both chat and completion.
+
+Implemented here with the full set of fields from both
+ChatModelConfigRequest and CompletionModelConfigRequest.
+
+Ideally we'd use `Union[ChatModelConfigRequest, CompletionModelConfigRequest]`
+but that seems to cause Pydantic errors, especially with the `type` discriminator.
+
+Validation is done to ensure that only one of `chat_template` and
+`prompt_template` is provided, and that the provided one properly
+corresponds to the endpoint.
+This defaults to `complete` endpoint.
     """
 
 
     class MetaOapg:
         required = {
-            "name",
             "model",
-            "id",
             "type",
         }
         
         class properties:
-            id = schemas.StrSchema
+            model = schemas.StrSchema
             
             
             class type(
                 schemas.EnumBase,
                 schemas.StrSchema
             ):
                 
                 @schemas.classproperty
                 def MODEL(cls):
                     return cls("model")
-            name = schemas.StrSchema
-            model = schemas.StrSchema
             description = schemas.StrSchema
-            other = schemas.DictSchema
+            name = schemas.StrSchema
             
             
             class provider(
                 schemas.ComposedSchema,
             ):
             
             
@@ -155,41 +162,15 @@
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
             presence_penalty = schemas.NumberSchema
             frequency_penalty = schemas.NumberSchema
-            prompt_template = schemas.StrSchema
-            
-            
-            class chat_template(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    
-                    @staticmethod
-                    def items() -> typing.Type['ChatMessage']:
-                        return ChatMessage
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'chat_template':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'ChatMessage':
-                    return super().__getitem__(i)
+            other = schemas.DictSchema
             
             
             class endpoint(
                 schemas.ComposedSchema,
             ):
             
             
@@ -218,55 +199,74 @@
                 ) -> 'endpoint':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            prompt_template = schemas.StrSchema
+            
+            
+            class chat_template(
+                schemas.ListSchema
+            ):
+            
+            
+                class MetaOapg:
+                    
+                    @staticmethod
+                    def items() -> typing.Type['ChatMessage']:
+                        return ChatMessage
+            
+                def __new__(
+                    cls,
+                    arg: typing.Union[typing.Tuple['ChatMessage'], typing.List['ChatMessage']],
+                    _configuration: typing.Optional[schemas.Configuration] = None,
+                ) -> 'chat_template':
+                    return super().__new__(
+                        cls,
+                        arg,
+                        _configuration=_configuration,
+                    )
+            
+                def __getitem__(self, i: int) -> 'ChatMessage':
+                    return super().__getitem__(i)
             __annotations__ = {
-                "id": id,
-                "type": type,
-                "name": name,
                 "model": model,
+                "type": type,
                 "description": description,
-                "other": other,
+                "name": name,
                 "provider": provider,
                 "max_tokens": max_tokens,
                 "temperature": temperature,
                 "top_p": top_p,
                 "stop": stop,
                 "presence_penalty": presence_penalty,
                 "frequency_penalty": frequency_penalty,
+                "other": other,
+                "endpoint": endpoint,
                 "prompt_template": prompt_template,
                 "chat_template": chat_template,
-                "endpoint": endpoint,
             }
+        additional_properties = schemas.NotAnyTypeSchema
     
-    name: MetaOapg.properties.name
     model: MetaOapg.properties.model
-    id: MetaOapg.properties.id
     type: MetaOapg.properties.type
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
+    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["provider"]) -> MetaOapg.properties.provider: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["max_tokens"]) -> MetaOapg.properties.max_tokens: ...
     
@@ -282,47 +282,40 @@
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["presence_penalty"]) -> MetaOapg.properties.presence_penalty: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["frequency_penalty"]) -> MetaOapg.properties.frequency_penalty: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
+    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["endpoint"]) -> MetaOapg.properties.endpoint: ...
+    def __getitem__(self, name: typing_extensions.Literal["prompt_template"]) -> MetaOapg.properties.prompt_template: ...
     
     @typing.overload
-    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
+    def __getitem__(self, name: typing_extensions.Literal["chat_template"]) -> MetaOapg.properties.chat_template: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model"], typing_extensions.Literal["type"], typing_extensions.Literal["description"], typing_extensions.Literal["name"], typing_extensions.Literal["provider"], typing_extensions.Literal["max_tokens"], typing_extensions.Literal["temperature"], typing_extensions.Literal["top_p"], typing_extensions.Literal["stop"], typing_extensions.Literal["presence_penalty"], typing_extensions.Literal["frequency_penalty"], typing_extensions.Literal["other"], typing_extensions.Literal["endpoint"], typing_extensions.Literal["prompt_template"], typing_extensions.Literal["chat_template"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
-    
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["model"]) -> MetaOapg.properties.model: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["provider"]) -> typing.Union[MetaOapg.properties.provider, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["max_tokens"]) -> typing.Union[MetaOapg.properties.max_tokens, schemas.Unset]: ...
     
@@ -338,70 +331,65 @@
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["presence_penalty"]) -> typing.Union[MetaOapg.properties.presence_penalty, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["frequency_penalty"]) -> typing.Union[MetaOapg.properties.frequency_penalty, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["endpoint"]) -> typing.Union[MetaOapg.properties.endpoint, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["prompt_template"]) -> typing.Union[MetaOapg.properties.prompt_template, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["chat_template"]) -> typing.Union[MetaOapg.properties.chat_template, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "model", "description", "other", "provider", "max_tokens", "temperature", "top_p", "stop", "presence_penalty", "frequency_penalty", "prompt_template", "chat_template", "endpoint", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model"], typing_extensions.Literal["type"], typing_extensions.Literal["description"], typing_extensions.Literal["name"], typing_extensions.Literal["provider"], typing_extensions.Literal["max_tokens"], typing_extensions.Literal["temperature"], typing_extensions.Literal["top_p"], typing_extensions.Literal["stop"], typing_extensions.Literal["presence_penalty"], typing_extensions.Literal["frequency_penalty"], typing_extensions.Literal["other"], typing_extensions.Literal["endpoint"], typing_extensions.Literal["prompt_template"], typing_extensions.Literal["chat_template"], ]):
         return super().get_item_oapg(name)
-    
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, ],
         model: typing.Union[MetaOapg.properties.model, str, ],
-        id: typing.Union[MetaOapg.properties.id, str, ],
         type: typing.Union[MetaOapg.properties.type, str, ],
         description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
-        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
         provider: typing.Union[MetaOapg.properties.provider, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         max_tokens: typing.Union[MetaOapg.properties.max_tokens, decimal.Decimal, int, schemas.Unset] = schemas.unset,
         temperature: typing.Union[MetaOapg.properties.temperature, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         top_p: typing.Union[MetaOapg.properties.top_p, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         stop: typing.Union[MetaOapg.properties.stop, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         presence_penalty: typing.Union[MetaOapg.properties.presence_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
         frequency_penalty: typing.Union[MetaOapg.properties.frequency_penalty, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
+        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
+        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         prompt_template: typing.Union[MetaOapg.properties.prompt_template, str, schemas.Unset] = schemas.unset,
         chat_template: typing.Union[MetaOapg.properties.chat_template, list, tuple, schemas.Unset] = schemas.unset,
-        endpoint: typing.Union[MetaOapg.properties.endpoint, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'SrcExternalAppModelsV4ConfigsModelConfigResponse':
+    ) -> 'TraceModelConfigRequest':
         return super().__new__(
             cls,
             *args,
-            name=name,
             model=model,
-            id=id,
             type=type,
             description=description,
-            other=other,
+            name=name,
             provider=provider,
             max_tokens=max_tokens,
             temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
+            other=other,
+            endpoint=endpoint,
             prompt_template=prompt_template,
             chat_template=chat_template,
-            endpoint=endpoint,
             _configuration=_configuration,
-            **kwargs,
         )
 
 from humanloop.model.chat_message import ChatMessage
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
```

### Comparing `humanloop-0.4.8/humanloop/model/tool_config_request.py` & `humanloop-0.4.9/humanloop/model/tool_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/tool_config_request.pyi` & `humanloop-0.4.9/humanloop/model/tool_config_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/tool_config_response.py` & `humanloop-0.4.9/humanloop/model/tool_config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/tool_config_response.pyi` & `humanloop-0.4.9/humanloop/model/tool_result_response.py`

 * *Files 24% similar despite different names*

```diff
@@ -19,126 +19,101 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class ToolConfigResponse(
+class ToolResultResponse(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
+
+    A result from a tool used to populate the prompt template
     """
 
 
     class MetaOapg:
         required = {
+            "result",
+            "signature",
             "name",
             "id",
-            "type",
         }
         
         class properties:
             id = schemas.StrSchema
-            
-            
-            class type(
-                schemas.EnumBase,
-                schemas.StrSchema
-            ):
-                
-                @schemas.classproperty
-                def TOOL(cls):
-                    return cls("tool")
             name = schemas.StrSchema
-            description = schemas.StrSchema
-            other = schemas.DictSchema
-            source = schemas.StrSchema
+            signature = schemas.StrSchema
+            result = schemas.StrSchema
             __annotations__ = {
                 "id": id,
-                "type": type,
                 "name": name,
-                "description": description,
-                "other": other,
-                "source": source,
+                "signature": signature,
+                "result": result,
             }
     
+    result: MetaOapg.properties.result
+    signature: MetaOapg.properties.signature
     name: MetaOapg.properties.name
     id: MetaOapg.properties.id
-    type: MetaOapg.properties.type
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
-    
-    @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["description"]) -> MetaOapg.properties.description: ...
-    
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["other"]) -> MetaOapg.properties.other: ...
+    def __getitem__(self, name: typing_extensions.Literal["signature"]) -> MetaOapg.properties.signature: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["result"]) -> MetaOapg.properties.result: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "description", "other", "source", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["id", "name", "signature", "result", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["id"]) -> MetaOapg.properties.id: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
-    
-    @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["description"]) -> typing.Union[MetaOapg.properties.description, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["other"]) -> typing.Union[MetaOapg.properties.other, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["signature"]) -> MetaOapg.properties.signature: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["result"]) -> MetaOapg.properties.result: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "type", "name", "description", "other", "source", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["id", "name", "signature", "result", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
+        result: typing.Union[MetaOapg.properties.result, str, ],
+        signature: typing.Union[MetaOapg.properties.signature, str, ],
         name: typing.Union[MetaOapg.properties.name, str, ],
         id: typing.Union[MetaOapg.properties.id, str, ],
-        type: typing.Union[MetaOapg.properties.type, str, ],
-        description: typing.Union[MetaOapg.properties.description, str, schemas.Unset] = schemas.unset,
-        other: typing.Union[MetaOapg.properties.other, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'ToolConfigResponse':
+    ) -> 'ToolResultResponse':
         return super().__new__(
             cls,
             *args,
+            result=result,
+            signature=signature,
             name=name,
             id=id,
-            type=type,
-            description=description,
-            other=other,
-            source=source,
             _configuration=_configuration,
             **kwargs,
         )
```

### Comparing `humanloop-0.4.8/humanloop/model/tool_result_response.py` & `humanloop-0.4.9/humanloop/model/tool_result_response.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/trace_log_request.py` & `humanloop-0.4.9/humanloop/model/chat_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -19,36 +19,31 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class TraceLogRequest(
+class ChatRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Simplified version of LogRequest.
-
-Changes:
-    - Renamed `project` to `function_name`. TODO: Allow either `function_name` or `function_id`.
+    Base chat request.
     """
 
 
     class MetaOapg:
         required = {
-            "function_name",
+            "model_config",
+            "messages",
         }
         
         class properties:
-            function_name = schemas.StrSchema
-            trial_id = schemas.StrSchema
-            inputs = schemas.DictSchema
             
             
             class messages(
                 schemas.ListSchema
             ):
             
             
@@ -67,215 +62,254 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            output = schemas.StrSchema
-            source = schemas.StrSchema
             
             
-            class config(
+            class model_config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def one_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TraceModelConfigRequest,
-                            ToolConfigRequest,
-                            GenericConfigRequest,
-                            AgentConfigRequest,
+                            ModelConfigChatRequest,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'config':
+                ) -> 'model_config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
+            inputs = schemas.DictSchema
+            source = schemas.StrSchema
             metadata = schemas.DictSchema
-            error = schemas.StrSchema
-            duration = schemas.NumberSchema
-            created_at = schemas.DateTimeSchema
             
             
-            class children(
-                schemas.ListSchema
+            class provider_api_keys(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    @staticmethod
-                    def items() -> typing.Type['TraceLogRequest']:
-                        return TraceLogRequest
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProviderApiKeys,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['TraceLogRequest'], typing.List['TraceLogRequest']],
+                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'children':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'provider_api_keys':
                     return super().__new__(
                         cls,
-                        arg,
+                        *args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> 'TraceLogRequest':
-                    return super().__getitem__(i)
+            num_samples = schemas.IntSchema
+            stream = schemas.BoolSchema
+            user = schemas.StrSchema
             __annotations__ = {
-                "function_name": function_name,
-                "trial_id": trial_id,
-                "inputs": inputs,
                 "messages": messages,
-                "output": output,
+                "model_config": model_config,
+                "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
+                "inputs": inputs,
                 "source": source,
-                "config": config,
                 "metadata": metadata,
-                "error": error,
-                "duration": duration,
-                "created_at": created_at,
-                "children": children,
+                "provider_api_keys": provider_api_keys,
+                "num_samples": num_samples,
+                "stream": stream,
+                "user": user,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    function_name: MetaOapg.properties.function_name
+    model_config: MetaOapg.properties.model_config
+    messages: MetaOapg.properties.messages
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
+    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["error"]) -> MetaOapg.properties.error: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["children"]) -> MetaOapg.properties.children: ...
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["error"]) -> typing.Union[MetaOapg.properties.error, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> typing.Union[MetaOapg.properties.duration, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["children"]) -> typing.Union[MetaOapg.properties.children, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        function_name: typing.Union[MetaOapg.properties.function_name, str, ],
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
         inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
-        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
-        duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
-        children: typing.Union[MetaOapg.properties.children, list, tuple, schemas.Unset] = schemas.unset,
+        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
+        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TraceLogRequest':
+    ) -> 'ChatRequest':
         return super().__new__(
             cls,
             *args,
-            function_name=function_name,
-            trial_id=trial_id,
-            inputs=inputs,
+            model_config=model_config,
             messages=messages,
-            output=output,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
-            config=config,
             metadata=metadata,
-            error=error,
-            duration=duration,
-            created_at=created_at,
-            children=children,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            stream=stream,
+            user=user,
             _configuration=_configuration,
         )
 
-from humanloop.model.agent_config_request import AgentConfigRequest
 from humanloop.model.chat_message import ChatMessage
-from humanloop.model.generic_config_request import GenericConfigRequest
-from humanloop.model.tool_config_request import ToolConfigRequest
-from humanloop.model.trace_model_config_request import TraceModelConfigRequest
+from humanloop.model.model_config_chat_request import ModelConfigChatRequest
+from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/trace_log_request.pyi` & `humanloop-0.4.9/humanloop/model/chat_request.pyi`

 * *Files 19% similar despite different names*

```diff
@@ -19,36 +19,31 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class TraceLogRequest(
+class ChatRequest(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
 
-    Simplified version of LogRequest.
-
-Changes:
-    - Renamed `project` to `function_name`. TODO: Allow either `function_name` or `function_id`.
+    Base chat request.
     """
 
 
     class MetaOapg:
         required = {
-            "function_name",
+            "model_config",
+            "messages",
         }
         
         class properties:
-            function_name = schemas.StrSchema
-            trial_id = schemas.StrSchema
-            inputs = schemas.DictSchema
             
             
             class messages(
                 schemas.ListSchema
             ):
             
             
@@ -67,215 +62,254 @@
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> 'ChatMessage':
                     return super().__getitem__(i)
-            output = schemas.StrSchema
-            source = schemas.StrSchema
             
             
-            class config(
+            class model_config(
                 schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
                     @classmethod
                     @functools.lru_cache()
-                    def one_of(cls):
+                    def all_of(cls):
                         # we need this here to make our import statements work
                         # we must store _composed_schemas in here so the code is only run
                         # when we invoke this method. If we kept this at the class
                         # level we would get an error because the class level
                         # code would be run when this module is imported, and these composed
                         # classes don't exist yet because their module has not finished
                         # loading
                         return [
-                            TraceModelConfigRequest,
-                            ToolConfigRequest,
-                            GenericConfigRequest,
-                            AgentConfigRequest,
+                            ModelConfigChatRequest,
                         ]
             
             
                 def __new__(
                     cls,
                     *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
                     **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-                ) -> 'config':
+                ) -> 'model_config':
                     return super().__new__(
                         cls,
                         *args,
                         _configuration=_configuration,
                         **kwargs,
                     )
+            project = schemas.StrSchema
+            project_id = schemas.StrSchema
+            session_id = schemas.StrSchema
+            session_reference_id = schemas.StrSchema
+            parent_id = schemas.StrSchema
+            parent_reference_id = schemas.StrSchema
+            inputs = schemas.DictSchema
+            source = schemas.StrSchema
             metadata = schemas.DictSchema
-            error = schemas.StrSchema
-            duration = schemas.NumberSchema
-            created_at = schemas.DateTimeSchema
             
             
-            class children(
-                schemas.ListSchema
+            class provider_api_keys(
+                schemas.ComposedSchema,
             ):
             
             
                 class MetaOapg:
                     
-                    @staticmethod
-                    def items() -> typing.Type['TraceLogRequest']:
-                        return TraceLogRequest
+                    @classmethod
+                    @functools.lru_cache()
+                    def all_of(cls):
+                        # we need this here to make our import statements work
+                        # we must store _composed_schemas in here so the code is only run
+                        # when we invoke this method. If we kept this at the class
+                        # level we would get an error because the class level
+                        # code would be run when this module is imported, and these composed
+                        # classes don't exist yet because their module has not finished
+                        # loading
+                        return [
+                            ProviderApiKeys,
+                        ]
+            
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple['TraceLogRequest'], typing.List['TraceLogRequest']],
+                    *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'children':
+                    **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                ) -> 'provider_api_keys':
                     return super().__new__(
                         cls,
-                        arg,
+                        *args,
                         _configuration=_configuration,
+                        **kwargs,
                     )
-            
-                def __getitem__(self, i: int) -> 'TraceLogRequest':
-                    return super().__getitem__(i)
+            num_samples = schemas.IntSchema
+            stream = schemas.BoolSchema
+            user = schemas.StrSchema
             __annotations__ = {
-                "function_name": function_name,
-                "trial_id": trial_id,
-                "inputs": inputs,
                 "messages": messages,
-                "output": output,
+                "model_config": model_config,
+                "project": project,
+                "project_id": project_id,
+                "session_id": session_id,
+                "session_reference_id": session_reference_id,
+                "parent_id": parent_id,
+                "parent_reference_id": parent_reference_id,
+                "inputs": inputs,
                 "source": source,
-                "config": config,
                 "metadata": metadata,
-                "error": error,
-                "duration": duration,
-                "created_at": created_at,
-                "children": children,
+                "provider_api_keys": provider_api_keys,
+                "num_samples": num_samples,
+                "stream": stream,
+                "user": user,
             }
         additional_properties = schemas.NotAnyTypeSchema
     
-    function_name: MetaOapg.properties.function_name
+    model_config: MetaOapg.properties.model_config
+    messages: MetaOapg.properties.messages
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
+    def __getitem__(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["trial_id"]) -> MetaOapg.properties.trial_id: ...
+    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
+    def __getitem__(self, name: typing_extensions.Literal["project"]) -> MetaOapg.properties.project: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
+    def __getitem__(self, name: typing_extensions.Literal["project_id"]) -> MetaOapg.properties.project_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["output"]) -> MetaOapg.properties.output: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_id"]) -> MetaOapg.properties.session_id: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
+    def __getitem__(self, name: typing_extensions.Literal["session_reference_id"]) -> MetaOapg.properties.session_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_id"]) -> MetaOapg.properties.parent_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["parent_reference_id"]) -> MetaOapg.properties.parent_reference_id: ...
+    
+    @typing.overload
+    def __getitem__(self, name: typing_extensions.Literal["inputs"]) -> MetaOapg.properties.inputs: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config"]) -> MetaOapg.properties.config: ...
+    def __getitem__(self, name: typing_extensions.Literal["source"]) -> MetaOapg.properties.source: ...
     
     @typing.overload
     def __getitem__(self, name: typing_extensions.Literal["metadata"]) -> MetaOapg.properties.metadata: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["error"]) -> MetaOapg.properties.error: ...
+    def __getitem__(self, name: typing_extensions.Literal["provider_api_keys"]) -> MetaOapg.properties.provider_api_keys: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["duration"]) -> MetaOapg.properties.duration: ...
+    def __getitem__(self, name: typing_extensions.Literal["num_samples"]) -> MetaOapg.properties.num_samples: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["created_at"]) -> MetaOapg.properties.created_at: ...
+    def __getitem__(self, name: typing_extensions.Literal["stream"]) -> MetaOapg.properties.stream: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["children"]) -> MetaOapg.properties.children: ...
+    def __getitem__(self, name: typing_extensions.Literal["user"]) -> MetaOapg.properties.user: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["function_name"]) -> MetaOapg.properties.function_name: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["model_config"]) -> MetaOapg.properties.model_config: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["trial_id"]) -> typing.Union[MetaOapg.properties.trial_id, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> MetaOapg.properties.messages: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project"]) -> typing.Union[MetaOapg.properties.project, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["messages"]) -> typing.Union[MetaOapg.properties.messages, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["project_id"]) -> typing.Union[MetaOapg.properties.project_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["output"]) -> typing.Union[MetaOapg.properties.output, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_id"]) -> typing.Union[MetaOapg.properties.session_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["session_reference_id"]) -> typing.Union[MetaOapg.properties.session_reference_id, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config"]) -> typing.Union[MetaOapg.properties.config, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_id"]) -> typing.Union[MetaOapg.properties.parent_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["parent_reference_id"]) -> typing.Union[MetaOapg.properties.parent_reference_id, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["inputs"]) -> typing.Union[MetaOapg.properties.inputs, schemas.Unset]: ...
+    
+    @typing.overload
+    def get_item_oapg(self, name: typing_extensions.Literal["source"]) -> typing.Union[MetaOapg.properties.source, schemas.Unset]: ...
     
     @typing.overload
     def get_item_oapg(self, name: typing_extensions.Literal["metadata"]) -> typing.Union[MetaOapg.properties.metadata, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["error"]) -> typing.Union[MetaOapg.properties.error, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["provider_api_keys"]) -> typing.Union[MetaOapg.properties.provider_api_keys, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["duration"]) -> typing.Union[MetaOapg.properties.duration, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["num_samples"]) -> typing.Union[MetaOapg.properties.num_samples, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["created_at"]) -> typing.Union[MetaOapg.properties.created_at, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["stream"]) -> typing.Union[MetaOapg.properties.stream, schemas.Unset]: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["children"]) -> typing.Union[MetaOapg.properties.children, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["user"]) -> typing.Union[MetaOapg.properties.user, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["function_name"], typing_extensions.Literal["trial_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["messages"], typing_extensions.Literal["output"], typing_extensions.Literal["source"], typing_extensions.Literal["config"], typing_extensions.Literal["metadata"], typing_extensions.Literal["error"], typing_extensions.Literal["duration"], typing_extensions.Literal["created_at"], typing_extensions.Literal["children"], ]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["model_config"], typing_extensions.Literal["messages"], typing_extensions.Literal["project"], typing_extensions.Literal["project_id"], typing_extensions.Literal["session_id"], typing_extensions.Literal["session_reference_id"], typing_extensions.Literal["parent_id"], typing_extensions.Literal["parent_reference_id"], typing_extensions.Literal["inputs"], typing_extensions.Literal["source"], typing_extensions.Literal["metadata"], typing_extensions.Literal["provider_api_keys"], typing_extensions.Literal["num_samples"], typing_extensions.Literal["stream"], typing_extensions.Literal["user"], ]):
         return super().get_item_oapg(name)
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        function_name: typing.Union[MetaOapg.properties.function_name, str, ],
-        trial_id: typing.Union[MetaOapg.properties.trial_id, str, schemas.Unset] = schemas.unset,
+        model_config: typing.Union[MetaOapg.properties.model_config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+        messages: typing.Union[MetaOapg.properties.messages, list, tuple, ],
+        project: typing.Union[MetaOapg.properties.project, str, schemas.Unset] = schemas.unset,
+        project_id: typing.Union[MetaOapg.properties.project_id, str, schemas.Unset] = schemas.unset,
+        session_id: typing.Union[MetaOapg.properties.session_id, str, schemas.Unset] = schemas.unset,
+        session_reference_id: typing.Union[MetaOapg.properties.session_reference_id, str, schemas.Unset] = schemas.unset,
+        parent_id: typing.Union[MetaOapg.properties.parent_id, str, schemas.Unset] = schemas.unset,
+        parent_reference_id: typing.Union[MetaOapg.properties.parent_reference_id, str, schemas.Unset] = schemas.unset,
         inputs: typing.Union[MetaOapg.properties.inputs, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        messages: typing.Union[MetaOapg.properties.messages, list, tuple, schemas.Unset] = schemas.unset,
-        output: typing.Union[MetaOapg.properties.output, str, schemas.Unset] = schemas.unset,
         source: typing.Union[MetaOapg.properties.source, str, schemas.Unset] = schemas.unset,
-        config: typing.Union[MetaOapg.properties.config, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
         metadata: typing.Union[MetaOapg.properties.metadata, dict, frozendict.frozendict, schemas.Unset] = schemas.unset,
-        error: typing.Union[MetaOapg.properties.error, str, schemas.Unset] = schemas.unset,
-        duration: typing.Union[MetaOapg.properties.duration, decimal.Decimal, int, float, schemas.Unset] = schemas.unset,
-        created_at: typing.Union[MetaOapg.properties.created_at, str, datetime, schemas.Unset] = schemas.unset,
-        children: typing.Union[MetaOapg.properties.children, list, tuple, schemas.Unset] = schemas.unset,
+        provider_api_keys: typing.Union[MetaOapg.properties.provider_api_keys, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
+        num_samples: typing.Union[MetaOapg.properties.num_samples, decimal.Decimal, int, schemas.Unset] = schemas.unset,
+        stream: typing.Union[MetaOapg.properties.stream, bool, schemas.Unset] = schemas.unset,
+        user: typing.Union[MetaOapg.properties.user, str, schemas.Unset] = schemas.unset,
         _configuration: typing.Optional[schemas.Configuration] = None,
-    ) -> 'TraceLogRequest':
+    ) -> 'ChatRequest':
         return super().__new__(
             cls,
             *args,
-            function_name=function_name,
-            trial_id=trial_id,
-            inputs=inputs,
+            model_config=model_config,
             messages=messages,
-            output=output,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
             source=source,
-            config=config,
             metadata=metadata,
-            error=error,
-            duration=duration,
-            created_at=created_at,
-            children=children,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            stream=stream,
+            user=user,
             _configuration=_configuration,
         )
 
-from humanloop.model.agent_config_request import AgentConfigRequest
 from humanloop.model.chat_message import ChatMessage
-from humanloop.model.generic_config_request import GenericConfigRequest
-from humanloop.model.tool_config_request import ToolConfigRequest
-from humanloop.model.trace_model_config_request import TraceModelConfigRequest
+from humanloop.model.model_config_chat_request import ModelConfigChatRequest
+from humanloop.model.provider_api_keys import ProviderApiKeys
```

### Comparing `humanloop-0.4.8/humanloop/model/update_experiment_request.py` & `humanloop-0.4.9/humanloop/model/validation_error.pyi`

 * *Files 21% similar despite different names*

```diff
@@ -19,159 +19,147 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 
-class UpdateExperimentRequest(
+class ValidationError(
     schemas.DictSchema
 ):
     """
     This class is auto generated by Konfig (https://konfigthis.com)
     """
 
 
     class MetaOapg:
+        required = {
+            "msg",
+            "loc",
+            "type",
+        }
         
         class properties:
-            name = schemas.StrSchema
             
             
-            class positive_labels(
+            class loc(
                 schemas.ListSchema
             ):
             
             
                 class MetaOapg:
                     
-                    @staticmethod
-                    def items() -> typing.Type['PositiveLabel']:
-                        return PositiveLabel
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple['PositiveLabel'], typing.List['PositiveLabel']],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'positive_labels':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> 'PositiveLabel':
-                    return super().__getitem__(i)
-            
-            
-            class config_ids_to_register(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.StrSchema
-            
-                def __new__(
-                    cls,
-                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
-                    _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'config_ids_to_register':
-                    return super().__new__(
-                        cls,
-                        arg,
-                        _configuration=_configuration,
-                    )
-            
-                def __getitem__(self, i: int) -> MetaOapg.items:
-                    return super().__getitem__(i)
-            
-            
-            class config_ids_to_deregister(
-                schemas.ListSchema
-            ):
-            
-            
-                class MetaOapg:
-                    items = schemas.StrSchema
+                    
+                    class items(
+                        schemas.ComposedSchema,
+                    ):
+                    
+                    
+                        class MetaOapg:
+                            any_of_0 = schemas.StrSchema
+                            any_of_1 = schemas.IntSchema
+                            
+                            @classmethod
+                            @functools.lru_cache()
+                            def any_of(cls):
+                                # we need this here to make our import statements work
+                                # we must store _composed_schemas in here so the code is only run
+                                # when we invoke this method. If we kept this at the class
+                                # level we would get an error because the class level
+                                # code would be run when this module is imported, and these composed
+                                # classes don't exist yet because their module has not finished
+                                # loading
+                                return [
+                                    cls.any_of_0,
+                                    cls.any_of_1,
+                                ]
+                    
+                    
+                        def __new__(
+                            cls,
+                            *args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
+                            _configuration: typing.Optional[schemas.Configuration] = None,
+                            **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
+                        ) -> 'items':
+                            return super().__new__(
+                                cls,
+                                *args,
+                                _configuration=_configuration,
+                                **kwargs,
+                            )
             
                 def __new__(
                     cls,
-                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, str, ]], typing.List[typing.Union[MetaOapg.items, str, ]]],
+                    arg: typing.Union[typing.Tuple[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]], typing.List[typing.Union[MetaOapg.items, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ]]],
                     _configuration: typing.Optional[schemas.Configuration] = None,
-                ) -> 'config_ids_to_deregister':
+                ) -> 'loc':
                     return super().__new__(
                         cls,
                         arg,
                         _configuration=_configuration,
                     )
             
                 def __getitem__(self, i: int) -> MetaOapg.items:
                     return super().__getitem__(i)
+            msg = schemas.StrSchema
+            type = schemas.StrSchema
             __annotations__ = {
-                "name": name,
-                "positive_labels": positive_labels,
-                "config_ids_to_register": config_ids_to_register,
-                "config_ids_to_deregister": config_ids_to_deregister,
+                "loc": loc,
+                "msg": msg,
+                "type": type,
             }
     
-    @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["name"]) -> MetaOapg.properties.name: ...
+    msg: MetaOapg.properties.msg
+    loc: MetaOapg.properties.loc
+    type: MetaOapg.properties.type
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["positive_labels"]) -> MetaOapg.properties.positive_labels: ...
+    def __getitem__(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config_ids_to_register"]) -> MetaOapg.properties.config_ids_to_register: ...
+    def __getitem__(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
     
     @typing.overload
-    def __getitem__(self, name: typing_extensions.Literal["config_ids_to_deregister"]) -> MetaOapg.properties.config_ids_to_deregister: ...
+    def __getitem__(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
     def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
     
-    def __getitem__(self, name: typing.Union[typing_extensions.Literal["name", "positive_labels", "config_ids_to_register", "config_ids_to_deregister", ], str]):
+    def __getitem__(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
         # dict_instance[name] accessor
         return super().__getitem__(name)
     
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["name"]) -> typing.Union[MetaOapg.properties.name, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["loc"]) -> MetaOapg.properties.loc: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["positive_labels"]) -> typing.Union[MetaOapg.properties.positive_labels, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["msg"]) -> MetaOapg.properties.msg: ...
     
     @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config_ids_to_register"]) -> typing.Union[MetaOapg.properties.config_ids_to_register, schemas.Unset]: ...
-    
-    @typing.overload
-    def get_item_oapg(self, name: typing_extensions.Literal["config_ids_to_deregister"]) -> typing.Union[MetaOapg.properties.config_ids_to_deregister, schemas.Unset]: ...
+    def get_item_oapg(self, name: typing_extensions.Literal["type"]) -> MetaOapg.properties.type: ...
     
     @typing.overload
     def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
     
-    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["name", "positive_labels", "config_ids_to_register", "config_ids_to_deregister", ], str]):
+    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["loc", "msg", "type", ], str]):
         return super().get_item_oapg(name)
     
 
     def __new__(
         cls,
         *args: typing.Union[dict, frozendict.frozendict, ],
-        name: typing.Union[MetaOapg.properties.name, str, schemas.Unset] = schemas.unset,
-        positive_labels: typing.Union[MetaOapg.properties.positive_labels, list, tuple, schemas.Unset] = schemas.unset,
-        config_ids_to_register: typing.Union[MetaOapg.properties.config_ids_to_register, list, tuple, schemas.Unset] = schemas.unset,
-        config_ids_to_deregister: typing.Union[MetaOapg.properties.config_ids_to_deregister, list, tuple, schemas.Unset] = schemas.unset,
+        msg: typing.Union[MetaOapg.properties.msg, str, ],
+        loc: typing.Union[MetaOapg.properties.loc, list, tuple, ],
+        type: typing.Union[MetaOapg.properties.type, str, ],
         _configuration: typing.Optional[schemas.Configuration] = None,
         **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
-    ) -> 'UpdateExperimentRequest':
+    ) -> 'ValidationError':
         return super().__new__(
             cls,
             *args,
-            name=name,
-            positive_labels=positive_labels,
-            config_ids_to_register=config_ids_to_register,
-            config_ids_to_deregister=config_ids_to_deregister,
+            msg=msg,
+            loc=loc,
+            type=type,
             _configuration=_configuration,
             **kwargs,
         )
-
-from humanloop.model.positive_label import PositiveLabel
```

### Comparing `humanloop-0.4.8/humanloop/model/update_log_request.py` & `humanloop-0.4.9/humanloop/model/update_log_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/update_log_request.pyi` & `humanloop-0.4.9/humanloop/model/update_log_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/update_project_request.py` & `humanloop-0.4.9/humanloop/model/update_project_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/update_project_request.pyi` & `humanloop-0.4.9/humanloop/model/update_project_request.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/usage.py` & `humanloop-0.4.9/humanloop/model/usage.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/model/usage.pyi` & `humanloop-0.4.9/humanloop/model/usage.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/models/__init__.py` & `humanloop-0.4.9/humanloop/models/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -67,29 +67,27 @@
 from humanloop.model.model_endpoints import ModelEndpoints
 from humanloop.model.model_providers import ModelProviders
 from humanloop.model.paginated_data_log_response import PaginatedDataLogResponse
 from humanloop.model.paginated_data_project_response import PaginatedDataProjectResponse
 from humanloop.model.paginated_data_session_response import PaginatedDataSessionResponse
 from humanloop.model.positive_label import PositiveLabel
 from humanloop.model.project_config_response import ProjectConfigResponse
+from humanloop.model.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
 from humanloop.model.project_model_config_request import ProjectModelConfigRequest
-from humanloop.model.project_model_config_response import ProjectModelConfigResponse
 from humanloop.model.project_response import ProjectResponse
 from humanloop.model.project_sort_by import ProjectSortBy
 from humanloop.model.project_user_response import ProjectUserResponse
 from humanloop.model.projects_get_configs_response import ProjectsGetConfigsResponse
 from humanloop.model.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest
 from humanloop.model.provider_api_keys import ProviderApiKeys
 from humanloop.model.session_project_response import SessionProjectResponse
 from humanloop.model.session_response import SessionResponse
 from humanloop.model.sort_order import SortOrder
-from humanloop.model.src_external_app_models_v3_model_configs_model_config_response import SrcExternalAppModelsV3ModelConfigsModelConfigResponse
-from humanloop.model.src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse
 from humanloop.model.src_external_app_models_v4_configs_model_config_response import SrcExternalAppModelsV4ConfigsModelConfigResponse
-from humanloop.model.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.model.src_external_app_models_v4_model_configs_model_config_response import SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 from humanloop.model.tool_config_request import ToolConfigRequest
 from humanloop.model.tool_config_response import ToolConfigResponse
 from humanloop.model.tool_result_response import ToolResultResponse
 from humanloop.model.trace_log_request import TraceLogRequest
 from humanloop.model.trace_model_config_request import TraceModelConfigRequest
 from humanloop.model.update_experiment_request import UpdateExperimentRequest
 from humanloop.model.update_log_request import UpdateLogRequest
```

### Comparing `humanloop-0.4.8/humanloop/paths/__init__.py` & `humanloop-0.4.9/humanloop/paths/__init__.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/chat/post.py` & `humanloop-0.4.9/humanloop/paths/model_configs/post.pyi`

 * *Files 9% similar despite different names*

```diff
@@ -27,55 +27,50 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.model_config_chat_request import ModelConfigChatRequest as ModelConfigChatRequestSchema
+from humanloop.model.model_providers import ModelProviders as ModelProvidersSchema
+from humanloop.model.project_model_config_request import ProjectModelConfigRequest as ProjectModelConfigRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.chat_request import ChatRequest as ChatRequestSchema
-from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
+from humanloop.model.model_endpoints import ModelEndpoints as ModelEndpointsSchema
+from humanloop.model.project_config_response import ProjectConfigResponse as ProjectConfigResponseSchema
 from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
 
-from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_request import ChatRequest
-from humanloop.type.chat_response import ChatResponse
+from humanloop.type.project_model_config_request import ProjectModelConfigRequest
+from humanloop.type.model_providers import ModelProviders
+from humanloop.type.project_config_response import ProjectConfigResponse
 from humanloop.type.http_validation_error import HTTPValidationError
-from humanloop.type.model_config_chat_request import ModelConfigChatRequest
-
-from . import path
+from humanloop.type.model_endpoints import ModelEndpoints
 
 # body param
-SchemaForRequestBodyApplicationJson = ChatRequestSchema
+SchemaForRequestBodyApplicationJson = ProjectModelConfigRequestSchema
 
 
-request_body_chat_request = api_client.RequestBody(
+request_body_project_model_config_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
-SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
+SchemaFor200ResponseBodyApplicationJson = ProjectConfigResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ChatResponse
+    body: ProjectConfigResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ChatResponse
+    body: ProjectConfigResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -99,78 +94,89 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_mapped_args(
+    def _register_mapped_args(
         self,
+        model: str,
         project: str,
-        messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider: typing.Optional[ModelProviders] = None,
+        max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
+        top_p: typing.Optional[typing.Union[int, float]] = None,
+        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
+        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
+        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
+        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        name: typing.Optional[str] = None,
+        experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
+        if provider is not None:
+            _body["provider"] = provider
+        if model is not None:
+            _body["model"] = model
+        if max_tokens is not None:
+            _body["max_tokens"] = max_tokens
+        if temperature is not None:
+            _body["temperature"] = temperature
+        if top_p is not None:
+            _body["top_p"] = top_p
+        if stop is not None:
+            _body["stop"] = stop
+        if presence_penalty is not None:
+            _body["presence_penalty"] = presence_penalty
+        if frequency_penalty is not None:
+            _body["frequency_penalty"] = frequency_penalty
+        if other is not None:
+            _body["other"] = other
         if project is not None:
             _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if stream is not None:
-            _body["stream"] = stream
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if model_config is not None:
-            _body["model_config"] = model_config
+        if name is not None:
+            _body["name"] = name
+        if experiment is not None:
+            _body["experiment"] = experiment
+        if prompt_template is not None:
+            _body["prompt_template"] = prompt_template
+        if chat_template is not None:
+            _body["chat_template"] = chat_template
+        if endpoint is not None:
+            _body["endpoint"] = endpoint
         args.body = _body
         return args
 
-    async def _aresponse_oapg(
+    async def _aregister_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat
+        Register Model Config
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -190,15 +196,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_request.serialize(body, content_type)
+        serialized_data = request_body_project_model_config_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -261,28 +267,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_oapg(
+    def _register_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat
+        Register Model Config
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -302,15 +308,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_request.serialize(body, content_type)
+        serialized_data = request_body_project_model_config_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -343,143 +349,183 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Response(BaseApi):
+class Register(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse(
+    async def aregister(
         self,
+        model: str,
         project: str,
-        messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider: typing.Optional[ModelProviders] = None,
+        max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
+        top_p: typing.Optional[typing.Union[int, float]] = None,
+        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
+        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
+        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
+        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        name: typing.Optional[str] = None,
+        experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_mapped_args(
+        args = self._register_mapped_args(
+            model=model,
             project=project,
-            messages=messages,
-            model_config=model_config,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            provider=provider,
+            max_tokens=max_tokens,
+            temperature=temperature,
+            top_p=top_p,
+            stop=stop,
+            presence_penalty=presence_penalty,
+            frequency_penalty=frequency_penalty,
+            other=other,
+            name=name,
+            experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
-        return await self._aresponse_oapg(
+        return await self._aregister_oapg(
             body=args.body,
         )
     
-    def response(
+    def register(
         self,
+        model: str,
         project: str,
-        messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider: typing.Optional[ModelProviders] = None,
+        max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
+        top_p: typing.Optional[typing.Union[int, float]] = None,
+        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
+        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
+        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
+        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        name: typing.Optional[str] = None,
+        experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_mapped_args(
+        args = self._register_mapped_args(
+            model=model,
             project=project,
-            messages=messages,
-            model_config=model_config,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            provider=provider,
+            max_tokens=max_tokens,
+            temperature=temperature,
+            top_p=top_p,
+            stop=stop,
+            presence_penalty=presence_penalty,
+            frequency_penalty=frequency_penalty,
+            other=other,
+            name=name,
+            experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
-        return self._response_oapg(
+        return self._register_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
+        model: str,
         project: str,
-        messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider: typing.Optional[ModelProviders] = None,
+        max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
+        top_p: typing.Optional[typing.Union[int, float]] = None,
+        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
+        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
+        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
+        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        name: typing.Optional[str] = None,
+        experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_mapped_args(
+        args = self._register_mapped_args(
+            model=model,
             project=project,
-            messages=messages,
-            model_config=model_config,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            provider=provider,
+            max_tokens=max_tokens,
+            temperature=temperature,
+            top_p=top_p,
+            stop=stop,
+            presence_penalty=presence_penalty,
+            frequency_penalty=frequency_penalty,
+            other=other,
+            name=name,
+            experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
-        return await self._aresponse_oapg(
+        return await self._aregister_oapg(
             body=args.body,
         )
     
     def post(
         self,
+        model: str,
         project: str,
-        messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider: typing.Optional[ModelProviders] = None,
+        max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
+        top_p: typing.Optional[typing.Union[int, float]] = None,
+        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
+        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
+        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
+        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        name: typing.Optional[str] = None,
+        experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_mapped_args(
+        args = self._register_mapped_args(
+            model=model,
             project=project,
-            messages=messages,
-            model_config=model_config,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+            provider=provider,
+            max_tokens=max_tokens,
+            temperature=temperature,
+            top_p=top_p,
+            stop=stop,
+            presence_penalty=presence_penalty,
+            frequency_penalty=frequency_penalty,
+            other=other,
+            name=name,
+            experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
-        return self._response_oapg(
+        return self._register_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat/post.pyi` & `humanloop-0.4.9/humanloop/paths/chat_experiment/post.pyi`

 * *Files 12% similar despite different names*

```diff
@@ -27,33 +27,31 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.model_config_chat_request import ModelConfigChatRequest as ModelConfigChatRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
+from humanloop.model.chat_experiment_request import ChatExperimentRequest as ChatExperimentRequestSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.chat_request import ChatRequest as ChatRequestSchema
 from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
 from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
 
 from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_request import ChatRequest
+from humanloop.type.chat_experiment_request import ChatExperimentRequest
 from humanloop.type.chat_response import ChatResponse
 from humanloop.type.http_validation_error import HTTPValidationError
-from humanloop.type.model_config_chat_request import ModelConfigChatRequest
 
 # body param
-SchemaForRequestBodyApplicationJson = ChatRequestSchema
+SchemaForRequestBodyApplicationJson = ChatExperimentRequestSchema
 
 
-request_body_chat_request = api_client.RequestBody(
+request_body_chat_experiment_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
 SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
@@ -101,67 +99,82 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_mapped_args(
+    def _response_experiment_mapped_args(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if messages is not None:
+            _body["messages"] = messages
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if stream is not None:
             _body["stream"] = stream
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if model_config is not None:
-            _body["model_config"] = model_config
+        if experiment_id is not None:
+            _body["experiment_id"] = experiment_id
         args.body = _body
         return args
 
-    async def _aresponse_oapg(
+    async def _aresponse_experiment_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat
+        Chat Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -181,15 +194,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_request.serialize(body, content_type)
+        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -252,28 +265,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_oapg(
+    def _response_experiment_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat
+        Chat Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -293,15 +306,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_request.serialize(body, content_type)
+        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -334,143 +347,183 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Response(BaseApi):
+class ResponseExperiment(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse(
+    async def aresponse_experiment(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_mapped_args(
-            project=project,
+        args = self._response_experiment_mapped_args(
             messages=messages,
-            model_config=model_config,
+            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_oapg(
+        return await self._aresponse_experiment_oapg(
             body=args.body,
         )
     
-    def response(
+    def response_experiment(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_mapped_args(
-            project=project,
+        args = self._response_experiment_mapped_args(
             messages=messages,
-            model_config=model_config,
+            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_oapg(
+        return self._response_experiment_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_mapped_args(
-            project=project,
+        args = self._response_experiment_mapped_args(
             messages=messages,
-            model_config=model_config,
+            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_oapg(
+        return await self._aresponse_experiment_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config: ModelConfigChatRequest,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_mapped_args(
-            project=project,
+        args = self._response_experiment_mapped_args(
             messages=messages,
-            model_config=model_config,
+            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_oapg(
+        return self._response_experiment_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat_deployed/post.py` & `humanloop-0.4.9/humanloop/paths/completion_deployed/post.py`

 * *Files 11% similar despite different names*

```diff
@@ -27,53 +27,51 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
+from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
-from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
-from humanloop.model.chat_deployed_request import ChatDeployedRequest as ChatDeployedRequestSchema
+from humanloop.model.completion_deployed_request import CompletionDeployedRequest as CompletionDeployedRequestSchema
 
+from humanloop.type.completion_deployed_request import CompletionDeployedRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_deployed_request import ChatDeployedRequest
-from humanloop.type.chat_response import ChatResponse
+from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
 # body param
-SchemaForRequestBodyApplicationJson = ChatDeployedRequestSchema
+SchemaForRequestBodyApplicationJson = CompletionDeployedRequestSchema
 
 
-request_body_chat_deployed_request = api_client.RequestBody(
+request_body_completion_deployed_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
+SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ChatResponse
+    body: CompletionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ChatResponse
+    body: CompletionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -108,64 +106,82 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_deployed_mapped_args(
+    def _create_deployed_mapped_args(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
+        if logprobs is not None:
+            _body["logprobs"] = logprobs
         if stream is not None:
             _body["stream"] = stream
+        if suffix is not None:
+            _body["suffix"] = suffix
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
         args.body = _body
         return args
 
-    async def _aresponse_deployed_oapg(
+    async def _acreate_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat Deployed
+        Completion Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -185,15 +201,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
+        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -256,28 +272,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_deployed_oapg(
+    def _create_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat Deployed
+        Completion Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -297,15 +313,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
+        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -338,135 +354,183 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ResponseDeployed(BaseApi):
+class CreateDeployed(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse_deployed(
+    async def acreate_deployed(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_deployed_oapg(
+        return await self._acreate_deployed_oapg(
             body=args.body,
         )
     
-    def response_deployed(
+    def create_deployed(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return self._response_deployed_oapg(
+        return self._create_deployed_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_deployed_oapg(
+        return await self._acreate_deployed_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return self._response_deployed_oapg(
+        return self._create_deployed_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat_deployed/post.pyi` & `humanloop-0.4.9/humanloop/paths/completion_deployed/post.pyi`

 * *Files 11% similar despite different names*

```diff
@@ -27,48 +27,46 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
+from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
-from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
-from humanloop.model.chat_deployed_request import ChatDeployedRequest as ChatDeployedRequestSchema
+from humanloop.model.completion_deployed_request import CompletionDeployedRequest as CompletionDeployedRequestSchema
 
+from humanloop.type.completion_deployed_request import CompletionDeployedRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_deployed_request import ChatDeployedRequest
-from humanloop.type.chat_response import ChatResponse
+from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 # body param
-SchemaForRequestBodyApplicationJson = ChatDeployedRequestSchema
+SchemaForRequestBodyApplicationJson = CompletionDeployedRequestSchema
 
 
-request_body_chat_deployed_request = api_client.RequestBody(
+request_body_completion_deployed_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
+SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ChatResponse
+    body: CompletionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ChatResponse
+    body: CompletionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -99,64 +97,82 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_deployed_mapped_args(
+    def _create_deployed_mapped_args(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
+        if logprobs is not None:
+            _body["logprobs"] = logprobs
         if stream is not None:
             _body["stream"] = stream
+        if suffix is not None:
+            _body["suffix"] = suffix
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
         args.body = _body
         return args
 
-    async def _aresponse_deployed_oapg(
+    async def _acreate_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat Deployed
+        Completion Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -176,15 +192,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
+        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -247,28 +263,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_deployed_oapg(
+    def _create_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat Deployed
+        Completion Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -288,15 +304,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
+        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -329,135 +345,183 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ResponseDeployed(BaseApi):
+class CreateDeployed(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse_deployed(
+    async def acreate_deployed(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_deployed_oapg(
+        return await self._acreate_deployed_oapg(
             body=args.body,
         )
     
-    def response_deployed(
+    def create_deployed(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return self._response_deployed_oapg(
+        return self._create_deployed_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_deployed_oapg(
+        return await self._acreate_deployed_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_deployed_mapped_args(
+        args = self._create_deployed_mapped_args(
             project=project,
-            messages=messages,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
+            logprobs=logprobs,
             stream=stream,
+            suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return self._response_deployed_oapg(
+        return self._create_deployed_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat_experiment/post.py` & `humanloop-0.4.9/humanloop/paths/chat_deployed/post.pyi`

 * *Files 12% similar despite different names*

```diff
@@ -28,41 +28,36 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.chat_experiment_request import ChatExperimentRequest as ChatExperimentRequestSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
 from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
 from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
+from humanloop.model.chat_deployed_request import ChatDeployedRequest as ChatDeployedRequestSchema
 
 from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_experiment_request import ChatExperimentRequest
+from humanloop.type.chat_deployed_request import ChatDeployedRequest
 from humanloop.type.chat_response import ChatResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
-
 # body param
-SchemaForRequestBodyApplicationJson = ChatExperimentRequestSchema
+SchemaForRequestBodyApplicationJson = ChatDeployedRequestSchema
 
 
-request_body_chat_experiment_request = api_client.RequestBody(
+request_body_chat_deployed_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
 SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: ChatResponse
 
@@ -97,78 +92,86 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_experiment_mapped_args(
+    def _response_deployed_mapped_args(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if messages is not None:
+            _body["messages"] = messages
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if stream is not None:
             _body["stream"] = stream
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if experiment_id is not None:
-            _body["experiment_id"] = experiment_id
         args.body = _body
         return args
 
-    async def _aresponse_experiment_oapg(
+    async def _aresponse_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat Experiment
+        Chat Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -188,15 +191,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -259,28 +262,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_experiment_oapg(
+    def _response_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat Experiment
+        Chat Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -300,15 +303,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -341,143 +344,175 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ResponseExperiment(BaseApi):
+class ResponseDeployed(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse_experiment(
+    async def aresponse_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_experiment_oapg(
+        return await self._aresponse_deployed_oapg(
             body=args.body,
         )
     
-    def response_experiment(
+    def response_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_experiment_oapg(
+        return self._response_deployed_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_experiment_oapg(
+        return await self._aresponse_deployed_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_experiment_oapg(
+        return self._response_deployed_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat_experiment/post.pyi` & `humanloop-0.4.9/humanloop/paths/chat_deployed/post.py`

 * *Files 12% similar despite different names*

```diff
@@ -28,36 +28,41 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.chat_experiment_request import ChatExperimentRequest as ChatExperimentRequestSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
 from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
 from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
+from humanloop.model.chat_deployed_request import ChatDeployedRequest as ChatDeployedRequestSchema
 
 from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_experiment_request import ChatExperimentRequest
+from humanloop.type.chat_deployed_request import ChatDeployedRequest
 from humanloop.type.chat_response import ChatResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
+from . import path
+
 # body param
-SchemaForRequestBodyApplicationJson = ChatExperimentRequestSchema
+SchemaForRequestBodyApplicationJson = ChatDeployedRequestSchema
 
 
-request_body_chat_experiment_request = api_client.RequestBody(
+request_body_chat_deployed_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
+_auth = [
+    'APIKeyHeader',
+]
 SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: ChatResponse
 
@@ -92,74 +97,90 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_experiment_mapped_args(
+    def _response_deployed_mapped_args(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if messages is not None:
+            _body["messages"] = messages
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if stream is not None:
             _body["stream"] = stream
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if experiment_id is not None:
-            _body["experiment_id"] = experiment_id
         args.body = _body
         return args
 
-    async def _aresponse_experiment_oapg(
+    async def _aresponse_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat Experiment
+        Chat Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -179,15 +200,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -250,28 +271,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_experiment_oapg(
+    def _response_deployed_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat Experiment
+        Chat Deployed
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -291,15 +312,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_chat_deployed_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -332,143 +353,175 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ResponseExperiment(BaseApi):
+class ResponseDeployed(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse_experiment(
+    async def aresponse_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_experiment_oapg(
+        return await self._aresponse_deployed_oapg(
             body=args.body,
         )
     
-    def response_experiment(
+    def response_deployed(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_experiment_oapg(
+        return self._response_deployed_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_experiment_oapg(
+        return await self._aresponse_deployed_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_experiment_mapped_args(
-            project=project,
+        args = self._response_deployed_mapped_args(
             messages=messages,
-            experiment_id=experiment_id,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_experiment_oapg(
+        return self._response_deployed_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat_model_config/post.py` & `humanloop-0.4.9/humanloop/paths/chat/post.pyi`

 * *Files 15% similar despite different names*

```diff
@@ -27,42 +27,39 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
+from humanloop.model.model_config_chat_request import ModelConfigChatRequest as ModelConfigChatRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.chat_model_config_request import ChatModelConfigRequest as ChatModelConfigRequestSchema
+from humanloop.model.chat_request import ChatRequest as ChatRequestSchema
 from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
 from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
 
-from humanloop.type.chat_model_config_request import ChatModelConfigRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.chat_message import ChatMessage
+from humanloop.type.chat_request import ChatRequest
 from humanloop.type.chat_response import ChatResponse
 from humanloop.type.http_validation_error import HTTPValidationError
-
-from . import path
+from humanloop.type.model_config_chat_request import ModelConfigChatRequest
 
 # body param
-SchemaForRequestBodyApplicationJson = ChatModelConfigRequestSchema
+SchemaForRequestBodyApplicationJson = ChatRequestSchema
 
 
-request_body_chat_model_config_request = api_client.RequestBody(
+request_body_chat_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
 SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: ChatResponse
 
@@ -97,78 +94,89 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_model_configuration_mapped_args(
+    def _response_mapped_args(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config_id: str,
+        model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if messages is not None:
+            _body["messages"] = messages
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if stream is not None:
             _body["stream"] = stream
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if model_config_id is not None:
-            _body["model_config_id"] = model_config_id
+        if model_config is not None:
+            _body["model_config"] = model_config
         args.body = _body
         return args
 
-    async def _aresponse_model_configuration_oapg(
+    async def _aresponse_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat Model Config
+        Chat
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -188,15 +196,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_chat_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -259,28 +267,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_model_configuration_oapg(
+    def _response_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat Model Config
+        Chat
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -300,15 +308,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_chat_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -341,143 +349,183 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ResponseModelConfiguration(BaseApi):
+class Response(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse_model_configuration(
+    async def aresponse(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config_id: str,
+        model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
+        args = self._response_mapped_args(
             messages=messages,
-            model_config_id=model_config_id,
+            model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_model_configuration_oapg(
+        return await self._aresponse_oapg(
             body=args.body,
         )
     
-    def response_model_configuration(
+    def response(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config_id: str,
+        model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
+        args = self._response_mapped_args(
             messages=messages,
-            model_config_id=model_config_id,
+            model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_model_configuration_oapg(
+        return self._response_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config_id: str,
+        model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
+        args = self._response_mapped_args(
             messages=messages,
-            model_config_id=model_config_id,
+            model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return await self._aresponse_model_configuration_oapg(
+        return await self._aresponse_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
         messages: typing.List[ChatMessage],
-        model_config_id: str,
+        model_config: ModelConfigChatRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
+        args = self._response_mapped_args(
             messages=messages,
-            model_config_id=model_config_id,
+            model_config=model_config,
+            project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             stream=stream,
             user=user,
-            metadata=metadata,
         )
-        return self._response_model_configuration_oapg(
+        return self._response_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/chat_model_config/post.pyi` & `humanloop-0.4.9/humanloop/paths/experiments_experiment_id/patch.pyi`

 * *Files 14% similar despite different names*

```diff
@@ -28,47 +28,71 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.chat_model_config_request import ChatModelConfigRequest as ChatModelConfigRequestSchema
-from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
-from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
-
-from humanloop.type.chat_model_config_request import ChatModelConfigRequest
-from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.chat_response import ChatResponse
+from humanloop.model.update_experiment_request import UpdateExperimentRequest as UpdateExperimentRequestSchema
+from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
+from humanloop.model.experiment_response import ExperimentResponse as ExperimentResponseSchema
+
+from humanloop.type.experiment_response import ExperimentResponse
+from humanloop.type.positive_label import PositiveLabel
+from humanloop.type.update_experiment_request import UpdateExperimentRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
+# Path params
+ExperimentIdSchema = schemas.StrSchema
+RequestRequiredPathParams = typing_extensions.TypedDict(
+    'RequestRequiredPathParams',
+    {
+        'experiment_id': typing.Union[ExperimentIdSchema, str, ],
+    }
+)
+RequestOptionalPathParams = typing_extensions.TypedDict(
+    'RequestOptionalPathParams',
+    {
+    },
+    total=False
+)
+
+
+class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
+    pass
+
+
+request_path_experiment_id = api_client.PathParameter(
+    name="experiment_id",
+    style=api_client.ParameterStyle.SIMPLE,
+    schema=ExperimentIdSchema,
+    required=True,
+)
 # body param
-SchemaForRequestBodyApplicationJson = ChatModelConfigRequestSchema
+SchemaForRequestBodyApplicationJson = UpdateExperimentRequestSchema
 
 
-request_body_chat_model_config_request = api_client.RequestBody(
+request_body_update_experiment_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
+SchemaFor200ResponseBodyApplicationJson = ExperimentResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ChatResponse
+    body: ExperimentResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ChatResponse
+    body: ExperimentResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -99,79 +123,81 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _response_model_configuration_mapped_args(
+    def _update_mapped_args(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
-        model_config_id: str,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        experiment_id: str,
+        name: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        config_ids_to_register: typing.Optional[typing.List[str]] = None,
+        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
+        _path_params = {}
         _body = {}
-        if project is not None:
-            _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if messages is not None:
-            _body["messages"] = messages
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if stream is not None:
-            _body["stream"] = stream
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if model_config_id is not None:
-            _body["model_config_id"] = model_config_id
+        if name is not None:
+            _body["name"] = name
+        if positive_labels is not None:
+            _body["positive_labels"] = positive_labels
+        if config_ids_to_register is not None:
+            _body["config_ids_to_register"] = config_ids_to_register
+        if config_ids_to_deregister is not None:
+            _body["config_ids_to_deregister"] = config_ids_to_deregister
         args.body = _body
+        if experiment_id is not None:
+            _path_params["experiment_id"] = experiment_id
+        args.path = _path_params
         return args
 
-    async def _aresponse_model_configuration_oapg(
+    async def _aupdate_oapg(
         self,
         body: typing.Any = None,
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Chat Model Config
+        Update Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_experiment_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -179,15 +205,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_update_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -250,40 +276,55 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _response_model_configuration_oapg(
+    def _update_oapg(
         self,
         body: typing.Any = None,
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Chat Model Config
+        Update Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_experiment_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -291,15 +332,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_chat_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_update_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -332,143 +373,107 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ResponseModelConfiguration(BaseApi):
+class Update(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aresponse_model_configuration(
+    async def aupdate(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
-        model_config_id: str,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        experiment_id: str,
+        name: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        config_ids_to_register: typing.Optional[typing.List[str]] = None,
+        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
-            messages=messages,
-            model_config_id=model_config_id,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            experiment_id=experiment_id,
+            name=name,
+            positive_labels=positive_labels,
+            config_ids_to_register=config_ids_to_register,
+            config_ids_to_deregister=config_ids_to_deregister,
         )
-        return await self._aresponse_model_configuration_oapg(
+        return await self._aupdate_oapg(
             body=args.body,
+            path_params=args.path,
         )
     
-    def response_model_configuration(
+    def update(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
-        model_config_id: str,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        experiment_id: str,
+        name: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        config_ids_to_register: typing.Optional[typing.List[str]] = None,
+        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
-            messages=messages,
-            model_config_id=model_config_id,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            experiment_id=experiment_id,
+            name=name,
+            positive_labels=positive_labels,
+            config_ids_to_register=config_ids_to_register,
+            config_ids_to_deregister=config_ids_to_deregister,
         )
-        return self._response_model_configuration_oapg(
+        return self._update_oapg(
             body=args.body,
+            path_params=args.path,
         )
 
-class ApiForpost(BaseApi):
+class ApiForpatch(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apost(
+    async def apatch(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
-        model_config_id: str,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        experiment_id: str,
+        name: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        config_ids_to_register: typing.Optional[typing.List[str]] = None,
+        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
-            messages=messages,
-            model_config_id=model_config_id,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            experiment_id=experiment_id,
+            name=name,
+            positive_labels=positive_labels,
+            config_ids_to_register=config_ids_to_register,
+            config_ids_to_deregister=config_ids_to_deregister,
         )
-        return await self._aresponse_model_configuration_oapg(
+        return await self._aupdate_oapg(
             body=args.body,
+            path_params=args.path,
         )
     
-    def post(
+    def patch(
         self,
-        project: str,
-        messages: typing.List[ChatMessage],
-        model_config_id: str,
-        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        experiment_id: str,
+        name: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        config_ids_to_register: typing.Optional[typing.List[str]] = None,
+        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._response_model_configuration_mapped_args(
-            project=project,
-            messages=messages,
-            model_config_id=model_config_id,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            stream=stream,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            experiment_id=experiment_id,
+            name=name,
+            positive_labels=positive_labels,
+            config_ids_to_register=config_ids_to_register,
+            config_ids_to_deregister=config_ids_to_deregister,
         )
-        return self._response_model_configuration_oapg(
+        return self._update_oapg(
             body=args.body,
+            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion/post.py` & `humanloop-0.4.9/humanloop/paths/projects_id/patch.pyi`

 * *Files 16% similar despite different names*

```diff
@@ -27,53 +27,72 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
-from humanloop.model.model_config_completion_request import ModelConfigCompletionRequest as ModelConfigCompletionRequestSchema
+from humanloop.model.project_response import ProjectResponse as ProjectResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.completion_request import CompletionRequest as CompletionRequestSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
+from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
+from humanloop.model.update_project_request import UpdateProjectRequest as UpdateProjectRequestSchema
 
-from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.model_config_completion_request import ModelConfigCompletionRequest
-from humanloop.type.completion_request import CompletionRequest
-from humanloop.type.completion_response import CompletionResponse
+from humanloop.type.project_response import ProjectResponse
+from humanloop.type.positive_label import PositiveLabel
+from humanloop.type.update_project_request import UpdateProjectRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
+# Path params
+IdSchema = schemas.StrSchema
+RequestRequiredPathParams = typing_extensions.TypedDict(
+    'RequestRequiredPathParams',
+    {
+        'id': typing.Union[IdSchema, str, ],
+    }
+)
+RequestOptionalPathParams = typing_extensions.TypedDict(
+    'RequestOptionalPathParams',
+    {
+    },
+    total=False
+)
+
+
+class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
+    pass
+
 
+request_path_id = api_client.PathParameter(
+    name="id",
+    style=api_client.ParameterStyle.SIMPLE,
+    schema=IdSchema,
+    required=True,
+)
 # body param
-SchemaForRequestBodyApplicationJson = CompletionRequestSchema
+SchemaForRequestBodyApplicationJson = UpdateProjectRequestSchema
 
 
-request_body_completion_request = api_client.RequestBody(
+request_body_update_project_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
-SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
+SchemaFor200ResponseBodyApplicationJson = ProjectResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: CompletionResponse
+    body: ProjectResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: CompletionResponse
+    body: ProjectResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -97,93 +116,85 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_mapped_args(
+    def _update_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config: ModelConfigCompletionRequest,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
+        _path_params = {}
         _body = {}
-        if project is not None:
-            _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if logprobs is not None:
-            _body["logprobs"] = logprobs
-        if stream is not None:
-            _body["stream"] = stream
-        if suffix is not None:
-            _body["suffix"] = suffix
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if model_config is not None:
-            _body["model_config"] = model_config
+        if active_experiment_id is not None:
+            _body["active_experiment_id"] = active_experiment_id
+        if active_config_id is not None:
+            _body["active_config_id"] = active_config_id
+        if positive_labels is not None:
+            _body["positive_labels"] = positive_labels
         args.body = _body
+        if id is not None:
+            _path_params["id"] = id
+        args.path = _path_params
         return args
 
-    async def _acreate_oapg(
+    async def _aupdate_oapg(
         self,
         body: typing.Any = None,
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Completion
+        Update Project
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -191,15 +202,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_request.serialize(body, content_type)
+        serialized_data = request_body_update_project_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -262,40 +273,55 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_oapg(
+    def _update_oapg(
         self,
         body: typing.Any = None,
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Completion
+        Update Project
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -303,15 +329,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_request.serialize(body, content_type)
+        serialized_data = request_body_update_project_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -344,151 +370,99 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Create(BaseApi):
+class Update(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate(
+    async def aupdate(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config: ModelConfigCompletionRequest,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config=model_config,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return await self._acreate_oapg(
+        return await self._aupdate_oapg(
             body=args.body,
+            path_params=args.path,
         )
     
-    def create(
+    def update(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config: ModelConfigCompletionRequest,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config=model_config,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return self._create_oapg(
+        return self._update_oapg(
             body=args.body,
+            path_params=args.path,
         )
 
-class ApiForpost(BaseApi):
+class ApiForpatch(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apost(
+    async def apatch(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config: ModelConfigCompletionRequest,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config=model_config,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return await self._acreate_oapg(
+        return await self._aupdate_oapg(
             body=args.body,
+            path_params=args.path,
         )
     
-    def post(
+    def patch(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config: ModelConfigCompletionRequest,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config=model_config,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return self._create_oapg(
+        return self._update_oapg(
             body=args.body,
+            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion/post.pyi` & `humanloop-0.4.9/humanloop/paths/completion/post.py`

 * *Files 18% similar despite different names*

```diff
@@ -39,25 +39,30 @@
 
 from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.model_config_completion_request import ModelConfigCompletionRequest
 from humanloop.type.completion_request import CompletionRequest
 from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
+from . import path
+
 # body param
 SchemaForRequestBodyApplicationJson = CompletionRequestSchema
 
 
 request_body_completion_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
+_auth = [
+    'APIKeyHeader',
+]
 SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: CompletionResponse
 
@@ -92,57 +97,76 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
     def _create_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if logprobs is not None:
             _body["logprobs"] = logprobs
         if stream is not None:
             _body["stream"] = stream
         if suffix is not None:
             _body["suffix"] = suffix
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
         if model_config is not None:
             _body["model_config"] = model_config
         args.body = _body
         return args
 
     async def _acreate_oapg(
         self,
@@ -340,146 +364,186 @@
 
 
 class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
     async def acreate(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return await self._acreate_oapg(
             body=args.body,
         )
     
     def create(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return self._create_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return await self._acreate_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config=model_config,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return self._create_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion_deployed/post.py` & `humanloop-0.4.9/humanloop/paths/completion/post.pyi`

 * *Files 19% similar despite different names*

```diff
@@ -28,39 +28,36 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
+from humanloop.model.model_config_completion_request import ModelConfigCompletionRequest as ModelConfigCompletionRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
+from humanloop.model.completion_request import CompletionRequest as CompletionRequestSchema
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.completion_deployed_request import CompletionDeployedRequest as CompletionDeployedRequestSchema
 
-from humanloop.type.completion_deployed_request import CompletionDeployedRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.model_config_completion_request import ModelConfigCompletionRequest
+from humanloop.type.completion_request import CompletionRequest
 from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
-
 # body param
-SchemaForRequestBodyApplicationJson = CompletionDeployedRequestSchema
+SchemaForRequestBodyApplicationJson = CompletionRequestSchema
 
 
-request_body_completion_deployed_request = api_client.RequestBody(
+request_body_completion_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
 SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: CompletionResponse
 
@@ -95,78 +92,92 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_deployed_mapped_args(
+    def _create_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if logprobs is not None:
             _body["logprobs"] = logprobs
         if stream is not None:
             _body["stream"] = stream
         if suffix is not None:
             _body["suffix"] = suffix
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
+        if model_config is not None:
+            _body["model_config"] = model_config
         args.body = _body
         return args
 
-    async def _acreate_deployed_oapg(
+    async def _acreate_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Completion Deployed
+        Completion
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -186,15 +197,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
+        serialized_data = request_body_completion_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -257,28 +268,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_deployed_oapg(
+    def _create_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Completion Deployed
+        Completion
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -298,15 +309,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
+        serialized_data = request_body_completion_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -339,143 +350,191 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class CreateDeployed(BaseApi):
+class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate_deployed(
+    async def acreate(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_deployed_mapped_args(
+        args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return await self._acreate_deployed_oapg(
+        return await self._acreate_oapg(
             body=args.body,
         )
     
-    def create_deployed(
+    def create(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_deployed_mapped_args(
+        args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return self._create_deployed_oapg(
+        return self._create_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_deployed_mapped_args(
+        args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return await self._acreate_deployed_oapg(
+        return await self._acreate_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
+        model_config: ModelConfigCompletionRequest,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_deployed_mapped_args(
+        args = self._create_mapped_args(
+            model_config=model_config,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
-        return self._create_deployed_oapg(
+        return self._create_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion_deployed/post.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_export/post.py`

 * *Files 19% similar despite different names*

```diff
@@ -27,46 +27,96 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.completion_deployed_request import CompletionDeployedRequest as CompletionDeployedRequestSchema
+from humanloop.model.paginated_data_log_response import PaginatedDataLogResponse as PaginatedDataLogResponseSchema
 
-from humanloop.type.completion_deployed_request import CompletionDeployedRequest
-from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.completion_response import CompletionResponse
+from humanloop.type.paginated_data_log_response import PaginatedDataLogResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
-# body param
-SchemaForRequestBodyApplicationJson = CompletionDeployedRequestSchema
+from . import path
 
+# Query params
+PageSchema = schemas.IntSchema
+SizeSchema = schemas.IntSchema
+RequestRequiredQueryParams = typing_extensions.TypedDict(
+    'RequestRequiredQueryParams',
+    {
+    }
+)
+RequestOptionalQueryParams = typing_extensions.TypedDict(
+    'RequestOptionalQueryParams',
+    {
+        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
+        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
+    },
+    total=False
+)
 
-request_body_completion_deployed_request = api_client.RequestBody(
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaForRequestBodyApplicationJson),
+
+class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
+    pass
+
+
+request_query_page = api_client.QueryParameter(
+    name="page",
+    style=api_client.ParameterStyle.FORM,
+    schema=PageSchema,
+    explode=True,
+)
+request_query_size = api_client.QueryParameter(
+    name="size",
+    style=api_client.ParameterStyle.FORM,
+    schema=SizeSchema,
+    explode=True,
+)
+# Path params
+IdSchema = schemas.StrSchema
+RequestRequiredPathParams = typing_extensions.TypedDict(
+    'RequestRequiredPathParams',
+    {
+        'id': typing.Union[IdSchema, str, ],
+    }
+)
+RequestOptionalPathParams = typing_extensions.TypedDict(
+    'RequestOptionalPathParams',
+    {
     },
+    total=False
+)
+
+
+class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
+    pass
+
+
+request_path_id = api_client.PathParameter(
+    name="id",
+    style=api_client.ParameterStyle.SIMPLE,
+    schema=IdSchema,
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
+_auth = [
+    'APIKeyHeader',
+]
+SchemaFor200ResponseBodyApplicationJson = PaginatedDataLogResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: CompletionResponse
+    body: PaginatedDataLogResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: CompletionResponse
+    body: PaginatedDataLogResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -90,115 +140,114 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_deployed_mapped_args(
+    def _export_datapoints_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _body = {}
-        if project is not None:
-            _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if logprobs is not None:
-            _body["logprobs"] = logprobs
-        if stream is not None:
-            _body["stream"] = stream
-        if suffix is not None:
-            _body["suffix"] = suffix
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        args.body = _body
+        _query_params = {}
+        _path_params = {}
+        if page is not None:
+            _query_params["page"] = page
+        if size is not None:
+            _query_params["size"] = size
+        if id is not None:
+            _path_params["id"] = id
+        args.query = _query_params
+        args.path = _path_params
         return args
 
-    async def _acreate_deployed_oapg(
+    async def _aexport_datapoints_oapg(
         self,
-        body: typing.Any = None,
+            query_params: typing.Optional[dict] = {},
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Completion Deployed
+        Export Datapoints
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
+        prefix_separator_iterator = None
+        for parameter in (
+            request_query_page,
+            request_query_size,
+        ):
+            parameter_data = query_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -248,69 +297,83 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_deployed_oapg(
+    def _export_datapoints_oapg(
         self,
-        body: typing.Any = None,
+            query_params: typing.Optional[dict] = {},
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Completion Deployed
+        Export Datapoints
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
+        prefix_separator_iterator = None
+        for parameter in (
+            request_query_page,
+            request_query_size,
+        ):
+            parameter_data = query_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_deployed_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -330,143 +393,91 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class CreateDeployed(BaseApi):
+class ExportDatapoints(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate_deployed(
+    async def aexport_datapoints(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_deployed_mapped_args(
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
         )
-        return await self._acreate_deployed_oapg(
-            body=args.body,
+        return await self._aexport_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
     
-    def create_deployed(
+    def export_datapoints(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_deployed_mapped_args(
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
-        )
-        return self._create_deployed_oapg(
-            body=args.body,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
+        )
+        return self._export_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_deployed_mapped_args(
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
-        )
-        return await self._acreate_deployed_oapg(
-            body=args.body,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
+        )
+        return await self._aexport_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
     
     def post(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_deployed_mapped_args(
-            project=project,
-            inputs=inputs,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
-        )
-        return self._create_deployed_oapg(
-            body=args.body,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
+        )
+        return self._export_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion_experiment/post.py` & `humanloop-0.4.9/humanloop/paths/projects_id/patch.py`

 * *Files 17% similar despite different names*

```diff
@@ -27,51 +27,77 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
+from humanloop.model.project_response import ProjectResponse as ProjectResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.completion_experiment_request import CompletionExperimentRequest as CompletionExperimentRequestSchema
+from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
+from humanloop.model.update_project_request import UpdateProjectRequest as UpdateProjectRequestSchema
 
-from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.completion_experiment_request import CompletionExperimentRequest
-from humanloop.type.completion_response import CompletionResponse
+from humanloop.type.project_response import ProjectResponse
+from humanloop.type.positive_label import PositiveLabel
+from humanloop.type.update_project_request import UpdateProjectRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
+# Path params
+IdSchema = schemas.StrSchema
+RequestRequiredPathParams = typing_extensions.TypedDict(
+    'RequestRequiredPathParams',
+    {
+        'id': typing.Union[IdSchema, str, ],
+    }
+)
+RequestOptionalPathParams = typing_extensions.TypedDict(
+    'RequestOptionalPathParams',
+    {
+    },
+    total=False
+)
+
+
+class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
+    pass
+
+
+request_path_id = api_client.PathParameter(
+    name="id",
+    style=api_client.ParameterStyle.SIMPLE,
+    schema=IdSchema,
+    required=True,
+)
 # body param
-SchemaForRequestBodyApplicationJson = CompletionExperimentRequestSchema
+SchemaForRequestBodyApplicationJson = UpdateProjectRequestSchema
 
 
-request_body_completion_experiment_request = api_client.RequestBody(
+request_body_update_project_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
+SchemaFor200ResponseBodyApplicationJson = ProjectResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: CompletionResponse
+    body: ProjectResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: CompletionResponse
+    body: ProjectResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -106,82 +132,78 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_experiment_mapped_args(
+    def _update_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
+        _path_params = {}
         _body = {}
-        if project is not None:
-            _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if logprobs is not None:
-            _body["logprobs"] = logprobs
-        if stream is not None:
-            _body["stream"] = stream
-        if suffix is not None:
-            _body["suffix"] = suffix
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if experiment_id is not None:
-            _body["experiment_id"] = experiment_id
+        if active_experiment_id is not None:
+            _body["active_experiment_id"] = active_experiment_id
+        if active_config_id is not None:
+            _body["active_config_id"] = active_config_id
+        if positive_labels is not None:
+            _body["positive_labels"] = positive_labels
         args.body = _body
+        if id is not None:
+            _path_params["id"] = id
+        args.path = _path_params
         return args
 
-    async def _acreate_experiment_oapg(
+    async def _aupdate_oapg(
         self,
         body: typing.Any = None,
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Completion Experiment
+        Update Project
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -189,15 +211,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_update_project_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -260,40 +282,55 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_experiment_oapg(
+    def _update_oapg(
         self,
         body: typing.Any = None,
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Completion Experiment
+        Update Project
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -301,15 +338,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_update_project_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -342,151 +379,99 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class CreateExperiment(BaseApi):
+class Update(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate_experiment(
+    async def aupdate(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return await self._acreate_experiment_oapg(
+        return await self._aupdate_oapg(
             body=args.body,
+            path_params=args.path,
         )
     
-    def create_experiment(
+    def update(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return self._create_experiment_oapg(
+        return self._update_oapg(
             body=args.body,
+            path_params=args.path,
         )
 
-class ApiForpost(BaseApi):
+class ApiForpatch(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apost(
+    async def apatch(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return await self._acreate_experiment_oapg(
+        return await self._aupdate_oapg(
             body=args.body,
+            path_params=args.path,
         )
     
-    def post(
+    def patch(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        active_experiment_id: typing.Optional[str] = None,
+        active_config_id: typing.Optional[str] = None,
+        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_mapped_args(
+            id=id,
+            active_experiment_id=active_experiment_id,
+            active_config_id=active_config_id,
+            positive_labels=positive_labels,
         )
-        return self._create_experiment_oapg(
+        return self._update_oapg(
             body=args.body,
+            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion_experiment/post.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_export/post.pyi`

 * *Files 16% similar despite different names*

```diff
@@ -27,46 +27,91 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
-from humanloop.model.completion_experiment_request import CompletionExperimentRequest as CompletionExperimentRequestSchema
+from humanloop.model.paginated_data_log_response import PaginatedDataLogResponse as PaginatedDataLogResponseSchema
 
-from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.completion_experiment_request import CompletionExperimentRequest
-from humanloop.type.completion_response import CompletionResponse
+from humanloop.type.paginated_data_log_response import PaginatedDataLogResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
-# body param
-SchemaForRequestBodyApplicationJson = CompletionExperimentRequestSchema
+# Query params
+PageSchema = schemas.IntSchema
+SizeSchema = schemas.IntSchema
+RequestRequiredQueryParams = typing_extensions.TypedDict(
+    'RequestRequiredQueryParams',
+    {
+    }
+)
+RequestOptionalQueryParams = typing_extensions.TypedDict(
+    'RequestOptionalQueryParams',
+    {
+        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
+        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
+    },
+    total=False
+)
 
 
-request_body_completion_experiment_request = api_client.RequestBody(
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaForRequestBodyApplicationJson),
+class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
+    pass
+
+
+request_query_page = api_client.QueryParameter(
+    name="page",
+    style=api_client.ParameterStyle.FORM,
+    schema=PageSchema,
+    explode=True,
+)
+request_query_size = api_client.QueryParameter(
+    name="size",
+    style=api_client.ParameterStyle.FORM,
+    schema=SizeSchema,
+    explode=True,
+)
+# Path params
+IdSchema = schemas.StrSchema
+RequestRequiredPathParams = typing_extensions.TypedDict(
+    'RequestRequiredPathParams',
+    {
+        'id': typing.Union[IdSchema, str, ],
+    }
+)
+RequestOptionalPathParams = typing_extensions.TypedDict(
+    'RequestOptionalPathParams',
+    {
     },
+    total=False
+)
+
+
+class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
+    pass
+
+
+request_path_id = api_client.PathParameter(
+    name="id",
+    style=api_client.ParameterStyle.SIMPLE,
+    schema=IdSchema,
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
+SchemaFor200ResponseBodyApplicationJson = PaginatedDataLogResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: CompletionResponse
+    body: PaginatedDataLogResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: CompletionResponse
+    body: PaginatedDataLogResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -97,111 +142,103 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_experiment_mapped_args(
+    def _export_datapoints_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _body = {}
-        if project is not None:
-            _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if logprobs is not None:
-            _body["logprobs"] = logprobs
-        if stream is not None:
-            _body["stream"] = stream
-        if suffix is not None:
-            _body["suffix"] = suffix
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if experiment_id is not None:
-            _body["experiment_id"] = experiment_id
-        args.body = _body
+        _query_params = {}
+        _path_params = {}
+        if page is not None:
+            _query_params["page"] = page
+        if size is not None:
+            _query_params["size"] = size
+        if id is not None:
+            _path_params["id"] = id
+        args.query = _query_params
+        args.path = _path_params
         return args
 
-    async def _acreate_experiment_oapg(
+    async def _aexport_datapoints_oapg(
         self,
-        body: typing.Any = None,
+            query_params: typing.Optional[dict] = {},
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Completion Experiment
+        Export Datapoints
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
+        prefix_separator_iterator = None
+        for parameter in (
+            request_query_page,
+            request_query_size,
+        ):
+            parameter_data = query_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -251,69 +288,83 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_experiment_oapg(
+    def _export_datapoints_oapg(
         self,
-        body: typing.Any = None,
+            query_params: typing.Optional[dict] = {},
+            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Completion Experiment
+        Export Datapoints
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
+        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
+        _path_params = {}
+        for parameter in (
+            request_path_id,
+        ):
+            parameter_data = path_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            serialized_data = parameter.serialize(parameter_data)
+            _path_params.update(serialized_data)
+    
+        for k, v in _path_params.items():
+            used_path = used_path.replace('{%s}' % k, v)
+    
+        prefix_separator_iterator = None
+        for parameter in (
+            request_query_page,
+            request_query_size,
+        ):
+            parameter_data = query_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -333,151 +384,91 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class CreateExperiment(BaseApi):
+class ExportDatapoints(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate_experiment(
+    async def aexport_datapoints(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
         )
-        return await self._acreate_experiment_oapg(
-            body=args.body,
+        return await self._aexport_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
     
-    def create_experiment(
+    def export_datapoints(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
-        )
-        return self._create_experiment_oapg(
-            body=args.body,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
+        )
+        return self._export_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
-        )
-        return await self._acreate_experiment_oapg(
-            body=args.body,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
+        )
+        return await self._aexport_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
     
     def post(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        experiment_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_experiment_mapped_args(
-            project=project,
-            inputs=inputs,
-            experiment_id=experiment_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
-        )
-        return self._create_experiment_oapg(
-            body=args.body,
+        args = self._export_datapoints_mapped_args(
+            id=id,
+            page=page,
+            size=size,
+        )
+        return self._export_datapoints_oapg(
+            query_params=args.query,
+            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion_model_config/post.py` & `humanloop-0.4.9/humanloop/paths/logs/patch.pyi`

 * *Files 18% similar despite different names*

```diff
@@ -27,51 +27,71 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
-from humanloop.model.completion_model_config_request import CompletionModelConfigRequest as CompletionModelConfigRequestSchema
+from humanloop.model.update_log_request import UpdateLogRequest as UpdateLogRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
+from humanloop.model.log_response import LogResponse as LogResponseSchema
 
-from humanloop.type.provider_api_keys import ProviderApiKeys
-from humanloop.type.completion_model_config_request import CompletionModelConfigRequest
-from humanloop.type.completion_response import CompletionResponse
+from humanloop.type.update_log_request import UpdateLogRequest
+from humanloop.type.log_response import LogResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
+# Query params
+ReferenceIdSchema = schemas.StrSchema
+RequestRequiredQueryParams = typing_extensions.TypedDict(
+    'RequestRequiredQueryParams',
+    {
+        'reference_id': typing.Union[ReferenceIdSchema, str, ],
+    }
+)
+RequestOptionalQueryParams = typing_extensions.TypedDict(
+    'RequestOptionalQueryParams',
+    {
+    },
+    total=False
+)
+
+
+class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
+    pass
 
+
+request_query_reference_id = api_client.QueryParameter(
+    name="reference_id",
+    style=api_client.ParameterStyle.FORM,
+    schema=ReferenceIdSchema,
+    required=True,
+    explode=True,
+)
 # body param
-SchemaForRequestBodyApplicationJson = CompletionModelConfigRequestSchema
+SchemaForRequestBodyApplicationJson = UpdateLogRequestSchema
 
 
-request_body_completion_model_config_request = api_client.RequestBody(
+request_body_update_log_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
-SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
+SchemaFor200ResponseBodyApplicationJson = LogResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: CompletionResponse
+    body: LogResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: CompletionResponse
+    body: LogResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -95,93 +115,85 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_model_configuration_mapped_args(
+    def _update_by_reference_id_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: str,
+        output: typing.Optional[str] = None,
+        error: typing.Optional[str] = None,
+        duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
+        _query_params = {}
         _body = {}
-        if project is not None:
-            _body["project"] = project
-        if inputs is not None:
-            _body["inputs"] = inputs
-        if source is not None:
-            _body["source"] = source
-        if provider_api_keys is not None:
-            _body["provider_api_keys"] = provider_api_keys
-        if num_samples is not None:
-            _body["num_samples"] = num_samples
-        if logprobs is not None:
-            _body["logprobs"] = logprobs
-        if stream is not None:
-            _body["stream"] = stream
-        if suffix is not None:
-            _body["suffix"] = suffix
-        if user is not None:
-            _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
-        if model_config_id is not None:
-            _body["model_config_id"] = model_config_id
+        if output is not None:
+            _body["output"] = output
+        if error is not None:
+            _body["error"] = error
+        if duration is not None:
+            _body["duration"] = duration
         args.body = _body
+        if reference_id is not None:
+            _query_params["reference_id"] = reference_id
+        args.query = _query_params
         return args
 
-    async def _acreate_model_configuration_oapg(
+    async def _aupdate_by_reference_id_oapg(
         self,
         body: typing.Any = None,
+            query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Completion Model Config
+        Update Log By Reference Id
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
+        prefix_separator_iterator = None
+        for parameter in (
+            request_query_reference_id,
+        ):
+            parameter_data = query_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -189,28 +201,29 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_update_log_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
             fields=_fields,
             serialized_body=_body,
             body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -260,40 +273,55 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_model_configuration_oapg(
+    def _update_by_reference_id_oapg(
         self,
         body: typing.Any = None,
+            query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Completion Model Config
+        Update Log By Reference Id
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
+        prefix_separator_iterator = None
+        for parameter in (
+            request_query_reference_id,
+        ):
+            parameter_data = query_params.get(parameter.name, schemas.unset)
+            if parameter_data is schemas.unset:
+                continue
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
+    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -301,28 +329,29 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_completion_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_update_log_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
             fields=_fields,
             serialized_body=_body,
             body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -342,151 +371,99 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class CreateModelConfiguration(BaseApi):
+class UpdateByReferenceId(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate_model_configuration(
+    async def aupdate_by_reference_id(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: str,
+        output: typing.Optional[str] = None,
+        error: typing.Optional[str] = None,
+        duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_model_configuration_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config_id=model_config_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_by_reference_id_mapped_args(
+            reference_id=reference_id,
+            output=output,
+            error=error,
+            duration=duration,
         )
-        return await self._acreate_model_configuration_oapg(
+        return await self._aupdate_by_reference_id_oapg(
             body=args.body,
+            query_params=args.query,
         )
     
-    def create_model_configuration(
+    def update_by_reference_id(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: str,
+        output: typing.Optional[str] = None,
+        error: typing.Optional[str] = None,
+        duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_model_configuration_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config_id=model_config_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_by_reference_id_mapped_args(
+            reference_id=reference_id,
+            output=output,
+            error=error,
+            duration=duration,
         )
-        return self._create_model_configuration_oapg(
+        return self._update_by_reference_id_oapg(
             body=args.body,
+            query_params=args.query,
         )
 
-class ApiForpost(BaseApi):
+class ApiForpatch(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apost(
+    async def apatch(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: str,
+        output: typing.Optional[str] = None,
+        error: typing.Optional[str] = None,
+        duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_model_configuration_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config_id=model_config_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_by_reference_id_mapped_args(
+            reference_id=reference_id,
+            output=output,
+            error=error,
+            duration=duration,
         )
-        return await self._acreate_model_configuration_oapg(
+        return await self._aupdate_by_reference_id_oapg(
             body=args.body,
+            query_params=args.query,
         )
     
-    def post(
+    def patch(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
-        model_config_id: str,
-        source: typing.Optional[str] = None,
-        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
-        num_samples: typing.Optional[int] = None,
-        logprobs: typing.Optional[int] = None,
-        stream: typing.Optional[bool] = None,
-        suffix: typing.Optional[str] = None,
-        user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: str,
+        output: typing.Optional[str] = None,
+        error: typing.Optional[str] = None,
+        duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_model_configuration_mapped_args(
-            project=project,
-            inputs=inputs,
-            model_config_id=model_config_id,
-            source=source,
-            provider_api_keys=provider_api_keys,
-            num_samples=num_samples,
-            logprobs=logprobs,
-            stream=stream,
-            suffix=suffix,
-            user=user,
-            metadata=metadata,
+        args = self._update_by_reference_id_mapped_args(
+            reference_id=reference_id,
+            output=output,
+            error=error,
+            duration=duration,
         )
-        return self._create_model_configuration_oapg(
+        return self._update_by_reference_id_oapg(
             body=args.body,
+            query_params=args.query,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/completion_model_config/post.pyi` & `humanloop-0.4.9/humanloop/paths/completion_model_config/post.py`

 * *Files 19% similar despite different names*

```diff
@@ -37,25 +37,30 @@
 from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
 
 from humanloop.type.provider_api_keys import ProviderApiKeys
 from humanloop.type.completion_model_config_request import CompletionModelConfigRequest
 from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
+from . import path
+
 # body param
 SchemaForRequestBodyApplicationJson = CompletionModelConfigRequestSchema
 
 
 request_body_completion_model_config_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
+_auth = [
+    'APIKeyHeader',
+]
 SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: CompletionResponse
 
@@ -90,57 +95,76 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
     def _create_model_configuration_mapped_args(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
         if inputs is not None:
             _body["inputs"] = inputs
         if source is not None:
             _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
         if provider_api_keys is not None:
             _body["provider_api_keys"] = provider_api_keys
         if num_samples is not None:
             _body["num_samples"] = num_samples
         if logprobs is not None:
             _body["logprobs"] = logprobs
         if stream is not None:
             _body["stream"] = stream
         if suffix is not None:
             _body["suffix"] = suffix
         if user is not None:
             _body["user"] = user
-        if metadata is not None:
-            _body["metadata"] = metadata
         if model_config_id is not None:
             _body["model_config_id"] = model_config_id
         args.body = _body
         return args
 
     async def _acreate_model_configuration_oapg(
         self,
@@ -338,146 +362,186 @@
 
 
 class CreateModelConfiguration(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
     async def acreate_model_configuration(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._create_model_configuration_mapped_args(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return await self._acreate_model_configuration_oapg(
             body=args.body,
         )
     
     def create_model_configuration(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._create_model_configuration_mapped_args(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return self._create_model_configuration_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._create_model_configuration_mapped_args(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return await self._acreate_model_configuration_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        project: str,
-        inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]],
         model_config_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         provider_api_keys: typing.Optional[ProviderApiKeys] = None,
         num_samples: typing.Optional[int] = None,
         logprobs: typing.Optional[int] = None,
         stream: typing.Optional[bool] = None,
         suffix: typing.Optional[str] = None,
         user: typing.Optional[str] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._create_model_configuration_mapped_args(
+            model_config_id=model_config_id,
             project=project,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
             inputs=inputs,
-            model_config_id=model_config_id,
             source=source,
+            metadata=metadata,
             provider_api_keys=provider_api_keys,
             num_samples=num_samples,
             logprobs=logprobs,
             stream=stream,
             suffix=suffix,
             user=user,
-            metadata=metadata,
         )
         return self._create_model_configuration_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/experiments_experiment_id/delete.py` & `humanloop-0.4.9/humanloop/paths/experiments_experiment_id/delete.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/experiments_experiment_id/delete.pyi` & `humanloop-0.4.9/humanloop/paths/experiments_experiment_id/delete.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/experiments_experiment_id/patch.py` & `humanloop-0.4.9/humanloop/paths/experiments_experiment_id/patch.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/experiments_experiment_id/patch.pyi` & `humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/post.py`

 * *Files 10% similar despite different names*

```diff
@@ -28,60 +28,65 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.update_experiment_request import UpdateExperimentRequest as UpdateExperimentRequestSchema
 from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
 from humanloop.model.experiment_response import ExperimentResponse as ExperimentResponseSchema
+from humanloop.model.create_experiment_request import CreateExperimentRequest as CreateExperimentRequestSchema
 
+from humanloop.type.create_experiment_request import CreateExperimentRequest
 from humanloop.type.experiment_response import ExperimentResponse
 from humanloop.type.positive_label import PositiveLabel
-from humanloop.type.update_experiment_request import UpdateExperimentRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
+from . import path
+
 # Path params
-ExperimentIdSchema = schemas.StrSchema
+ProjectIdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
-        'experiment_id': typing.Union[ExperimentIdSchema, str, ],
+        'project_id': typing.Union[ProjectIdSchema, str, ],
     }
 )
 RequestOptionalPathParams = typing_extensions.TypedDict(
     'RequestOptionalPathParams',
     {
     },
     total=False
 )
 
 
 class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
     pass
 
 
-request_path_experiment_id = api_client.PathParameter(
-    name="experiment_id",
+request_path_project_id = api_client.PathParameter(
+    name="project_id",
     style=api_client.ParameterStyle.SIMPLE,
-    schema=ExperimentIdSchema,
+    schema=ProjectIdSchema,
     required=True,
 )
 # body param
-SchemaForRequestBodyApplicationJson = UpdateExperimentRequestSchema
+SchemaForRequestBodyApplicationJson = CreateExperimentRequestSchema
 
 
-request_body_update_experiment_request = api_client.RequestBody(
+request_body_create_experiment_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
+_auth = [
+    'APIKeyHeader',
+]
 SchemaFor200ResponseBodyApplicationJson = ExperimentResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: ExperimentResponse
 
@@ -116,72 +121,76 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _update_mapped_args(
+    def _create_mapped_args(
         self,
-        experiment_id: str,
-        name: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
-        config_ids_to_register: typing.Optional[typing.List[str]] = None,
-        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _path_params = {}
         _body = {}
         if name is not None:
             _body["name"] = name
+        if config_ids is not None:
+            _body["config_ids"] = config_ids
         if positive_labels is not None:
             _body["positive_labels"] = positive_labels
-        if config_ids_to_register is not None:
-            _body["config_ids_to_register"] = config_ids_to_register
-        if config_ids_to_deregister is not None:
-            _body["config_ids_to_deregister"] = config_ids_to_deregister
+        if set_active is not None:
+            _body["set_active"] = set_active
         args.body = _body
-        if experiment_id is not None:
-            _path_params["experiment_id"] = experiment_id
+        if project_id is not None:
+            _path_params["project_id"] = project_id
         args.path = _path_params
         return args
 
-    async def _aupdate_oapg(
+    async def _acreate_oapg(
         self,
         body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Update Experiment
+        Create Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_experiment_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -189,15 +198,15 @@
             used_path = used_path.replace('{%s}' % k, v)
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
+        method = 'post'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -205,15 +214,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -276,39 +285,39 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _update_oapg(
+    def _create_oapg(
         self,
         body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Update Experiment
+        Create Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_experiment_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -316,15 +325,15 @@
             used_path = used_path.replace('{%s}' % k, v)
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
+        method = 'post'.upper()
         _headers.add('Content-Type', content_type)
     
         if body is schemas.unset:
             raise exceptions.ApiValueError(
                 'The required body parameter has an invalid value of: unset. Set a valid value instead')
         _fields = None
         _body = None
@@ -332,15 +341,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -373,107 +382,107 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Update(BaseApi):
+class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aupdate(
+    async def acreate(
         self,
-        experiment_id: str,
-        name: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
-        config_ids_to_register: typing.Optional[typing.List[str]] = None,
-        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_mapped_args(
-            experiment_id=experiment_id,
+        args = self._create_mapped_args(
             name=name,
             positive_labels=positive_labels,
-            config_ids_to_register=config_ids_to_register,
-            config_ids_to_deregister=config_ids_to_deregister,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return await self._aupdate_oapg(
+        return await self._acreate_oapg(
             body=args.body,
             path_params=args.path,
         )
     
-    def update(
+    def create(
         self,
-        experiment_id: str,
-        name: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
-        config_ids_to_register: typing.Optional[typing.List[str]] = None,
-        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_mapped_args(
-            experiment_id=experiment_id,
+        args = self._create_mapped_args(
             name=name,
             positive_labels=positive_labels,
-            config_ids_to_register=config_ids_to_register,
-            config_ids_to_deregister=config_ids_to_deregister,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return self._update_oapg(
+        return self._create_oapg(
             body=args.body,
             path_params=args.path,
         )
 
-class ApiForpatch(BaseApi):
+class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apatch(
+    async def apost(
         self,
-        experiment_id: str,
-        name: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
-        config_ids_to_register: typing.Optional[typing.List[str]] = None,
-        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_mapped_args(
-            experiment_id=experiment_id,
+        args = self._create_mapped_args(
             name=name,
             positive_labels=positive_labels,
-            config_ids_to_register=config_ids_to_register,
-            config_ids_to_deregister=config_ids_to_deregister,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return await self._aupdate_oapg(
+        return await self._acreate_oapg(
             body=args.body,
             path_params=args.path,
         )
     
-    def patch(
+    def post(
         self,
-        experiment_id: str,
-        name: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
-        config_ids_to_register: typing.Optional[typing.List[str]] = None,
-        config_ids_to_deregister: typing.Optional[typing.List[str]] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_mapped_args(
-            experiment_id=experiment_id,
+        args = self._create_mapped_args(
             name=name,
             positive_labels=positive_labels,
-            config_ids_to_register=config_ids_to_register,
-            config_ids_to_deregister=config_ids_to_deregister,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return self._update_oapg(
+        return self._create_oapg(
             body=args.body,
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/experiments_experiment_id_model_config/get.py` & `humanloop-0.4.9/humanloop/paths/experiments_experiment_id_model_config/get.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/experiments_experiment_id_model_config/get.pyi` & `humanloop-0.4.9/humanloop/paths/experiments_experiment_id_model_config/get.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/feedback/post.py` & `humanloop-0.4.9/humanloop/paths/feedback/post.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/feedback/post.pyi` & `humanloop-0.4.9/humanloop/paths/feedback/post.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/logs/patch.py` & `humanloop-0.4.9/humanloop/paths/logs/patch.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/logs/patch.pyi` & `humanloop-0.4.9/humanloop/paths/sessions/get.pyi`

 * *Files 10% similar despite different names*

```diff
@@ -27,71 +27,74 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.update_log_request import UpdateLogRequest as UpdateLogRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.log_response import LogResponse as LogResponseSchema
+from humanloop.model.paginated_data_session_response import PaginatedDataSessionResponse as PaginatedDataSessionResponseSchema
 
-from humanloop.type.update_log_request import UpdateLogRequest
-from humanloop.type.log_response import LogResponse
+from humanloop.type.paginated_data_session_response import PaginatedDataSessionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 # Query params
-ReferenceIdSchema = schemas.StrSchema
+ProjectIdSchema = schemas.StrSchema
+PageSchema = schemas.IntSchema
+SizeSchema = schemas.IntSchema
 RequestRequiredQueryParams = typing_extensions.TypedDict(
     'RequestRequiredQueryParams',
     {
-        'reference_id': typing.Union[ReferenceIdSchema, str, ],
+        'project_id': typing.Union[ProjectIdSchema, str, ],
     }
 )
 RequestOptionalQueryParams = typing_extensions.TypedDict(
     'RequestOptionalQueryParams',
     {
+        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
+        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
     },
     total=False
 )
 
 
 class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
     pass
 
 
-request_query_reference_id = api_client.QueryParameter(
-    name="reference_id",
+request_query_project_id = api_client.QueryParameter(
+    name="project_id",
     style=api_client.ParameterStyle.FORM,
-    schema=ReferenceIdSchema,
+    schema=ProjectIdSchema,
     required=True,
     explode=True,
 )
-# body param
-SchemaForRequestBodyApplicationJson = UpdateLogRequestSchema
-
-
-request_body_update_log_request = api_client.RequestBody(
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaForRequestBodyApplicationJson),
-    },
-    required=True,
+request_query_page = api_client.QueryParameter(
+    name="page",
+    style=api_client.ParameterStyle.FORM,
+    schema=PageSchema,
+    explode=True,
+)
+request_query_size = api_client.QueryParameter(
+    name="size",
+    style=api_client.ParameterStyle.FORM,
+    schema=SizeSchema,
+    explode=True,
 )
-SchemaFor200ResponseBodyApplicationJson = LogResponseSchema
+SchemaFor200ResponseBodyApplicationJson = PaginatedDataSessionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: LogResponse
+    body: PaginatedDataSessionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: LogResponse
+    body: PaginatedDataSessionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -122,62 +125,57 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _update_by_reference_id_mapped_args(
+    def _list_mapped_args(
         self,
-        reference_id: str,
-        output: typing.Optional[str] = None,
-        error: typing.Optional[str] = None,
-        duration: typing.Optional[typing.Union[int, float]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _query_params = {}
-        _body = {}
-        if output is not None:
-            _body["output"] = output
-        if error is not None:
-            _body["error"] = error
-        if duration is not None:
-            _body["duration"] = duration
-        args.body = _body
-        if reference_id is not None:
-            _query_params["reference_id"] = reference_id
+        if project_id is not None:
+            _query_params["project_id"] = project_id
+        if page is not None:
+            _query_params["page"] = page
+        if size is not None:
+            _query_params["size"] = size
         args.query = _query_params
         return args
 
-    async def _aupdate_by_reference_id_oapg(
+    async def _alist_oapg(
         self,
-        body: typing.Any = None,
             query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Update Log By Reference Id
+        Get Sessions
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
         prefix_separator_iterator = None
         for parameter in (
-            request_query_reference_id,
+            request_query_project_id,
+            request_query_page,
+            request_query_size,
         ):
             parameter_data = query_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             if prefix_separator_iterator is None:
                 prefix_separator_iterator = parameter.get_prefix_separator_iterator()
             serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
@@ -185,43 +183,27 @@
                 used_path += serialized_value
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_log_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
             prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
@@ -273,39 +255,39 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _update_by_reference_id_oapg(
+    def _list_oapg(
         self,
-        body: typing.Any = None,
             query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Update Log By Reference Id
+        Get Sessions
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
         prefix_separator_iterator = None
         for parameter in (
-            request_query_reference_id,
+            request_query_project_id,
+            request_query_page,
+            request_query_size,
         ):
             parameter_data = query_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             if prefix_separator_iterator is None:
                 prefix_separator_iterator = parameter.get_prefix_separator_iterator()
             serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
@@ -313,43 +295,27 @@
                 used_path += serialized_value
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_log_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
             prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
@@ -371,99 +337,87 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class UpdateByReferenceId(BaseApi):
+class List(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aupdate_by_reference_id(
+    async def alist(
         self,
-        reference_id: str,
-        output: typing.Optional[str] = None,
-        error: typing.Optional[str] = None,
-        duration: typing.Optional[typing.Union[int, float]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_by_reference_id_mapped_args(
-            reference_id=reference_id,
-            output=output,
-            error=error,
-            duration=duration,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
         )
-        return await self._aupdate_by_reference_id_oapg(
-            body=args.body,
+        return await self._alist_oapg(
             query_params=args.query,
         )
     
-    def update_by_reference_id(
+    def list(
         self,
-        reference_id: str,
-        output: typing.Optional[str] = None,
-        error: typing.Optional[str] = None,
-        duration: typing.Optional[typing.Union[int, float]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_by_reference_id_mapped_args(
-            reference_id=reference_id,
-            output=output,
-            error=error,
-            duration=duration,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
         )
-        return self._update_by_reference_id_oapg(
-            body=args.body,
+        return self._list_oapg(
             query_params=args.query,
         )
 
-class ApiForpatch(BaseApi):
+class ApiForget(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apatch(
+    async def aget(
         self,
-        reference_id: str,
-        output: typing.Optional[str] = None,
-        error: typing.Optional[str] = None,
-        duration: typing.Optional[typing.Union[int, float]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_by_reference_id_mapped_args(
-            reference_id=reference_id,
-            output=output,
-            error=error,
-            duration=duration,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
         )
-        return await self._aupdate_by_reference_id_oapg(
-            body=args.body,
+        return await self._alist_oapg(
             query_params=args.query,
         )
     
-    def patch(
+    def get(
         self,
-        reference_id: str,
-        output: typing.Optional[str] = None,
-        error: typing.Optional[str] = None,
-        duration: typing.Optional[typing.Union[int, float]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_by_reference_id_mapped_args(
-            reference_id=reference_id,
-            output=output,
-            error=error,
-            duration=duration,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
         )
-        return self._update_by_reference_id_oapg(
-            body=args.body,
+        return self._list_oapg(
             query_params=args.query,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/logs/post.py` & `humanloop-0.4.9/humanloop/paths/logs/post.pyi`

 * *Files 2% similar despite different names*

```diff
@@ -47,30 +47,25 @@
 from humanloop.type.generic_config_request import GenericConfigRequest
 from humanloop.type.tool_config_request import ToolConfigRequest
 from humanloop.type.logs_log_response import LogsLogResponse
 from humanloop.type.trace_model_config_request import TraceModelConfigRequest
 from humanloop.type.log_datapoint_request import LogDatapointRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
-
 # body param
 SchemaForRequestBodyApplicationJson = LogDatapointRequestSchema
 
 
 request_body_log_datapoint_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
 SchemaFor200ResponseBodyApplicationJson = LogsLogResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: LogsLogResponse
 
@@ -105,74 +100,73 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
     def _log_mapped_args(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
-        if reference_id is not None:
-            _body["reference_id"] = reference_id
+        if project_id is not None:
+            _body["project_id"] = project_id
         if session_id is not None:
             _body["session_id"] = session_id
         if session_reference_id is not None:
             _body["session_reference_id"] = session_reference_id
         if parent_id is not None:
             _body["parent_id"] = parent_id
         if parent_reference_id is not None:
             _body["parent_reference_id"] = parent_reference_id
-        if trial_id is not None:
-            _body["trial_id"] = trial_id
         if inputs is not None:
             _body["inputs"] = inputs
+        if source is not None:
+            _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if reference_id is not None:
+            _body["reference_id"] = reference_id
+        if trial_id is not None:
+            _body["trial_id"] = trial_id
         if messages is not None:
             _body["messages"] = messages
         if output is not None:
             _body["output"] = output
-        if source is not None:
-            _body["source"] = source
         if config is not None:
             _body["config"] = config
-        if metadata is not None:
-            _body["metadata"] = metadata
         if feedback is not None:
             _body["feedback"] = feedback
         if created_at is not None:
             _body["created_at"] = created_at
         if error is not None:
             _body["error"] = error
         if duration is not None:
@@ -378,98 +372,102 @@
 class Log(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
     async def alog(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return await self._alog_oapg(
             body=args.body,
         )
     
     def log(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return self._log_oapg(
             body=args.body,
@@ -478,98 +476,102 @@
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return await self._alog_oapg(
             body=args.body,
         )
     
     def post(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return self._log_oapg(
             body=args.body,
```

### Comparing `humanloop-0.4.8/humanloop/paths/logs/post.pyi` & `humanloop-0.4.9/humanloop/paths/logs/post.py`

 * *Files 3% similar despite different names*

```diff
@@ -47,25 +47,30 @@
 from humanloop.type.generic_config_request import GenericConfigRequest
 from humanloop.type.tool_config_request import ToolConfigRequest
 from humanloop.type.logs_log_response import LogsLogResponse
 from humanloop.type.trace_model_config_request import TraceModelConfigRequest
 from humanloop.type.log_datapoint_request import LogDatapointRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
+from . import path
+
 # body param
 SchemaForRequestBodyApplicationJson = LogDatapointRequestSchema
 
 
 request_body_log_datapoint_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
+_auth = [
+    'APIKeyHeader',
+]
 SchemaFor200ResponseBodyApplicationJson = LogsLogResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
     body: LogsLogResponse
 
@@ -100,70 +105,77 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
     def _log_mapped_args(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if project is not None:
             _body["project"] = project
-        if reference_id is not None:
-            _body["reference_id"] = reference_id
+        if project_id is not None:
+            _body["project_id"] = project_id
         if session_id is not None:
             _body["session_id"] = session_id
         if session_reference_id is not None:
             _body["session_reference_id"] = session_reference_id
         if parent_id is not None:
             _body["parent_id"] = parent_id
         if parent_reference_id is not None:
             _body["parent_reference_id"] = parent_reference_id
-        if trial_id is not None:
-            _body["trial_id"] = trial_id
         if inputs is not None:
             _body["inputs"] = inputs
+        if source is not None:
+            _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if reference_id is not None:
+            _body["reference_id"] = reference_id
+        if trial_id is not None:
+            _body["trial_id"] = trial_id
         if messages is not None:
             _body["messages"] = messages
         if output is not None:
             _body["output"] = output
-        if source is not None:
-            _body["source"] = source
         if config is not None:
             _body["config"] = config
-        if metadata is not None:
-            _body["metadata"] = metadata
         if feedback is not None:
             _body["feedback"] = feedback
         if created_at is not None:
             _body["created_at"] = created_at
         if error is not None:
             _body["error"] = error
         if duration is not None:
@@ -369,98 +381,102 @@
 class Log(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
     async def alog(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return await self._alog_oapg(
             body=args.body,
         )
     
     def log(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return self._log_oapg(
             body=args.body,
@@ -469,98 +485,102 @@
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return await self._alog_oapg(
             body=args.body,
         )
     
     def post(
         self,
         body: typing.Optional[LogDatapointRequest] = None,
         project: typing.Optional[str] = None,
-        reference_id: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
         session_id: typing.Optional[str] = None,
         session_reference_id: typing.Optional[str] = None,
         parent_id: typing.Optional[str] = None,
         parent_reference_id: typing.Optional[str] = None,
-        trial_id: typing.Optional[str] = None,
         inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        reference_id: typing.Optional[str] = None,
+        trial_id: typing.Optional[str] = None,
         messages: typing.Optional[typing.List[ChatMessage]] = None,
         output: typing.Optional[str] = None,
-        source: typing.Optional[str] = None,
         config: typing.Optional[typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]] = None,
-        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         feedback: typing.Optional[typing.Union[Feedback, typing.List[Feedback]]] = None,
         created_at: typing.Optional[datetime] = None,
         error: typing.Optional[str] = None,
         duration: typing.Optional[typing.Union[int, float]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._log_mapped_args(
             body=body,
             project=project,
-            reference_id=reference_id,
+            project_id=project_id,
             session_id=session_id,
             session_reference_id=session_reference_id,
             parent_id=parent_id,
             parent_reference_id=parent_reference_id,
-            trial_id=trial_id,
             inputs=inputs,
+            source=source,
+            metadata=metadata,
+            reference_id=reference_id,
+            trial_id=trial_id,
             messages=messages,
             output=output,
-            source=source,
             config=config,
-            metadata=metadata,
             feedback=feedback,
             created_at=created_at,
             error=error,
             duration=duration,
         )
         return self._log_oapg(
             body=args.body,
```

### Comparing `humanloop-0.4.8/humanloop/paths/logs_id/patch.py` & `humanloop-0.4.9/humanloop/paths/logs_id/patch.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/logs_id/patch.pyi` & `humanloop-0.4.9/humanloop/paths/logs_id/patch.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/model_configs/post.py` & `humanloop-0.4.9/humanloop/paths/model_configs/post.py`

 * *Files 1% similar despite different names*

```diff
@@ -31,21 +31,21 @@
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.model_providers import ModelProviders as ModelProvidersSchema
 from humanloop.model.project_model_config_request import ProjectModelConfigRequest as ProjectModelConfigRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
 from humanloop.model.model_endpoints import ModelEndpoints as ModelEndpointsSchema
-from humanloop.model.project_model_config_response import ProjectModelConfigResponse as ProjectModelConfigResponseSchema
+from humanloop.model.project_config_response import ProjectConfigResponse as ProjectConfigResponseSchema
 from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
 
 from humanloop.type.chat_message import ChatMessage
 from humanloop.type.project_model_config_request import ProjectModelConfigRequest
-from humanloop.type.project_model_config_response import ProjectModelConfigResponse
 from humanloop.type.model_providers import ModelProviders
+from humanloop.type.project_config_response import ProjectConfigResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 from humanloop.type.model_endpoints import ModelEndpoints
 
 from . import path
 
 # body param
 SchemaForRequestBodyApplicationJson = ProjectModelConfigRequestSchema
@@ -57,25 +57,25 @@
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = ProjectModelConfigResponseSchema
+SchemaFor200ResponseBodyApplicationJson = ProjectConfigResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ProjectModelConfigResponse
+    body: ProjectConfigResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ProjectModelConfigResponse
+    body: ProjectConfigResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -115,43 +115,37 @@
 class BaseApi(api_client.Api):
 
     def _register_mapped_args(
         self,
         model: str,
         project: str,
         provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
         max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
         top_p: typing.Optional[typing.Union[int, float]] = None,
         stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
         presence_penalty: typing.Optional[typing.Union[int, float]] = None,
         frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
         other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         name: typing.Optional[str] = None,
         experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
         if provider is not None:
             _body["provider"] = provider
-        if endpoint is not None:
-            _body["endpoint"] = endpoint
         if model is not None:
             _body["model"] = model
-        if prompt_template is not None:
-            _body["prompt_template"] = prompt_template
-        if chat_template is not None:
-            _body["chat_template"] = chat_template
-        if temperature is not None:
-            _body["temperature"] = temperature
         if max_tokens is not None:
             _body["max_tokens"] = max_tokens
+        if temperature is not None:
+            _body["temperature"] = temperature
         if top_p is not None:
             _body["top_p"] = top_p
         if stop is not None:
             _body["stop"] = stop
         if presence_penalty is not None:
             _body["presence_penalty"] = presence_penalty
         if frequency_penalty is not None:
@@ -160,14 +154,20 @@
             _body["other"] = other
         if project is not None:
             _body["project"] = project
         if name is not None:
             _body["name"] = name
         if experiment is not None:
             _body["experiment"] = experiment
+        if prompt_template is not None:
+            _body["prompt_template"] = prompt_template
+        if chat_template is not None:
+            _body["chat_template"] = chat_template
+        if endpoint is not None:
+            _body["endpoint"] = endpoint
         args.body = _body
         return args
 
     async def _aregister_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
@@ -366,175 +366,175 @@
     # this class is used by api classes that refer to endpoints with operationId fn names
 
     async def aregister(
         self,
         model: str,
         project: str,
         provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
         max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
         top_p: typing.Optional[typing.Union[int, float]] = None,
         stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
         presence_penalty: typing.Optional[typing.Union[int, float]] = None,
         frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
         other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         name: typing.Optional[str] = None,
         experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._register_mapped_args(
             model=model,
             project=project,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             name=name,
             experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
         return await self._aregister_oapg(
             body=args.body,
         )
     
     def register(
         self,
         model: str,
         project: str,
         provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
         max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
         top_p: typing.Optional[typing.Union[int, float]] = None,
         stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
         presence_penalty: typing.Optional[typing.Union[int, float]] = None,
         frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
         other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         name: typing.Optional[str] = None,
         experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._register_mapped_args(
             model=model,
             project=project,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             name=name,
             experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
         return self._register_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
         model: str,
         project: str,
         provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
         max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
         top_p: typing.Optional[typing.Union[int, float]] = None,
         stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
         presence_penalty: typing.Optional[typing.Union[int, float]] = None,
         frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
         other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         name: typing.Optional[str] = None,
         experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._register_mapped_args(
             model=model,
             project=project,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             name=name,
             experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
         return await self._aregister_oapg(
             body=args.body,
         )
     
     def post(
         self,
         model: str,
         project: str,
         provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
         max_tokens: typing.Optional[int] = None,
+        temperature: typing.Optional[typing.Union[int, float]] = None,
         top_p: typing.Optional[typing.Union[int, float]] = None,
         stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
         presence_penalty: typing.Optional[typing.Union[int, float]] = None,
         frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
         other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
         name: typing.Optional[str] = None,
         experiment: typing.Optional[str] = None,
+        prompt_template: typing.Optional[str] = None,
+        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
+        endpoint: typing.Optional[ModelEndpoints] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._register_mapped_args(
             model=model,
             project=project,
             provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
             max_tokens=max_tokens,
+            temperature=temperature,
             top_p=top_p,
             stop=stop,
             presence_penalty=presence_penalty,
             frequency_penalty=frequency_penalty,
             other=other,
             name=name,
             experiment=experiment,
+            prompt_template=prompt_template,
+            chat_template=chat_template,
+            endpoint=endpoint,
         )
         return self._register_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/model_configs/post.pyi` & `humanloop-0.4.9/humanloop/paths/completion_experiment/post.pyi`

 * *Files 12% similar despite different names*

```diff
@@ -27,50 +27,46 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.model_providers import ModelProviders as ModelProvidersSchema
-from humanloop.model.project_model_config_request import ProjectModelConfigRequest as ProjectModelConfigRequestSchema
+from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.model_endpoints import ModelEndpoints as ModelEndpointsSchema
-from humanloop.model.project_model_config_response import ProjectModelConfigResponse as ProjectModelConfigResponseSchema
-from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
-
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.project_model_config_request import ProjectModelConfigRequest
-from humanloop.type.project_model_config_response import ProjectModelConfigResponse
-from humanloop.type.model_providers import ModelProviders
+from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
+from humanloop.model.completion_experiment_request import CompletionExperimentRequest as CompletionExperimentRequestSchema
+
+from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.completion_experiment_request import CompletionExperimentRequest
+from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
-from humanloop.type.model_endpoints import ModelEndpoints
 
 # body param
-SchemaForRequestBodyApplicationJson = ProjectModelConfigRequestSchema
+SchemaForRequestBodyApplicationJson = CompletionExperimentRequestSchema
 
 
-request_body_project_model_config_request = api_client.RequestBody(
+request_body_completion_experiment_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = ProjectModelConfigResponseSchema
+SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ProjectModelConfigResponse
+    body: CompletionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ProjectModelConfigResponse
+    body: CompletionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -101,82 +97,85 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _register_mapped_args(
+    def _create_experiment_mapped_args(
         self,
-        model: str,
-        project: str,
-        provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
-        max_tokens: typing.Optional[int] = None,
-        top_p: typing.Optional[typing.Union[int, float]] = None,
-        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
-        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
-        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
-        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        name: typing.Optional[str] = None,
-        experiment: typing.Optional[str] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _body = {}
-        if provider is not None:
-            _body["provider"] = provider
-        if endpoint is not None:
-            _body["endpoint"] = endpoint
-        if model is not None:
-            _body["model"] = model
-        if prompt_template is not None:
-            _body["prompt_template"] = prompt_template
-        if chat_template is not None:
-            _body["chat_template"] = chat_template
-        if temperature is not None:
-            _body["temperature"] = temperature
-        if max_tokens is not None:
-            _body["max_tokens"] = max_tokens
-        if top_p is not None:
-            _body["top_p"] = top_p
-        if stop is not None:
-            _body["stop"] = stop
-        if presence_penalty is not None:
-            _body["presence_penalty"] = presence_penalty
-        if frequency_penalty is not None:
-            _body["frequency_penalty"] = frequency_penalty
-        if other is not None:
-            _body["other"] = other
         if project is not None:
             _body["project"] = project
-        if name is not None:
-            _body["name"] = name
-        if experiment is not None:
-            _body["experiment"] = experiment
+        if project_id is not None:
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
+        if inputs is not None:
+            _body["inputs"] = inputs
+        if source is not None:
+            _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if provider_api_keys is not None:
+            _body["provider_api_keys"] = provider_api_keys
+        if num_samples is not None:
+            _body["num_samples"] = num_samples
+        if logprobs is not None:
+            _body["logprobs"] = logprobs
+        if stream is not None:
+            _body["stream"] = stream
+        if suffix is not None:
+            _body["suffix"] = suffix
+        if user is not None:
+            _body["user"] = user
+        if experiment_id is not None:
+            _body["experiment_id"] = experiment_id
         args.body = _body
         return args
 
-    async def _aregister_oapg(
+    async def _acreate_experiment_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Register Model Config
+        Completion Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -196,15 +195,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_project_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -267,28 +266,28 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _register_oapg(
+    def _create_experiment_oapg(
         self,
         body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Register Model Config
+        Completion Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
@@ -308,15 +307,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_project_model_config_request.serialize(body, content_type)
+        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -349,183 +348,191 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Register(BaseApi):
+class CreateExperiment(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aregister(
+    async def acreate_experiment(
         self,
-        model: str,
-        project: str,
-        provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
-        max_tokens: typing.Optional[int] = None,
-        top_p: typing.Optional[typing.Union[int, float]] = None,
-        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
-        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
-        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
-        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        name: typing.Optional[str] = None,
-        experiment: typing.Optional[str] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._register_mapped_args(
-            model=model,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
             project=project,
-            provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
-            max_tokens=max_tokens,
-            top_p=top_p,
-            stop=stop,
-            presence_penalty=presence_penalty,
-            frequency_penalty=frequency_penalty,
-            other=other,
-            name=name,
-            experiment=experiment,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return await self._aregister_oapg(
+        return await self._acreate_experiment_oapg(
             body=args.body,
         )
     
-    def register(
+    def create_experiment(
         self,
-        model: str,
-        project: str,
-        provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
-        max_tokens: typing.Optional[int] = None,
-        top_p: typing.Optional[typing.Union[int, float]] = None,
-        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
-        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
-        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
-        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        name: typing.Optional[str] = None,
-        experiment: typing.Optional[str] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._register_mapped_args(
-            model=model,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
             project=project,
-            provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
-            max_tokens=max_tokens,
-            top_p=top_p,
-            stop=stop,
-            presence_penalty=presence_penalty,
-            frequency_penalty=frequency_penalty,
-            other=other,
-            name=name,
-            experiment=experiment,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return self._register_oapg(
+        return self._create_experiment_oapg(
             body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        model: str,
-        project: str,
-        provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
-        max_tokens: typing.Optional[int] = None,
-        top_p: typing.Optional[typing.Union[int, float]] = None,
-        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
-        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
-        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
-        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        name: typing.Optional[str] = None,
-        experiment: typing.Optional[str] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._register_mapped_args(
-            model=model,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
             project=project,
-            provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
-            max_tokens=max_tokens,
-            top_p=top_p,
-            stop=stop,
-            presence_penalty=presence_penalty,
-            frequency_penalty=frequency_penalty,
-            other=other,
-            name=name,
-            experiment=experiment,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return await self._aregister_oapg(
+        return await self._acreate_experiment_oapg(
             body=args.body,
         )
     
     def post(
         self,
-        model: str,
-        project: str,
-        provider: typing.Optional[ModelProviders] = None,
-        endpoint: typing.Optional[ModelEndpoints] = None,
-        prompt_template: typing.Optional[str] = None,
-        chat_template: typing.Optional[typing.List[ChatMessage]] = None,
-        temperature: typing.Optional[typing.Union[int, float]] = None,
-        max_tokens: typing.Optional[int] = None,
-        top_p: typing.Optional[typing.Union[int, float]] = None,
-        stop: typing.Optional[typing.Union[str, typing.List[str]]] = None,
-        presence_penalty: typing.Optional[typing.Union[int, float]] = None,
-        frequency_penalty: typing.Optional[typing.Union[int, float]] = None,
-        other: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
-        name: typing.Optional[str] = None,
-        experiment: typing.Optional[str] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._register_mapped_args(
-            model=model,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
             project=project,
-            provider=provider,
-            endpoint=endpoint,
-            prompt_template=prompt_template,
-            chat_template=chat_template,
-            temperature=temperature,
-            max_tokens=max_tokens,
-            top_p=top_p,
-            stop=stop,
-            presence_penalty=presence_penalty,
-            frequency_penalty=frequency_penalty,
-            other=other,
-            name=name,
-            experiment=experiment,
+            project_id=project_id,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return self._register_oapg(
+        return self._create_experiment_oapg(
             body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/model_configs_id/get.py` & `humanloop-0.4.9/humanloop/paths/model_configs_id/get.py`

 * *Files 1% similar despite different names*

```diff
@@ -28,17 +28,17 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.src_external_app_models_v3_model_configs_model_config_response import SrcExternalAppModelsV3ModelConfigsModelConfigResponse as SrcExternalAppModelsV3ModelConfigsModelConfigResponseSchema
+from humanloop.model.src_external_app_models_v4_model_configs_model_config_response import SrcExternalAppModelsV4ModelConfigsModelConfigResponse as SrcExternalAppModelsV4ModelConfigsModelConfigResponseSchema
 
-from humanloop.type.src_external_app_models_v3_model_configs_model_config_response import SrcExternalAppModelsV3ModelConfigsModelConfigResponse
+from humanloop.type.src_external_app_models_v4_model_configs_model_config_response import SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
 # Path params
 IdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
@@ -64,25 +64,25 @@
     style=api_client.ParameterStyle.SIMPLE,
     schema=IdSchema,
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = SrcExternalAppModelsV3ModelConfigsModelConfigResponseSchema
+SchemaFor200ResponseBodyApplicationJson = SrcExternalAppModelsV4ModelConfigsModelConfigResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: SrcExternalAppModelsV3ModelConfigsModelConfigResponse
+    body: SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: SrcExternalAppModelsV3ModelConfigsModelConfigResponse
+    body: SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
```

### Comparing `humanloop-0.4.8/humanloop/paths/model_configs_id/get.pyi` & `humanloop-0.4.9/humanloop/paths/model_configs_id/get.pyi`

 * *Files 1% similar despite different names*

```diff
@@ -28,17 +28,17 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.src_external_app_models_v3_model_configs_model_config_response import SrcExternalAppModelsV3ModelConfigsModelConfigResponse as SrcExternalAppModelsV3ModelConfigsModelConfigResponseSchema
+from humanloop.model.src_external_app_models_v4_model_configs_model_config_response import SrcExternalAppModelsV4ModelConfigsModelConfigResponse as SrcExternalAppModelsV4ModelConfigsModelConfigResponseSchema
 
-from humanloop.type.src_external_app_models_v3_model_configs_model_config_response import SrcExternalAppModelsV3ModelConfigsModelConfigResponse
+from humanloop.type.src_external_app_models_v4_model_configs_model_config_response import SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 # Path params
 IdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
@@ -59,25 +59,25 @@
 
 request_path_id = api_client.PathParameter(
     name="id",
     style=api_client.ParameterStyle.SIMPLE,
     schema=IdSchema,
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = SrcExternalAppModelsV3ModelConfigsModelConfigResponseSchema
+SchemaFor200ResponseBodyApplicationJson = SrcExternalAppModelsV4ModelConfigsModelConfigResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: SrcExternalAppModelsV3ModelConfigsModelConfigResponse
+    body: SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: SrcExternalAppModelsV3ModelConfigsModelConfigResponse
+    body: SrcExternalAppModelsV4ModelConfigsModelConfigResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects/get.py` & `humanloop-0.4.9/humanloop/paths/projects/get.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects/get.pyi` & `humanloop-0.4.9/humanloop/paths/projects/get.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects/post.py` & `humanloop-0.4.9/humanloop/paths/projects/post.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects/post.pyi` & `humanloop-0.4.9/humanloop/paths/projects/post.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id/get.py` & `humanloop-0.4.9/humanloop/paths/projects_id/get.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id/get.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id/get.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id/patch.py` & `humanloop-0.4.9/humanloop/paths/sessions/get.py`

 * *Files 11% similar despite different names*

```diff
@@ -27,77 +27,79 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.project_response import ProjectResponse as ProjectResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
-from humanloop.model.update_project_request import UpdateProjectRequest as UpdateProjectRequestSchema
+from humanloop.model.paginated_data_session_response import PaginatedDataSessionResponse as PaginatedDataSessionResponseSchema
 
-from humanloop.type.project_response import ProjectResponse
-from humanloop.type.positive_label import PositiveLabel
-from humanloop.type.update_project_request import UpdateProjectRequest
+from humanloop.type.paginated_data_session_response import PaginatedDataSessionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
-# Path params
-IdSchema = schemas.StrSchema
-RequestRequiredPathParams = typing_extensions.TypedDict(
-    'RequestRequiredPathParams',
+# Query params
+ProjectIdSchema = schemas.StrSchema
+PageSchema = schemas.IntSchema
+SizeSchema = schemas.IntSchema
+RequestRequiredQueryParams = typing_extensions.TypedDict(
+    'RequestRequiredQueryParams',
     {
-        'id': typing.Union[IdSchema, str, ],
+        'project_id': typing.Union[ProjectIdSchema, str, ],
     }
 )
-RequestOptionalPathParams = typing_extensions.TypedDict(
-    'RequestOptionalPathParams',
+RequestOptionalQueryParams = typing_extensions.TypedDict(
+    'RequestOptionalQueryParams',
     {
+        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
+        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
     },
     total=False
 )
 
 
-class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
+class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
     pass
 
 
-request_path_id = api_client.PathParameter(
-    name="id",
-    style=api_client.ParameterStyle.SIMPLE,
-    schema=IdSchema,
+request_query_project_id = api_client.QueryParameter(
+    name="project_id",
+    style=api_client.ParameterStyle.FORM,
+    schema=ProjectIdSchema,
     required=True,
+    explode=True,
 )
-# body param
-SchemaForRequestBodyApplicationJson = UpdateProjectRequestSchema
-
-
-request_body_update_project_request = api_client.RequestBody(
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaForRequestBodyApplicationJson),
-    },
-    required=True,
+request_query_page = api_client.QueryParameter(
+    name="page",
+    style=api_client.ParameterStyle.FORM,
+    schema=PageSchema,
+    explode=True,
+)
+request_query_size = api_client.QueryParameter(
+    name="size",
+    style=api_client.ParameterStyle.FORM,
+    schema=SizeSchema,
+    explode=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = ProjectResponseSchema
+SchemaFor200ResponseBodyApplicationJson = PaginatedDataSessionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ProjectResponse
+    body: PaginatedDataSessionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ProjectResponse
+    body: PaginatedDataSessionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -132,107 +134,87 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _update_mapped_args(
+    def _list_mapped_args(
         self,
-        id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _path_params = {}
-        _body = {}
-        if active_experiment_id is not None:
-            _body["active_experiment_id"] = active_experiment_id
-        if active_config_id is not None:
-            _body["active_config_id"] = active_config_id
-        if positive_labels is not None:
-            _body["positive_labels"] = positive_labels
-        args.body = _body
-        if id is not None:
-            _path_params["id"] = id
-        args.path = _path_params
+        _query_params = {}
+        if project_id is not None:
+            _query_params["project_id"] = project_id
+        if page is not None:
+            _query_params["page"] = page
+        if size is not None:
+            _query_params["size"] = size
+        args.query = _query_params
         return args
 
-    async def _aupdate_oapg(
+    async def _alist_oapg(
         self,
-        body: typing.Any = None,
-            path_params: typing.Optional[dict] = {},
+            query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Update Project
+        Get Sessions
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
-        _path_params = {}
+        prefix_separator_iterator = None
         for parameter in (
-            request_path_id,
+            request_query_project_id,
+            request_query_page,
+            request_query_size,
         ):
-            parameter_data = path_params.get(parameter.name, schemas.unset)
+            parameter_data = query_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
-            serialized_data = parameter.serialize(parameter_data)
-            _path_params.update(serialized_data)
-    
-        for k, v in _path_params.items():
-            used_path = used_path.replace('{%s}' % k, v)
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_project_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -282,84 +264,69 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _update_oapg(
+    def _list_oapg(
         self,
-        body: typing.Any = None,
-            path_params: typing.Optional[dict] = {},
+            query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Update Project
+        Get Sessions
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
+        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
-        _path_params = {}
+        prefix_separator_iterator = None
         for parameter in (
-            request_path_id,
+            request_query_project_id,
+            request_query_page,
+            request_query_size,
         ):
-            parameter_data = path_params.get(parameter.name, schemas.unset)
+            parameter_data = query_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
-            serialized_data = parameter.serialize(parameter_data)
-            _path_params.update(serialized_data)
-    
-        for k, v in _path_params.items():
-            used_path = used_path.replace('{%s}' % k, v)
+            if prefix_separator_iterator is None:
+                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
+            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
+            for serialized_value in serialized_data.values():
+                used_path += serialized_value
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_project_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
+            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -379,99 +346,87 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Update(BaseApi):
+class List(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aupdate(
+    async def alist(
         self,
-        id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_mapped_args(
-            id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
-        )
-        return await self._aupdate_oapg(
-            body=args.body,
-            path_params=args.path,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
+        )
+        return await self._alist_oapg(
+            query_params=args.query,
         )
     
-    def update(
+    def list(
         self,
-        id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_mapped_args(
-            id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
-        )
-        return self._update_oapg(
-            body=args.body,
-            path_params=args.path,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
+        )
+        return self._list_oapg(
+            query_params=args.query,
         )
 
-class ApiForpatch(BaseApi):
+class ApiForget(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apatch(
+    async def aget(
         self,
-        id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_mapped_args(
-            id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
-        )
-        return await self._aupdate_oapg(
-            body=args.body,
-            path_params=args.path,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
+        )
+        return await self._alist_oapg(
+            query_params=args.query,
         )
     
-    def patch(
+    def get(
         self,
-        id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
+        project_id: str,
+        page: typing.Optional[int] = None,
+        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_mapped_args(
-            id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
-        )
-        return self._update_oapg(
-            body=args.body,
-            path_params=args.path,
+        args = self._list_mapped_args(
+            project_id=project_id,
+            page=page,
+            size=size,
+        )
+        return self._list_oapg(
+            query_params=args.query,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id/patch.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_feedback_types/patch.pyi`

 * *Files 11% similar despite different names*

```diff
@@ -27,22 +27,20 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.project_response import ProjectResponse as ProjectResponseSchema
+from humanloop.model.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest as ProjectsUpdateFeedbackTypesRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
-from humanloop.model.update_project_request import UpdateProjectRequest as UpdateProjectRequestSchema
+from humanloop.model.feedback_types import FeedbackTypes as FeedbackTypesSchema
 
-from humanloop.type.project_response import ProjectResponse
-from humanloop.type.positive_label import PositiveLabel
-from humanloop.type.update_project_request import UpdateProjectRequest
+from humanloop.type.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest
+from humanloop.type.feedback_types import FeedbackTypes
 from humanloop.type.http_validation_error import HTTPValidationError
 
 # Path params
 IdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
@@ -64,35 +62,35 @@
 request_path_id = api_client.PathParameter(
     name="id",
     style=api_client.ParameterStyle.SIMPLE,
     schema=IdSchema,
     required=True,
 )
 # body param
-SchemaForRequestBodyApplicationJson = UpdateProjectRequestSchema
+SchemaForRequestBodyApplicationJson = ProjectsUpdateFeedbackTypesRequestSchema
 
 
-request_body_update_project_request = api_client.RequestBody(
+request_body_projects_update_feedback_types_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = ProjectResponseSchema
+SchemaFor200ResponseBodyApplicationJson = FeedbackTypesSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ProjectResponse
+    body: FeedbackTypes
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ProjectResponse
+    body: FeedbackTypes
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -123,52 +121,44 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _update_mapped_args(
+    def _update_feedback_types_mapped_args(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _path_params = {}
         _body = {}
-        if active_experiment_id is not None:
-            _body["active_experiment_id"] = active_experiment_id
-        if active_config_id is not None:
-            _body["active_config_id"] = active_config_id
-        if positive_labels is not None:
-            _body["positive_labels"] = positive_labels
-        args.body = _body
+        args.body = body if body is not None else _body
         if id is not None:
             _path_params["id"] = id
         args.path = _path_params
         return args
 
-    async def _aupdate_oapg(
+    async def _aupdate_feedback_types_oapg(
         self,
         body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Update Project
+        Update Feedback Types
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
@@ -202,15 +192,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_project_request.serialize(body, content_type)
+        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -273,29 +263,29 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _update_oapg(
+    def _update_feedback_types_oapg(
         self,
         body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Update Project
+        Update Feedback Types
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
@@ -329,15 +319,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_update_project_request.serialize(body, content_type)
+        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -370,99 +360,83 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Update(BaseApi):
+class UpdateFeedbackTypes(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aupdate(
+    async def aupdate_feedback_types(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
         )
-        return await self._aupdate_oapg(
+        return await self._aupdate_feedback_types_oapg(
             body=args.body,
             path_params=args.path,
         )
     
-    def update(
+    def update_feedback_types(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
         )
-        return self._update_oapg(
+        return self._update_feedback_types_oapg(
             body=args.body,
             path_params=args.path,
         )
 
 class ApiForpatch(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apatch(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
         )
-        return await self._aupdate_oapg(
+        return await self._aupdate_feedback_types_oapg(
             body=args.body,
             path_params=args.path,
         )
     
     def patch(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        active_experiment_id: typing.Optional[str] = None,
-        active_config_id: typing.Optional[str] = None,
-        positive_labels: typing.Optional[typing.List[PositiveLabel]] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            active_experiment_id=active_experiment_id,
-            active_config_id=active_config_id,
-            positive_labels=positive_labels,
         )
-        return self._update_oapg(
+        return self._update_feedback_types_oapg(
             body=args.body,
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_active_config/delete.py` & `humanloop-0.4.9/humanloop/paths/projects_id_active_config/delete.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_active_config/delete.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_active_config/delete.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_active_config/get.py` & `humanloop-0.4.9/humanloop/paths/projects_id_active_config/get.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_active_config/get.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_active_config/get.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_active_experiment/delete.py` & `humanloop-0.4.9/humanloop/paths/projects_id_active_experiment/delete.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_active_experiment/delete.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_active_experiment/delete.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_configs/get.py` & `humanloop-0.4.9/humanloop/paths/projects_id_configs/get.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_configs/get.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_configs/get.pyi`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_export/post.py` & `humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/post.pyi`

 * *Files 12% similar despite different names*

```diff
@@ -28,95 +28,71 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.paginated_data_log_response import PaginatedDataLogResponse as PaginatedDataLogResponseSchema
-
-from humanloop.type.paginated_data_log_response import PaginatedDataLogResponse
+from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
+from humanloop.model.experiment_response import ExperimentResponse as ExperimentResponseSchema
+from humanloop.model.create_experiment_request import CreateExperimentRequest as CreateExperimentRequestSchema
+
+from humanloop.type.create_experiment_request import CreateExperimentRequest
+from humanloop.type.experiment_response import ExperimentResponse
+from humanloop.type.positive_label import PositiveLabel
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
-
-# Query params
-PageSchema = schemas.IntSchema
-SizeSchema = schemas.IntSchema
-RequestRequiredQueryParams = typing_extensions.TypedDict(
-    'RequestRequiredQueryParams',
-    {
-    }
-)
-RequestOptionalQueryParams = typing_extensions.TypedDict(
-    'RequestOptionalQueryParams',
-    {
-        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
-        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
-    },
-    total=False
-)
-
-
-class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
-    pass
-
-
-request_query_page = api_client.QueryParameter(
-    name="page",
-    style=api_client.ParameterStyle.FORM,
-    schema=PageSchema,
-    explode=True,
-)
-request_query_size = api_client.QueryParameter(
-    name="size",
-    style=api_client.ParameterStyle.FORM,
-    schema=SizeSchema,
-    explode=True,
-)
 # Path params
-IdSchema = schemas.StrSchema
+ProjectIdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
-        'id': typing.Union[IdSchema, str, ],
+        'project_id': typing.Union[ProjectIdSchema, str, ],
     }
 )
 RequestOptionalPathParams = typing_extensions.TypedDict(
     'RequestOptionalPathParams',
     {
     },
     total=False
 )
 
 
 class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
     pass
 
 
-request_path_id = api_client.PathParameter(
-    name="id",
+request_path_project_id = api_client.PathParameter(
+    name="project_id",
     style=api_client.ParameterStyle.SIMPLE,
-    schema=IdSchema,
+    schema=ProjectIdSchema,
     required=True,
 )
-_auth = [
-    'APIKeyHeader',
-]
-SchemaFor200ResponseBodyApplicationJson = PaginatedDataLogResponseSchema
+# body param
+SchemaForRequestBodyApplicationJson = CreateExperimentRequestSchema
+
+
+request_body_create_experiment_request = api_client.RequestBody(
+    content={
+        'application/json': api_client.MediaType(
+            schema=SchemaForRequestBodyApplicationJson),
+    },
+    required=True,
+)
+SchemaFor200ResponseBodyApplicationJson = ExperimentResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: PaginatedDataLogResponse
+    body: ExperimentResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: PaginatedDataLogResponse
+    body: ExperimentResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -140,114 +116,117 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _export_datapoints_mapped_args(
+    def _create_mapped_args(
         self,
-        id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _query_params = {}
         _path_params = {}
-        if page is not None:
-            _query_params["page"] = page
-        if size is not None:
-            _query_params["size"] = size
-        if id is not None:
-            _path_params["id"] = id
-        args.query = _query_params
+        _body = {}
+        if name is not None:
+            _body["name"] = name
+        if config_ids is not None:
+            _body["config_ids"] = config_ids
+        if positive_labels is not None:
+            _body["positive_labels"] = positive_labels
+        if set_active is not None:
+            _body["set_active"] = set_active
+        args.body = _body
+        if project_id is not None:
+            _path_params["project_id"] = project_id
         args.path = _path_params
         return args
 
-    async def _aexport_datapoints_oapg(
+    async def _acreate_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
+        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Export Datapoints
+        Create Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
         for k, v in _path_params.items():
             used_path = used_path.replace('{%s}' % k, v)
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -297,83 +276,84 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _export_datapoints_oapg(
+    def _create_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
+        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Export Datapoints
+        Create Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
         for k, v in _path_params.items():
             used_path = used_path.replace('{%s}' % k, v)
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -393,91 +373,107 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ExportDatapoints(BaseApi):
+class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aexport_datapoints(
+    async def acreate(
         self,
-        id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._export_datapoints_mapped_args(
-            id=id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            name=name,
+            positive_labels=positive_labels,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return await self._aexport_datapoints_oapg(
-            query_params=args.query,
+        return await self._acreate_oapg(
+            body=args.body,
             path_params=args.path,
         )
     
-    def export_datapoints(
+    def create(
         self,
-        id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._export_datapoints_mapped_args(
-            id=id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            name=name,
+            positive_labels=positive_labels,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return self._export_datapoints_oapg(
-            query_params=args.query,
+        return self._create_oapg(
+            body=args.body,
             path_params=args.path,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._export_datapoints_mapped_args(
-            id=id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            name=name,
+            positive_labels=positive_labels,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return await self._aexport_datapoints_oapg(
-            query_params=args.query,
+        return await self._acreate_oapg(
+            body=args.body,
             path_params=args.path,
         )
     
     def post(
         self,
-        id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        name: str,
+        positive_labels: typing.List[PositiveLabel],
+        project_id: str,
+        config_ids: typing.Optional[typing.List[str]] = None,
+        set_active: typing.Optional[bool] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._export_datapoints_mapped_args(
-            id=id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            name=name,
+            positive_labels=positive_labels,
+            project_id=project_id,
+            config_ids=config_ids,
+            set_active=set_active,
         )
-        return self._export_datapoints_oapg(
-            query_params=args.query,
+        return self._create_oapg(
+            body=args.body,
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_export/post.pyi` & `humanloop-0.4.9/humanloop/paths/projects_id_feedback_types/patch.py`

 * *Files 10% similar despite different names*

```diff
@@ -27,54 +27,24 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
+from humanloop.model.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest as ProjectsUpdateFeedbackTypesRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.paginated_data_log_response import PaginatedDataLogResponse as PaginatedDataLogResponseSchema
+from humanloop.model.feedback_types import FeedbackTypes as FeedbackTypesSchema
 
-from humanloop.type.paginated_data_log_response import PaginatedDataLogResponse
+from humanloop.type.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest
+from humanloop.type.feedback_types import FeedbackTypes
 from humanloop.type.http_validation_error import HTTPValidationError
 
-# Query params
-PageSchema = schemas.IntSchema
-SizeSchema = schemas.IntSchema
-RequestRequiredQueryParams = typing_extensions.TypedDict(
-    'RequestRequiredQueryParams',
-    {
-    }
-)
-RequestOptionalQueryParams = typing_extensions.TypedDict(
-    'RequestOptionalQueryParams',
-    {
-        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
-        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
-    },
-    total=False
-)
-
+from . import path
 
-class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
-    pass
-
-
-request_query_page = api_client.QueryParameter(
-    name="page",
-    style=api_client.ParameterStyle.FORM,
-    schema=PageSchema,
-    explode=True,
-)
-request_query_size = api_client.QueryParameter(
-    name="size",
-    style=api_client.ParameterStyle.FORM,
-    schema=SizeSchema,
-    explode=True,
-)
 # Path params
 IdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
         'id': typing.Union[IdSchema, str, ],
     }
@@ -93,25 +63,39 @@
 
 request_path_id = api_client.PathParameter(
     name="id",
     style=api_client.ParameterStyle.SIMPLE,
     schema=IdSchema,
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = PaginatedDataLogResponseSchema
+# body param
+SchemaForRequestBodyApplicationJson = ProjectsUpdateFeedbackTypesRequestSchema
+
+
+request_body_projects_update_feedback_types_request = api_client.RequestBody(
+    content={
+        'application/json': api_client.MediaType(
+            schema=SchemaForRequestBodyApplicationJson),
+    },
+    required=True,
+)
+_auth = [
+    'APIKeyHeader',
+]
+SchemaFor200ResponseBodyApplicationJson = FeedbackTypesSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: PaginatedDataLogResponse
+    body: FeedbackTypes
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: PaginatedDataLogResponse
+    body: FeedbackTypes
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -135,60 +119,59 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _export_datapoints_mapped_args(
+    def _update_feedback_types_mapped_args(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _query_params = {}
         _path_params = {}
-        if page is not None:
-            _query_params["page"] = page
-        if size is not None:
-            _query_params["size"] = size
+        _body = {}
+        args.body = body if body is not None else _body
         if id is not None:
             _path_params["id"] = id
-        args.query = _query_params
         args.path = _path_params
         return args
 
-    async def _aexport_datapoints_oapg(
+    async def _aupdate_feedback_types_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
+        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Export Datapoints
+        Update Feedback Types
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
             request_path_id,
         ):
@@ -197,48 +180,49 @@
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
         for k, v in _path_params.items():
             used_path = used_path.replace('{%s}' % k, v)
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -288,33 +272,33 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _export_datapoints_oapg(
+    def _update_feedback_types_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
+        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Export Datapoints
+        Update Feedback Types
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
             request_path_id,
         ):
@@ -323,48 +307,49 @@
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
         for k, v in _path_params.items():
             used_path = used_path.replace('{%s}' % k, v)
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'post'.upper()
+        method = 'patch'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -384,91 +369,83 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class ExportDatapoints(BaseApi):
+class UpdateFeedbackTypes(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aexport_datapoints(
+    async def aupdate_feedback_types(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._export_datapoints_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            page=page,
-            size=size,
         )
-        return await self._aexport_datapoints_oapg(
-            query_params=args.query,
+        return await self._aupdate_feedback_types_oapg(
+            body=args.body,
             path_params=args.path,
         )
     
-    def export_datapoints(
+    def update_feedback_types(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._export_datapoints_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            page=page,
-            size=size,
         )
-        return self._export_datapoints_oapg(
-            query_params=args.query,
+        return self._update_feedback_types_oapg(
+            body=args.body,
             path_params=args.path,
         )
 
-class ApiForpost(BaseApi):
+class ApiForpatch(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apost(
+    async def apatch(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._export_datapoints_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            page=page,
-            size=size,
         )
-        return await self._aexport_datapoints_oapg(
-            query_params=args.query,
+        return await self._aupdate_feedback_types_oapg(
+            body=args.body,
             path_params=args.path,
         )
     
-    def post(
+    def patch(
         self,
+        body: ProjectsUpdateFeedbackTypesRequest,
         id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._export_datapoints_mapped_args(
+        args = self._update_feedback_types_mapped_args(
+            body=body,
             id=id,
-            page=page,
-            size=size,
         )
-        return self._export_datapoints_oapg(
-            query_params=args.query,
+        return self._update_feedback_types_oapg(
+            body=args.body,
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_feedback_types/patch.py` & `humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/get.py`

 * *Files 9% similar despite different names*

```diff
@@ -27,75 +27,62 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest as ProjectsUpdateFeedbackTypesRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.feedback_types import FeedbackTypes as FeedbackTypesSchema
+from humanloop.model.experiments_list_response import ExperimentsListResponse as ExperimentsListResponseSchema
 
-from humanloop.type.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest
-from humanloop.type.feedback_types import FeedbackTypes
+from humanloop.type.experiments_list_response import ExperimentsListResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
 # Path params
-IdSchema = schemas.StrSchema
+ProjectIdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
-        'id': typing.Union[IdSchema, str, ],
+        'project_id': typing.Union[ProjectIdSchema, str, ],
     }
 )
 RequestOptionalPathParams = typing_extensions.TypedDict(
     'RequestOptionalPathParams',
     {
     },
     total=False
 )
 
 
 class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
     pass
 
 
-request_path_id = api_client.PathParameter(
-    name="id",
+request_path_project_id = api_client.PathParameter(
+    name="project_id",
     style=api_client.ParameterStyle.SIMPLE,
-    schema=IdSchema,
-    required=True,
-)
-# body param
-SchemaForRequestBodyApplicationJson = ProjectsUpdateFeedbackTypesRequestSchema
-
-
-request_body_projects_update_feedback_types_request = api_client.RequestBody(
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaForRequestBodyApplicationJson),
-    },
+    schema=ProjectIdSchema,
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = FeedbackTypesSchema
+SchemaFor200ResponseBodyApplicationJson = ExperimentsListResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: FeedbackTypes
+    body: ExperimentsListResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: FeedbackTypes
+    body: ExperimentsListResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -130,54 +117,49 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _update_feedback_types_mapped_args(
+    def _list_mapped_args(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _path_params = {}
-        _body = {}
-        args.body = body if body is not None else _body
-        if id is not None:
-            _path_params["id"] = id
+        if project_id is not None:
+            _path_params["project_id"] = project_id
         args.path = _path_params
         return args
 
-    async def _aupdate_feedback_types_oapg(
+    async def _alist_oapg(
         self,
-        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Update Feedback Types
+        Get Experiments
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -185,43 +167,27 @@
             used_path = used_path.replace('{%s}' % k, v)
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
@@ -272,39 +238,37 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _update_feedback_types_oapg(
+    def _list_oapg(
         self,
-        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Update Feedback Types
+        Get Experiments
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -312,43 +276,27 @@
             used_path = used_path.replace('{%s}' % k, v)
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
@@ -369,83 +317,71 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class UpdateFeedbackTypes(BaseApi):
+class List(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aupdate_feedback_types(
+    async def alist(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return await self._aupdate_feedback_types_oapg(
-            body=args.body,
+        return await self._alist_oapg(
             path_params=args.path,
         )
     
-    def update_feedback_types(
+    def list(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return self._update_feedback_types_oapg(
-            body=args.body,
+        return self._list_oapg(
             path_params=args.path,
         )
 
-class ApiForpatch(BaseApi):
+class ApiForget(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apatch(
+    async def aget(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return await self._aupdate_feedback_types_oapg(
-            body=args.body,
+        return await self._alist_oapg(
             path_params=args.path,
         )
     
-    def patch(
+    def get(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return self._update_feedback_types_oapg(
-            body=args.body,
+        return self._list_oapg(
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_id_feedback_types/patch.pyi` & `humanloop-0.4.9/humanloop/paths/projects_project_id_experiments/get.pyi`

 * *Files 8% similar despite different names*

```diff
@@ -27,70 +27,57 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest as ProjectsUpdateFeedbackTypesRequestSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.feedback_types import FeedbackTypes as FeedbackTypesSchema
+from humanloop.model.experiments_list_response import ExperimentsListResponse as ExperimentsListResponseSchema
 
-from humanloop.type.projects_update_feedback_types_request import ProjectsUpdateFeedbackTypesRequest
-from humanloop.type.feedback_types import FeedbackTypes
+from humanloop.type.experiments_list_response import ExperimentsListResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 # Path params
-IdSchema = schemas.StrSchema
+ProjectIdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
-        'id': typing.Union[IdSchema, str, ],
+        'project_id': typing.Union[ProjectIdSchema, str, ],
     }
 )
 RequestOptionalPathParams = typing_extensions.TypedDict(
     'RequestOptionalPathParams',
     {
     },
     total=False
 )
 
 
 class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
     pass
 
 
-request_path_id = api_client.PathParameter(
-    name="id",
+request_path_project_id = api_client.PathParameter(
+    name="project_id",
     style=api_client.ParameterStyle.SIMPLE,
-    schema=IdSchema,
+    schema=ProjectIdSchema,
     required=True,
 )
-# body param
-SchemaForRequestBodyApplicationJson = ProjectsUpdateFeedbackTypesRequestSchema
-
-
-request_body_projects_update_feedback_types_request = api_client.RequestBody(
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaForRequestBodyApplicationJson),
-    },
-    required=True,
-)
-SchemaFor200ResponseBodyApplicationJson = FeedbackTypesSchema
+SchemaFor200ResponseBodyApplicationJson = ExperimentsListResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: FeedbackTypes
+    body: ExperimentsListResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: FeedbackTypes
+    body: ExperimentsListResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -121,54 +108,49 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _update_feedback_types_mapped_args(
+    def _list_mapped_args(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _path_params = {}
-        _body = {}
-        args.body = body if body is not None else _body
-        if id is not None:
-            _path_params["id"] = id
+        if project_id is not None:
+            _path_params["project_id"] = project_id
         args.path = _path_params
         return args
 
-    async def _aupdate_feedback_types_oapg(
+    async def _alist_oapg(
         self,
-        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Update Feedback Types
+        Get Experiments
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -176,43 +158,27 @@
             used_path = used_path.replace('{%s}' % k, v)
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
@@ -263,39 +229,37 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _update_feedback_types_oapg(
+    def _list_oapg(
         self,
-        body: typing.Any = None,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
-        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Update Feedback Types
+        Get Experiments
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_id,
+            request_path_project_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -303,43 +267,27 @@
             used_path = used_path.replace('{%s}' % k, v)
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'patch'.upper()
-        _headers.add('Content-Type', content_type)
-    
-        if body is schemas.unset:
-            raise exceptions.ApiValueError(
-                'The required body parameter has an invalid value of: unset. Set a valid value instead')
-        _fields = None
-        _body = None
+        method = 'get'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
-            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_projects_update_feedback_types_request.serialize(body, content_type)
-        if 'fields' in serialized_data:
-            _fields = serialized_data['fields']
-        elif 'body' in serialized_data:
-            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
-            fields=_fields,
-            serialized_body=_body,
-            body=body,
             auth_settings=_auth,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
@@ -360,83 +308,71 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class UpdateFeedbackTypes(BaseApi):
+class List(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def aupdate_feedback_types(
+    async def alist(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return await self._aupdate_feedback_types_oapg(
-            body=args.body,
+        return await self._alist_oapg(
             path_params=args.path,
         )
     
-    def update_feedback_types(
+    def list(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return self._update_feedback_types_oapg(
-            body=args.body,
+        return self._list_oapg(
             path_params=args.path,
         )
 
-class ApiForpatch(BaseApi):
+class ApiForget(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def apatch(
+    async def aget(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return await self._aupdate_feedback_types_oapg(
-            body=args.body,
+        return await self._alist_oapg(
             path_params=args.path,
         )
     
-    def patch(
+    def get(
         self,
-        body: ProjectsUpdateFeedbackTypesRequest,
-        id: str,
+        project_id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._update_feedback_types_mapped_args(
-            body=body,
-            id=id,
+        args = self._list_mapped_args(
+            project_id=project_id,
         )
-        return self._update_feedback_types_oapg(
-            body=args.body,
+        return self._list_oapg(
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/get.py` & `humanloop-0.4.9/humanloop/paths/sessions_id/get.py`

 * *Files 7% similar despite different names*

```diff
@@ -28,61 +28,61 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.experiments_list_response import ExperimentsListResponse as ExperimentsListResponseSchema
+from humanloop.model.session_response import SessionResponse as SessionResponseSchema
 
-from humanloop.type.experiments_list_response import ExperimentsListResponse
+from humanloop.type.session_response import SessionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
 # Path params
-ProjectIdSchema = schemas.StrSchema
+IdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
-        'project_id': typing.Union[ProjectIdSchema, str, ],
+        'id': typing.Union[IdSchema, str, ],
     }
 )
 RequestOptionalPathParams = typing_extensions.TypedDict(
     'RequestOptionalPathParams',
     {
     },
     total=False
 )
 
 
 class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
     pass
 
 
-request_path_project_id = api_client.PathParameter(
-    name="project_id",
+request_path_id = api_client.PathParameter(
+    name="id",
     style=api_client.ParameterStyle.SIMPLE,
-    schema=ProjectIdSchema,
+    schema=IdSchema,
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = ExperimentsListResponseSchema
+SchemaFor200ResponseBodyApplicationJson = SessionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ExperimentsListResponse
+    body: SessionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ExperimentsListResponse
+    body: SessionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -117,49 +117,49 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _list_mapped_args(
+    def _get_mapped_args(
         self,
-        project_id: str,
+        id: str,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _path_params = {}
-        if project_id is not None:
-            _path_params["project_id"] = project_id
+        if id is not None:
+            _path_params["id"] = id
         args.path = _path_params
         return args
 
-    async def _alist_oapg(
+    async def _aget_oapg(
         self,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Get Experiments
+        Get Session
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_project_id,
+            request_path_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -238,37 +238,37 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _list_oapg(
+    def _get_oapg(
         self,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Get Experiments
+        Get Session
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_project_id,
+            request_path_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -317,71 +317,71 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class List(BaseApi):
+class Get(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def alist(
+    async def aget(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return await self._alist_oapg(
+        return await self._aget_oapg(
             path_params=args.path,
         )
     
-    def list(
+    def get(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return self._list_oapg(
+        return self._get_oapg(
             path_params=args.path,
         )
 
 class ApiForget(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def aget(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return await self._alist_oapg(
+        return await self._aget_oapg(
             path_params=args.path,
         )
     
     def get(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return self._list_oapg(
+        return self._get_oapg(
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/get.pyi` & `humanloop-0.4.9/humanloop/paths/sessions_id/get.pyi`

 * *Files 10% similar despite different names*

```diff
@@ -28,56 +28,56 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.experiments_list_response import ExperimentsListResponse as ExperimentsListResponseSchema
+from humanloop.model.session_response import SessionResponse as SessionResponseSchema
 
-from humanloop.type.experiments_list_response import ExperimentsListResponse
+from humanloop.type.session_response import SessionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 # Path params
-ProjectIdSchema = schemas.StrSchema
+IdSchema = schemas.StrSchema
 RequestRequiredPathParams = typing_extensions.TypedDict(
     'RequestRequiredPathParams',
     {
-        'project_id': typing.Union[ProjectIdSchema, str, ],
+        'id': typing.Union[IdSchema, str, ],
     }
 )
 RequestOptionalPathParams = typing_extensions.TypedDict(
     'RequestOptionalPathParams',
     {
     },
     total=False
 )
 
 
 class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
     pass
 
 
-request_path_project_id = api_client.PathParameter(
-    name="project_id",
+request_path_id = api_client.PathParameter(
+    name="id",
     style=api_client.ParameterStyle.SIMPLE,
-    schema=ProjectIdSchema,
+    schema=IdSchema,
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = ExperimentsListResponseSchema
+SchemaFor200ResponseBodyApplicationJson = SessionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ExperimentsListResponse
+    body: SessionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ExperimentsListResponse
+    body: SessionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -108,49 +108,49 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _list_mapped_args(
+    def _get_mapped_args(
         self,
-        project_id: str,
+        id: str,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
         _path_params = {}
-        if project_id is not None:
-            _path_params["project_id"] = project_id
+        if id is not None:
+            _path_params["id"] = id
         args.path = _path_params
         return args
 
-    async def _alist_oapg(
+    async def _aget_oapg(
         self,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Get Experiments
+        Get Session
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_project_id,
+            request_path_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -229,37 +229,37 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _list_oapg(
+    def _get_oapg(
         self,
             path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Get Experiments
+        Get Session
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
         _path_params = {}
         for parameter in (
-            request_path_project_id,
+            request_path_id,
         ):
             parameter_data = path_params.get(parameter.name, schemas.unset)
             if parameter_data is schemas.unset:
                 continue
             serialized_data = parameter.serialize(parameter_data)
             _path_params.update(serialized_data)
     
@@ -308,71 +308,71 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class List(BaseApi):
+class Get(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def alist(
+    async def aget(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return await self._alist_oapg(
+        return await self._aget_oapg(
             path_params=args.path,
         )
     
-    def list(
+    def get(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return self._list_oapg(
+        return self._get_oapg(
             path_params=args.path,
         )
 
 class ApiForget(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def aget(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return await self._alist_oapg(
+        return await self._aget_oapg(
             path_params=args.path,
         )
     
     def get(
         self,
-        project_id: str,
+        id: str,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
+        args = self._get_mapped_args(
+            id=id,
         )
-        return self._list_oapg(
+        return self._get_oapg(
             path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/post.py` & `humanloop-0.4.9/humanloop/paths/completion_experiment/post.py`

 * *Files 25% similar despite different names*

```diff
@@ -27,77 +27,51 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
+from humanloop.model.completion_response import CompletionResponse as CompletionResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
-from humanloop.model.experiment_response import ExperimentResponse as ExperimentResponseSchema
-from humanloop.model.create_experiment_request import CreateExperimentRequest as CreateExperimentRequestSchema
-
-from humanloop.type.create_experiment_request import CreateExperimentRequest
-from humanloop.type.experiment_response import ExperimentResponse
-from humanloop.type.positive_label import PositiveLabel
+from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
+from humanloop.model.completion_experiment_request import CompletionExperimentRequest as CompletionExperimentRequestSchema
+
+from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.completion_experiment_request import CompletionExperimentRequest
+from humanloop.type.completion_response import CompletionResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
 from . import path
 
-# Path params
-ProjectIdSchema = schemas.StrSchema
-RequestRequiredPathParams = typing_extensions.TypedDict(
-    'RequestRequiredPathParams',
-    {
-        'project_id': typing.Union[ProjectIdSchema, str, ],
-    }
-)
-RequestOptionalPathParams = typing_extensions.TypedDict(
-    'RequestOptionalPathParams',
-    {
-    },
-    total=False
-)
-
-
-class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
-    pass
-
-
-request_path_project_id = api_client.PathParameter(
-    name="project_id",
-    style=api_client.ParameterStyle.SIMPLE,
-    schema=ProjectIdSchema,
-    required=True,
-)
 # body param
-SchemaForRequestBodyApplicationJson = CreateExperimentRequestSchema
+SchemaForRequestBodyApplicationJson = CompletionExperimentRequestSchema
 
 
-request_body_create_experiment_request = api_client.RequestBody(
+request_body_completion_experiment_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
 _auth = [
     'APIKeyHeader',
 ]
-SchemaFor200ResponseBodyApplicationJson = ExperimentResponseSchema
+SchemaFor200ResponseBodyApplicationJson = CompletionResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ExperimentResponse
+    body: CompletionResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ExperimentResponse
+    body: CompletionResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -132,75 +106,91 @@
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_mapped_args(
+    def _create_experiment_mapped_args(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _path_params = {}
         _body = {}
-        if name is not None:
-            _body["name"] = name
-        if config_ids is not None:
-            _body["config_ids"] = config_ids
-        if positive_labels is not None:
-            _body["positive_labels"] = positive_labels
-        if set_active is not None:
-            _body["set_active"] = set_active
-        args.body = _body
+        if project is not None:
+            _body["project"] = project
         if project_id is not None:
-            _path_params["project_id"] = project_id
-        args.path = _path_params
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
+        if inputs is not None:
+            _body["inputs"] = inputs
+        if source is not None:
+            _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if provider_api_keys is not None:
+            _body["provider_api_keys"] = provider_api_keys
+        if num_samples is not None:
+            _body["num_samples"] = num_samples
+        if logprobs is not None:
+            _body["logprobs"] = logprobs
+        if stream is not None:
+            _body["stream"] = stream
+        if suffix is not None:
+            _body["suffix"] = suffix
+        if user is not None:
+            _body["user"] = user
+        if experiment_id is not None:
+            _body["experiment_id"] = experiment_id
+        args.body = _body
         return args
 
-    async def _acreate_oapg(
+    async def _acreate_experiment_oapg(
         self,
         body: typing.Any = None,
-            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Create Experiment
+        Completion Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
-        _path_params = {}
-        for parameter in (
-            request_path_project_id,
-        ):
-            parameter_data = path_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            serialized_data = parameter.serialize(parameter_data)
-            _path_params.update(serialized_data)
-    
-        for k, v in _path_params.items():
-            used_path = used_path.replace('{%s}' % k, v)
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
         _headers.add('Content-Type', content_type)
@@ -214,15 +204,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -285,49 +275,34 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_oapg(
+    def _create_experiment_oapg(
         self,
         body: typing.Any = None,
-            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Create Experiment
+        Completion Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
-        _path_params = {}
-        for parameter in (
-            request_path_project_id,
-        ):
-            parameter_data = path_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            serialized_data = parameter.serialize(parameter_data)
-            _path_params.update(serialized_data)
-    
-        for k, v in _path_params.items():
-            used_path = used_path.replace('{%s}' % k, v)
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
         _headers.add('Content-Type', content_type)
@@ -341,15 +316,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_completion_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -382,107 +357,191 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Create(BaseApi):
+class CreateExperiment(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate(
+    async def acreate_experiment(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return await self._acreate_oapg(
+        return await self._acreate_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
     
-    def create(
+    def create_experiment(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return self._create_oapg(
+        return self._create_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return await self._acreate_oapg(
+        return await self._acreate_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
     
     def post(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        logprobs: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        suffix: typing.Optional[str] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._create_experiment_mapped_args(
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            logprobs=logprobs,
+            stream=stream,
+            suffix=suffix,
+            user=user,
         )
-        return self._create_oapg(
+        return self._create_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/projects_project_id_experiments/post.pyi` & `humanloop-0.4.9/humanloop/paths/chat_experiment/post.py`

 * *Files 26% similar despite different names*

```diff
@@ -28,71 +28,52 @@
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.positive_label import PositiveLabel as PositiveLabelSchema
-from humanloop.model.experiment_response import ExperimentResponse as ExperimentResponseSchema
-from humanloop.model.create_experiment_request import CreateExperimentRequest as CreateExperimentRequestSchema
-
-from humanloop.type.create_experiment_request import CreateExperimentRequest
-from humanloop.type.experiment_response import ExperimentResponse
-from humanloop.type.positive_label import PositiveLabel
+from humanloop.model.chat_experiment_request import ChatExperimentRequest as ChatExperimentRequestSchema
+from humanloop.model.provider_api_keys import ProviderApiKeys as ProviderApiKeysSchema
+from humanloop.model.chat_response import ChatResponse as ChatResponseSchema
+from humanloop.model.chat_message import ChatMessage as ChatMessageSchema
+
+from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.chat_message import ChatMessage
+from humanloop.type.chat_experiment_request import ChatExperimentRequest
+from humanloop.type.chat_response import ChatResponse
 from humanloop.type.http_validation_error import HTTPValidationError
 
-# Path params
-ProjectIdSchema = schemas.StrSchema
-RequestRequiredPathParams = typing_extensions.TypedDict(
-    'RequestRequiredPathParams',
-    {
-        'project_id': typing.Union[ProjectIdSchema, str, ],
-    }
-)
-RequestOptionalPathParams = typing_extensions.TypedDict(
-    'RequestOptionalPathParams',
-    {
-    },
-    total=False
-)
-
+from . import path
 
-class RequestPathParams(RequestRequiredPathParams, RequestOptionalPathParams):
-    pass
-
-
-request_path_project_id = api_client.PathParameter(
-    name="project_id",
-    style=api_client.ParameterStyle.SIMPLE,
-    schema=ProjectIdSchema,
-    required=True,
-)
 # body param
-SchemaForRequestBodyApplicationJson = CreateExperimentRequestSchema
+SchemaForRequestBodyApplicationJson = ChatExperimentRequestSchema
 
 
-request_body_create_experiment_request = api_client.RequestBody(
+request_body_chat_experiment_request = api_client.RequestBody(
     content={
         'application/json': api_client.MediaType(
             schema=SchemaForRequestBodyApplicationJson),
     },
     required=True,
 )
-SchemaFor200ResponseBodyApplicationJson = ExperimentResponseSchema
+_auth = [
+    'APIKeyHeader',
+]
+SchemaFor200ResponseBodyApplicationJson = ChatResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: ExperimentResponse
+    body: ChatResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: ExperimentResponse
+    body: ChatResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -116,82 +97,99 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _create_mapped_args(
+    def _response_experiment_mapped_args(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        messages: typing.List[ChatMessage],
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        user: typing.Optional[str] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _path_params = {}
         _body = {}
-        if name is not None:
-            _body["name"] = name
-        if config_ids is not None:
-            _body["config_ids"] = config_ids
-        if positive_labels is not None:
-            _body["positive_labels"] = positive_labels
-        if set_active is not None:
-            _body["set_active"] = set_active
-        args.body = _body
+        if project is not None:
+            _body["project"] = project
         if project_id is not None:
-            _path_params["project_id"] = project_id
-        args.path = _path_params
+            _body["project_id"] = project_id
+        if session_id is not None:
+            _body["session_id"] = session_id
+        if session_reference_id is not None:
+            _body["session_reference_id"] = session_reference_id
+        if parent_id is not None:
+            _body["parent_id"] = parent_id
+        if parent_reference_id is not None:
+            _body["parent_reference_id"] = parent_reference_id
+        if inputs is not None:
+            _body["inputs"] = inputs
+        if source is not None:
+            _body["source"] = source
+        if metadata is not None:
+            _body["metadata"] = metadata
+        if messages is not None:
+            _body["messages"] = messages
+        if provider_api_keys is not None:
+            _body["provider_api_keys"] = provider_api_keys
+        if num_samples is not None:
+            _body["num_samples"] = num_samples
+        if stream is not None:
+            _body["stream"] = stream
+        if user is not None:
+            _body["user"] = user
+        if experiment_id is not None:
+            _body["experiment_id"] = experiment_id
+        args.body = _body
         return args
 
-    async def _acreate_oapg(
+    async def _aresponse_experiment_oapg(
         self,
         body: typing.Any = None,
-            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Create Experiment
+        Chat Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
-        _path_params = {}
-        for parameter in (
-            request_path_project_id,
-        ):
-            parameter_data = path_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            serialized_data = parameter.serialize(parameter_data)
-            _path_params.update(serialized_data)
-    
-        for k, v in _path_params.items():
-            used_path = used_path.replace('{%s}' % k, v)
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
         _headers.add('Content-Type', content_type)
@@ -205,15 +203,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
@@ -276,49 +274,34 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _create_oapg(
+    def _response_experiment_oapg(
         self,
         body: typing.Any = None,
-            path_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Create Experiment
+        Chat Experiment
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestPathParams, path_params)
         used_path = path.value
     
-        _path_params = {}
-        for parameter in (
-            request_path_project_id,
-        ):
-            parameter_data = path_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            serialized_data = parameter.serialize(parameter_data)
-            _path_params.update(serialized_data)
-    
-        for k, v in _path_params.items():
-            used_path = used_path.replace('{%s}' % k, v)
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
         _headers.add('Content-Type', content_type)
@@ -332,15 +315,15 @@
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             body=body,
             auth_settings=_auth,
             headers=_headers,
         )
-        serialized_data = request_body_create_experiment_request.serialize(body, content_type)
+        serialized_data = request_body_chat_experiment_request.serialize(body, content_type)
         if 'fields' in serialized_data:
             _fields = serialized_data['fields']
         elif 'body' in serialized_data:
             _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
@@ -373,107 +356,183 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class Create(BaseApi):
+class ResponseExperiment(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def acreate(
+    async def aresponse_experiment(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        messages: typing.List[ChatMessage],
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._response_experiment_mapped_args(
+            messages=messages,
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            stream=stream,
+            user=user,
         )
-        return await self._acreate_oapg(
+        return await self._aresponse_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
     
-    def create(
+    def response_experiment(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        messages: typing.List[ChatMessage],
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._response_experiment_mapped_args(
+            messages=messages,
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            stream=stream,
+            user=user,
         )
-        return self._create_oapg(
+        return self._response_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        messages: typing.List[ChatMessage],
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._response_experiment_mapped_args(
+            messages=messages,
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            stream=stream,
+            user=user,
         )
-        return await self._acreate_oapg(
+        return await self._aresponse_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
     
     def post(
         self,
-        name: str,
-        positive_labels: typing.List[PositiveLabel],
-        project_id: str,
-        config_ids: typing.Optional[typing.List[str]] = None,
-        set_active: typing.Optional[bool] = None,
+        messages: typing.List[ChatMessage],
+        experiment_id: str,
+        project: typing.Optional[str] = None,
+        project_id: typing.Optional[str] = None,
+        session_id: typing.Optional[str] = None,
+        session_reference_id: typing.Optional[str] = None,
+        parent_id: typing.Optional[str] = None,
+        parent_reference_id: typing.Optional[str] = None,
+        inputs: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        source: typing.Optional[str] = None,
+        metadata: typing.Optional[typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]] = None,
+        provider_api_keys: typing.Optional[ProviderApiKeys] = None,
+        num_samples: typing.Optional[int] = None,
+        stream: typing.Optional[bool] = None,
+        user: typing.Optional[str] = None,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._create_mapped_args(
-            name=name,
-            positive_labels=positive_labels,
+        args = self._response_experiment_mapped_args(
+            messages=messages,
+            experiment_id=experiment_id,
+            project=project,
             project_id=project_id,
-            config_ids=config_ids,
-            set_active=set_active,
+            session_id=session_id,
+            session_reference_id=session_reference_id,
+            parent_id=parent_id,
+            parent_reference_id=parent_reference_id,
+            inputs=inputs,
+            source=source,
+            metadata=metadata,
+            provider_api_keys=provider_api_keys,
+            num_samples=num_samples,
+            stream=stream,
+            user=user,
         )
-        return self._create_oapg(
+        return self._response_experiment_oapg(
             body=args.body,
-            path_params=args.path,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/sessions/get.py` & `humanloop-0.4.9/humanloop/paths/traces/post.pyi`

 * *Files 25% similar despite different names*

```diff
@@ -27,79 +27,46 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
+from humanloop.model.create_trace_response import CreateTraceResponse as CreateTraceResponseSchema
 from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.paginated_data_session_response import PaginatedDataSessionResponse as PaginatedDataSessionResponseSchema
+from humanloop.model.create_trace_request import CreateTraceRequest as CreateTraceRequestSchema
+from humanloop.model.trace_log_request import TraceLogRequest as TraceLogRequestSchema
 
-from humanloop.type.paginated_data_session_response import PaginatedDataSessionResponse
+from humanloop.type.trace_log_request import TraceLogRequest
+from humanloop.type.create_trace_response import CreateTraceResponse
+from humanloop.type.create_trace_request import CreateTraceRequest
 from humanloop.type.http_validation_error import HTTPValidationError
 
-from . import path
-
-# Query params
-ProjectIdSchema = schemas.StrSchema
-PageSchema = schemas.IntSchema
-SizeSchema = schemas.IntSchema
-RequestRequiredQueryParams = typing_extensions.TypedDict(
-    'RequestRequiredQueryParams',
-    {
-        'project_id': typing.Union[ProjectIdSchema, str, ],
-    }
-)
-RequestOptionalQueryParams = typing_extensions.TypedDict(
-    'RequestOptionalQueryParams',
-    {
-        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
-        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
-    },
-    total=False
-)
+# body param
+SchemaForRequestBodyApplicationJson = CreateTraceRequestSchema
 
 
-class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
-    pass
-
-
-request_query_project_id = api_client.QueryParameter(
-    name="project_id",
-    style=api_client.ParameterStyle.FORM,
-    schema=ProjectIdSchema,
+request_body_create_trace_request = api_client.RequestBody(
+    content={
+        'application/json': api_client.MediaType(
+            schema=SchemaForRequestBodyApplicationJson),
+    },
     required=True,
-    explode=True,
-)
-request_query_page = api_client.QueryParameter(
-    name="page",
-    style=api_client.ParameterStyle.FORM,
-    schema=PageSchema,
-    explode=True,
 )
-request_query_size = api_client.QueryParameter(
-    name="size",
-    style=api_client.ParameterStyle.FORM,
-    schema=SizeSchema,
-    explode=True,
-)
-_auth = [
-    'APIKeyHeader',
-]
-SchemaFor200ResponseBodyApplicationJson = PaginatedDataSessionResponseSchema
+SchemaFor200ResponseBodyApplicationJson = CreateTraceResponseSchema
 
 
 @dataclass
 class ApiResponseFor200(api_client.ApiResponse):
-    body: PaginatedDataSessionResponse
+    body: CreateTraceResponse
 
 
 @dataclass
 class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: PaginatedDataSessionResponse
+    body: CreateTraceResponse
 
 
 _response_for_200 = api_client.OpenApiResponse(
     response_cls=ApiResponseFor200,
     response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
@@ -123,98 +90,88 @@
     response_cls=ApiResponseFor422,
     response_cls_async=ApiResponseFor422Async,
     content={
         'application/json': api_client.MediaType(
             schema=SchemaFor422ResponseBodyApplicationJson),
     },
 )
-_status_code_to_response = {
-    '200': _response_for_200,
-    '422': _response_for_422,
-}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _list_mapped_args(
+    def _create_mapped_args(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        logs: typing.List[TraceLogRequest],
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _query_params = {}
-        if project_id is not None:
-            _query_params["project_id"] = project_id
-        if page is not None:
-            _query_params["page"] = page
-        if size is not None:
-            _query_params["size"] = size
-        args.query = _query_params
+        _body = {}
+        if logs is not None:
+            _body["logs"] = logs
+        args.body = _body
         return args
 
-    async def _alist_oapg(
+    async def _acreate_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
+        body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Get Sessions
+        Create Trace
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_project_id,
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'get'.upper()
+        method = 'post'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_create_trace_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -264,69 +221,69 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _list_oapg(
+    def _create_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
+        body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Get Sessions
+        Create Trace
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_project_id,
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'get'.upper()
+        method = 'post'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_create_trace_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -346,87 +303,71 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class List(BaseApi):
+class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def alist(
+    async def acreate(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            logs=logs,
         )
-        return await self._alist_oapg(
-            query_params=args.query,
+        return await self._acreate_oapg(
+            body=args.body,
         )
     
-    def list(
+    def create(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            logs=logs,
         )
-        return self._list_oapg(
-            query_params=args.query,
+        return self._create_oapg(
+            body=args.body,
         )
 
-class ApiForget(BaseApi):
+class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def aget(
+    async def apost(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
         ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            logs=logs,
         )
-        return await self._alist_oapg(
-            query_params=args.query,
+        return await self._acreate_oapg(
+            body=args.body,
         )
     
-    def get(
+    def post(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
         ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
+            logs=logs,
         )
-        return self._list_oapg(
-            query_params=args.query,
+        return self._create_oapg(
+            body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/sessions/get.pyi` & `humanloop-0.4.9/humanloop/paths/sessions/post.pyi`

 * *Files 25% similar despite different names*

```diff
@@ -27,185 +27,90 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
-from humanloop.model.paginated_data_session_response import PaginatedDataSessionResponse as PaginatedDataSessionResponseSchema
+from humanloop.model.create_session_response import CreateSessionResponse as CreateSessionResponseSchema
 
-from humanloop.type.paginated_data_session_response import PaginatedDataSessionResponse
-from humanloop.type.http_validation_error import HTTPValidationError
+from humanloop.type.create_session_response import CreateSessionResponse
 
-# Query params
-ProjectIdSchema = schemas.StrSchema
-PageSchema = schemas.IntSchema
-SizeSchema = schemas.IntSchema
-RequestRequiredQueryParams = typing_extensions.TypedDict(
-    'RequestRequiredQueryParams',
-    {
-        'project_id': typing.Union[ProjectIdSchema, str, ],
-    }
-)
-RequestOptionalQueryParams = typing_extensions.TypedDict(
-    'RequestOptionalQueryParams',
-    {
-        'page': typing.Union[PageSchema, decimal.Decimal, int, ],
-        'size': typing.Union[SizeSchema, decimal.Decimal, int, ],
-    },
-    total=False
-)
-
-
-class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
-    pass
-
-
-request_query_project_id = api_client.QueryParameter(
-    name="project_id",
-    style=api_client.ParameterStyle.FORM,
-    schema=ProjectIdSchema,
-    required=True,
-    explode=True,
-)
-request_query_page = api_client.QueryParameter(
-    name="page",
-    style=api_client.ParameterStyle.FORM,
-    schema=PageSchema,
-    explode=True,
-)
-request_query_size = api_client.QueryParameter(
-    name="size",
-    style=api_client.ParameterStyle.FORM,
-    schema=SizeSchema,
-    explode=True,
-)
-SchemaFor200ResponseBodyApplicationJson = PaginatedDataSessionResponseSchema
-
-
-@dataclass
-class ApiResponseFor200(api_client.ApiResponse):
-    body: PaginatedDataSessionResponse
-
-
-@dataclass
-class ApiResponseFor200Async(api_client.AsyncApiResponse):
-    body: PaginatedDataSessionResponse
-
-
-_response_for_200 = api_client.OpenApiResponse(
-    response_cls=ApiResponseFor200,
-    response_cls_async=ApiResponseFor200Async,
-    content={
-        'application/json': api_client.MediaType(
-            schema=SchemaFor200ResponseBodyApplicationJson),
-    },
-)
-SchemaFor422ResponseBodyApplicationJson = HTTPValidationErrorSchema
+SchemaFor201ResponseBodyApplicationJson = CreateSessionResponseSchema
 
 
 @dataclass
-class ApiResponseFor422(api_client.ApiResponse):
-    body: HTTPValidationError
+class ApiResponseFor201(api_client.ApiResponse):
+    body: CreateSessionResponse
 
 
 @dataclass
-class ApiResponseFor422Async(api_client.AsyncApiResponse):
-    body: HTTPValidationError
+class ApiResponseFor201Async(api_client.AsyncApiResponse):
+    body: CreateSessionResponse
 
 
-_response_for_422 = api_client.OpenApiResponse(
-    response_cls=ApiResponseFor422,
-    response_cls_async=ApiResponseFor422Async,
+_response_for_201 = api_client.OpenApiResponse(
+    response_cls=ApiResponseFor201,
+    response_cls_async=ApiResponseFor201Async,
     content={
         'application/json': api_client.MediaType(
-            schema=SchemaFor422ResponseBodyApplicationJson),
+            schema=SchemaFor201ResponseBodyApplicationJson),
     },
 )
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
-    def _list_mapped_args(
+    def _create_mapped_args(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
-        _query_params = {}
-        if project_id is not None:
-            _query_params["project_id"] = project_id
-        if page is not None:
-            _query_params["page"] = page
-        if size is not None:
-            _query_params["size"] = size
-        args.query = _query_params
         return args
 
-    async def _alist_oapg(
+    async def _acreate_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
     ) -> typing.Union[
-        ApiResponseFor200Async,
+        ApiResponseFor201Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Get Sessions
+        Create Session
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_project_id,
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'get'.upper()
+        method = 'post'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             auth_settings=_auth,
             headers=_headers,
         )
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
                 raise exceptions.ApiStreamingException(
@@ -255,69 +160,51 @@
         # cleanup session / response
         response.http_response.close()
         await response.session.close()
     
         return api_response
 
 
-    def _list_oapg(
+    def _create_oapg(
         self,
-            query_params: typing.Optional[dict] = {},
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
         stream: bool = False,
     ) -> typing.Union[
-        ApiResponseFor200,
+        ApiResponseFor201,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Get Sessions
+        Create Session
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
-        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
         used_path = path.value
     
-        prefix_separator_iterator = None
-        for parameter in (
-            request_query_project_id,
-            request_query_page,
-            request_query_size,
-        ):
-            parameter_data = query_params.get(parameter.name, schemas.unset)
-            if parameter_data is schemas.unset:
-                continue
-            if prefix_separator_iterator is None:
-                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
-            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
-            for serialized_value in serialized_data.values():
-                used_path += serialized_value
-    
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
-        method = 'get'.upper()
+        method = 'post'.upper()
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
             auth_settings=_auth,
             headers=_headers,
         )
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
             auth_settings=_auth,
-            prefix_separator_iterator=prefix_separator_iterator,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
                                                     response,
@@ -337,87 +224,59 @@
     
         if not 200 <= api_response.status <= 299:
             raise exceptions.ApiException(api_response=api_response)
     
         return api_response
 
 
-class List(BaseApi):
+class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
-    async def alist(
+    async def acreate(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
-        ApiResponseFor200Async,
+        ApiResponseFor201Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
         )
-        return await self._alist_oapg(
-            query_params=args.query,
+        return await self._acreate_oapg(
         )
     
-    def list(
+    def create(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
-        ApiResponseFor200,
+        ApiResponseFor201,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
         )
-        return self._list_oapg(
-            query_params=args.query,
+        return self._create_oapg(
         )
 
-class ApiForget(BaseApi):
+class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
-    async def aget(
+    async def apost(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
-        ApiResponseFor200Async,
+        ApiResponseFor201Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
         )
-        return await self._alist_oapg(
-            query_params=args.query,
+        return await self._acreate_oapg(
         )
     
-    def get(
+    def post(
         self,
-        project_id: str,
-        page: typing.Optional[int] = None,
-        size: typing.Optional[int] = None,
     ) -> typing.Union[
-        ApiResponseFor200,
+        ApiResponseFor201,
         api_client.ApiResponseWithoutDeserialization,
     ]:
-        args = self._list_mapped_args(
-            project_id=project_id,
-            page=page,
-            size=size,
+        args = self._create_mapped_args(
         )
-        return self._list_oapg(
-            query_params=args.query,
+        return self._create_oapg(
         )
```

### Comparing `humanloop-0.4.8/humanloop/paths/sessions/post.py` & `humanloop-0.4.9/humanloop/paths/sessions/post.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/paths/sessions/post.pyi` & `humanloop-0.4.9/humanloop/paths/traces/post.py`

 * *Files 26% similar despite different names*

```diff
@@ -27,89 +27,159 @@
 import typing_extensions  # noqa: F401
 import uuid  # noqa: F401
 
 import frozendict  # noqa: F401
 
 from humanloop import schemas  # noqa: F401
 
-from humanloop.model.create_session_response import CreateSessionResponse as CreateSessionResponseSchema
+from humanloop.model.create_trace_response import CreateTraceResponse as CreateTraceResponseSchema
+from humanloop.model.http_validation_error import HTTPValidationError as HTTPValidationErrorSchema
+from humanloop.model.create_trace_request import CreateTraceRequest as CreateTraceRequestSchema
+from humanloop.model.trace_log_request import TraceLogRequest as TraceLogRequestSchema
 
-from humanloop.type.create_session_response import CreateSessionResponse
+from humanloop.type.trace_log_request import TraceLogRequest
+from humanloop.type.create_trace_response import CreateTraceResponse
+from humanloop.type.create_trace_request import CreateTraceRequest
+from humanloop.type.http_validation_error import HTTPValidationError
 
-SchemaFor201ResponseBodyApplicationJson = CreateSessionResponseSchema
+from . import path
+
+# body param
+SchemaForRequestBodyApplicationJson = CreateTraceRequestSchema
+
+
+request_body_create_trace_request = api_client.RequestBody(
+    content={
+        'application/json': api_client.MediaType(
+            schema=SchemaForRequestBodyApplicationJson),
+    },
+    required=True,
+)
+_auth = [
+    'APIKeyHeader',
+]
+SchemaFor200ResponseBodyApplicationJson = CreateTraceResponseSchema
 
 
 @dataclass
-class ApiResponseFor201(api_client.ApiResponse):
-    body: CreateSessionResponse
+class ApiResponseFor200(api_client.ApiResponse):
+    body: CreateTraceResponse
 
 
 @dataclass
-class ApiResponseFor201Async(api_client.AsyncApiResponse):
-    body: CreateSessionResponse
+class ApiResponseFor200Async(api_client.AsyncApiResponse):
+    body: CreateTraceResponse
 
 
-_response_for_201 = api_client.OpenApiResponse(
-    response_cls=ApiResponseFor201,
-    response_cls_async=ApiResponseFor201Async,
+_response_for_200 = api_client.OpenApiResponse(
+    response_cls=ApiResponseFor200,
+    response_cls_async=ApiResponseFor200Async,
     content={
         'application/json': api_client.MediaType(
-            schema=SchemaFor201ResponseBodyApplicationJson),
+            schema=SchemaFor200ResponseBodyApplicationJson),
     },
 )
+SchemaFor422ResponseBodyApplicationJson = HTTPValidationErrorSchema
+
+
+@dataclass
+class ApiResponseFor422(api_client.ApiResponse):
+    body: HTTPValidationError
+
+
+@dataclass
+class ApiResponseFor422Async(api_client.AsyncApiResponse):
+    body: HTTPValidationError
+
+
+_response_for_422 = api_client.OpenApiResponse(
+    response_cls=ApiResponseFor422,
+    response_cls_async=ApiResponseFor422Async,
+    content={
+        'application/json': api_client.MediaType(
+            schema=SchemaFor422ResponseBodyApplicationJson),
+    },
+)
+_status_code_to_response = {
+    '200': _response_for_200,
+    '422': _response_for_422,
+}
 _all_accept_content_types = (
     'application/json',
 )
 
 
 class BaseApi(api_client.Api):
 
     def _create_mapped_args(
         self,
+        logs: typing.List[TraceLogRequest],
     ) -> api_client.MappedArgs:
         args: api_client.MappedArgs = api_client.MappedArgs()
+        _body = {}
+        if logs is not None:
+            _body["logs"] = logs
+        args.body = _body
         return args
 
     async def _acreate_oapg(
         self,
+        body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
-        ApiResponseFor201Async,
+        ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         """
-        Create Session
+        Create Trace
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_create_trace_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = await self.api_client.async_call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
             timeout=timeout,
         )
     
         if stream:
             if not 200 <= response.http_response.status <= 299:
                 body = (await response.http_response.content.read()).decode("utf-8")
@@ -162,48 +232,66 @@
         await response.session.close()
     
         return api_response
 
 
     def _create_oapg(
         self,
+        body: typing.Any = None,
         skip_deserialization: bool = True,
         timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
         accept_content_types: typing.Tuple[str] = _all_accept_content_types,
+        content_type: str = 'application/json',
         stream: bool = False,
     ) -> typing.Union[
-        ApiResponseFor201,
+        ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         """
-        Create Session
+        Create Trace
         :param skip_deserialization: If true then api_response.response will be set but
             api_response.body and api_response.headers will not be deserialized into schema
             class instances
         """
         used_path = path.value
     
         _headers = HTTPHeaderDict()
         # TODO add cookie handling
         if accept_content_types:
             for accept_content_type in accept_content_types:
                 _headers.add('Accept', accept_content_type)
         method = 'post'.upper()
+        _headers.add('Content-Type', content_type)
+    
+        if body is schemas.unset:
+            raise exceptions.ApiValueError(
+                'The required body parameter has an invalid value of: unset. Set a valid value instead')
+        _fields = None
+        _body = None
         request_before_hook(
             resource_path=used_path,
             method=method,
             configuration=self.api_client.configuration,
+            body=body,
             auth_settings=_auth,
             headers=_headers,
         )
+        serialized_data = request_body_create_trace_request.serialize(body, content_type)
+        if 'fields' in serialized_data:
+            _fields = serialized_data['fields']
+        elif 'body' in serialized_data:
+            _body = serialized_data['body']
     
         response = self.api_client.call_api(
             resource_path=used_path,
             method=method,
             headers=_headers,
+            fields=_fields,
+            serialized_body=_body,
+            body=body,
             auth_settings=_auth,
             timeout=timeout,
         )
     
         response_for_status = _status_code_to_response.get(str(response.http_response.status))
         if response_for_status:
             api_response = response_for_status.deserialize(
@@ -229,54 +317,66 @@
 
 
 class Create(BaseApi):
     # this class is used by api classes that refer to endpoints with operationId fn names
 
     async def acreate(
         self,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
-        ApiResponseFor201Async,
+        ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._create_mapped_args(
+            logs=logs,
         )
         return await self._acreate_oapg(
+            body=args.body,
         )
     
     def create(
         self,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
-        ApiResponseFor201,
+        ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._create_mapped_args(
+            logs=logs,
         )
         return self._create_oapg(
+            body=args.body,
         )
 
 class ApiForpost(BaseApi):
     # this class is used by api classes that refer to endpoints by path and http method names
 
     async def apost(
         self,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
-        ApiResponseFor201Async,
+        ApiResponseFor200Async,
         api_client.ApiResponseWithoutDeserializationAsync,
         AsyncGeneratorResponse,
     ]:
         args = self._create_mapped_args(
+            logs=logs,
         )
         return await self._acreate_oapg(
+            body=args.body,
         )
     
     def post(
         self,
+        logs: typing.List[TraceLogRequest],
     ) -> typing.Union[
-        ApiResponseFor201,
+        ApiResponseFor200,
         api_client.ApiResponseWithoutDeserialization,
     ]:
         args = self._create_mapped_args(
+            logs=logs,
         )
         return self._create_oapg(
+            body=args.body,
         )
```

### Comparing `humanloop-0.4.8/humanloop/request_after_hook.py` & `humanloop-0.4.9/humanloop/request_after_hook.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/request_before_hook.py` & `humanloop-0.4.9/humanloop/request_before_hook.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/rest.py` & `humanloop-0.4.9/humanloop/rest.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/schemas.py` & `humanloop-0.4.9/humanloop/schemas.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/agent_config_request.py` & `humanloop-0.4.9/humanloop/type/agent_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/agent_config_response.py` & `humanloop-0.4.9/humanloop/type/agent_config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/base_metric_response.py` & `humanloop-0.4.9/humanloop/type/base_metric_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/categorical_feedback_label.py` & `humanloop-0.4.9/humanloop/type/categorical_feedback_label.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/chat_data_response.py` & `humanloop-0.4.9/humanloop/type/chat_data_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/chat_deployed_request.py` & `humanloop-0.4.9/humanloop/type/chat_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,41 +10,41 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.chat_data_response import ChatDataResponse
+from humanloop.type.usage import Usage
 
-class RequiredChatDeployedRequest(TypedDict):
-    # Unique project name.
-    project: str
+class RequiredChatResponse(TypedDict):
+    # Unique identifier of the parent project.
+    project_id: str
 
-    # The messages passed to the to provider chat endpoint.
-    messages: typing.List[ChatMessage]
+    # Array containing the chat responses.
+    data: typing.List[ChatDataResponse]
 
-class OptionalChatDeployedRequest(TypedDict, total=False):
-    # The inputs passed to the chat template.
-    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-    # Identifies where the model was called from.
-    source: str
-
-    # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
-    provider_api_keys: ProviderApiKeys
+    # The raw responses returned by the model provider.
+    provider_responses: typing.List[typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
+class OptionalChatResponse(TypedDict, total=False):
     # The number of chat responses.
     num_samples: int
 
-    # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
-    stream: bool
+    # Include the log probabilities of the top n tokens in the provider_response
+    logprobs: int
+
+    # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
+    suffix: str
 
     # End-user ID passed through to provider call.
     user: str
 
+    # Counts of the number of tokens used and related stats.
+    usage: Usage
+
     # Any additional metadata to record.
     metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-class ChatDeployedRequest(RequiredChatDeployedRequest, OptionalChatDeployedRequest):
+class ChatResponse(RequiredChatResponse, OptionalChatResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/chat_experiment_request.py` & `humanloop-0.4.9/humanloop/type/trace_log_request.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,44 +10,53 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
+from humanloop.type.agent_config_request import AgentConfigRequest
 from humanloop.type.chat_message import ChatMessage
-from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.generic_config_request import GenericConfigRequest
+from humanloop.type.tool_config_request import ToolConfigRequest
+from humanloop.type.trace_model_config_request import TraceModelConfigRequest
+
+class RequiredTraceLogRequest(TypedDict):
+    # Unique function name. If no function exists with this name, a new function will be created.
+    function_name: str
+
+class OptionalTraceLogRequest(TypedDict, total=False):
+    # Unique ID of an experiment trial to associate to the log.
+    trial_id: str
 
-class RequiredChatExperimentRequest(TypedDict):
-    # Unique project name.
-    project: str
+    # The inputs passed to the prompt template.
+    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
     # The messages passed to the to provider chat endpoint.
     messages: typing.List[ChatMessage]
 
-    # If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations.
-    experiment_id: str
-
-class OptionalChatExperimentRequest(TypedDict, total=False):
-    # The inputs passed to the chat template.
-    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # Generated output from your model for the provided inputs. Can be `None` if logging an error.
+    output: str
 
     # Identifies where the model was called from.
     source: str
 
-    # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
-    provider_api_keys: ProviderApiKeys
+    # The config used for this generation. Required unless `trial_id` is provided.
+    config: typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]
+
+    # Any additional metadata to record.
+    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # The number of chat responses, where each chat response will use a model configuration sampled from the experiment.
-    num_samples: int
+    # Error message if the log is an error.
+    error: str
 
-    # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
-    stream: bool
+    # Duration of the logged event in seconds.
+    duration: typing.Union[int, float]
 
-    # End-user ID passed through to provider call.
-    user: str
+    # User-defined timestamp for when the log was created.
+    created_at: datetime
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # List of children logs.
+    children: typing.List["TraceLogRequest"]
 
-class ChatExperimentRequest(RequiredChatExperimentRequest, OptionalChatExperimentRequest):
+class TraceLogRequest(RequiredTraceLogRequest, OptionalTraceLogRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/chat_message.py` & `humanloop-0.4.9/humanloop/type/chat_message.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/chat_model_config_request.py` & `humanloop-0.4.9/humanloop/type/completion_response.py`

 * *Files 21% similar despite different names*

```diff
@@ -10,44 +10,41 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.data_response import DataResponse
+from humanloop.type.usage import Usage
 
-class RequiredChatModelConfigRequest(TypedDict):
-    # Unique project name.
-    project: str
+class RequiredCompletionResponse(TypedDict):
+    # Unique identifier of the parent project.
+    project_id: str
 
-    # The messages passed to the to provider chat endpoint.
-    messages: typing.List[ChatMessage]
+    # Array containing the generation responses.
+    data: typing.List[DataResponse]
 
-    # Identifies the model configuration used to create a chat response.
-    model_config_id: str
+    # The raw responses returned by the model provider.
+    provider_responses: typing.List[typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-class OptionalChatModelConfigRequest(TypedDict, total=False):
-    # The inputs passed to the chat template.
-    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-    # Identifies where the model was called from.
-    source: str
-
-    # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
-    provider_api_keys: ProviderApiKeys
-
-    # The number of chat responses.
+class OptionalCompletionResponse(TypedDict, total=False):
+    # How many completions to make for each set of inputs.
     num_samples: int
 
-    # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
-    stream: bool
+    # Include the log probabilities of the top n tokens in the provider_response
+    logprobs: int
+
+    # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
+    suffix: str
 
     # End-user ID passed through to provider call.
     user: str
 
+    # Counts of the number of tokens used and related stats.
+    usage: Usage
+
     # Any additional metadata to record.
     metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-class ChatModelConfigRequest(RequiredChatModelConfigRequest, OptionalChatModelConfigRequest):
+class CompletionResponse(RequiredCompletionResponse, OptionalCompletionResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/chat_request.py` & `humanloop-0.4.9/humanloop/type/chat_experiment_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -11,44 +11,58 @@
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 from humanloop.type.chat_message import ChatMessage
-from humanloop.type.model_config_chat_request import ModelConfigChatRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
 
-class RequiredChatRequest(TypedDict):
-    # Unique project name.
-    project: str
-
+class RequiredChatExperimentRequest(TypedDict):
     # The messages passed to the to provider chat endpoint.
     messages: typing.List[ChatMessage]
 
-    # The model configuration used to create a chat response.
-    model_config: ModelConfigChatRequest
+    # If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations.
+    experiment_id: str
+
+class OptionalChatExperimentRequest(TypedDict, total=False):
+    # Unique function name. If no function exists with this name, a new function will be created.
+    project: str
+
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
+
+    # ID of the session to associate the datapoint.
+    session_id: str
+
+    # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
+    session_reference_id: str
+
+    # ID associated to the parent datapoint in a session.
+    parent_id: str
 
-class OptionalChatRequest(TypedDict, total=False):
-    # The inputs passed to the chat template.
+    # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
+    parent_reference_id: str
+
+    # The inputs passed to the prompt template.
     inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
     # Identifies where the model was called from.
     source: str
 
+    # Any additional metadata to record.
+    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+
     # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
     provider_api_keys: ProviderApiKeys
 
-    # The number of chat responses.
+    # The number of chat responses, where each chat response will use a model configuration sampled from the experiment.
     num_samples: int
 
     # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
     stream: bool
 
     # End-user ID passed through to provider call.
     user: str
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-class ChatRequest(RequiredChatRequest, OptionalChatRequest):
+class ChatExperimentRequest(RequiredChatExperimentRequest, OptionalChatExperimentRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/chat_response.py` & `humanloop-0.4.9/humanloop/type/session_response.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,41 +10,30 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.chat_data_response import ChatDataResponse
-from humanloop.type.usage import Usage
+from humanloop.type.session_project_response import SessionProjectResponse
 
-class RequiredChatResponse(TypedDict):
-    # Unique identifier of the parent project.
-    project_id: str
+class RequiredSessionResponse(TypedDict):
+    # String ID of session. Starts with `sesh_`.
+    id: str
 
-    # Array containing the chat responses.
-    data: typing.List[ChatDataResponse]
+    # List of projects that have datapoints associated to this session.
+    projects: typing.List[SessionProjectResponse]
 
-    # The raw responses returned by the model provider.
-    provider_responses: typing.List[typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # Number of datapoints associated to this session.
+    datapoints_count: int
 
-class OptionalChatResponse(TypedDict, total=False):
-    # The number of chat responses.
-    num_samples: int
+    created_at: datetime
 
-    # Include the log probabilities of the top n tokens in the provider_response
-    logprobs: int
+class OptionalSessionResponse(TypedDict, total=False):
+    # Inputs for the first datapoint in the session.
+    first_inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
-    suffix: str
+    # Output for the last datapoint in the session.
+    last_output: str
 
-    # End-user ID passed through to provider call.
-    user: str
-
-    # Counts of the number of tokens used and related stats.
-    usage: Usage
-
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-class ChatResponse(RequiredChatResponse, OptionalChatResponse):
+class SessionResponse(RequiredSessionResponse, OptionalSessionResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/chat_role.py` & `humanloop-0.4.9/humanloop/type/chat_role.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/completion_deployed_request.py` & `humanloop-0.4.9/humanloop/type/completion_request.py`

 * *Files 19% similar despite different names*

```diff
@@ -10,27 +10,49 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
+from humanloop.type.model_config_completion_request import ModelConfigCompletionRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
 
-class RequiredCompletionDeployedRequest(TypedDict):
-    # Unique project name.
+class RequiredCompletionRequest(TypedDict):
+    # The model configuration used to generate.
+    model_config: ModelConfigCompletionRequest
+
+class OptionalCompletionRequest(TypedDict, total=False):
+    # Unique function name. If no function exists with this name, a new function will be created.
     project: str
 
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
+
+    # ID of the session to associate the datapoint.
+    session_id: str
+
+    # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
+    session_reference_id: str
+
+    # ID associated to the parent datapoint in a session.
+    parent_id: str
+
+    # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
+    parent_reference_id: str
+
     # The inputs passed to the prompt template.
     inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-class OptionalCompletionDeployedRequest(TypedDict, total=False):
     # Identifies where the model was called from.
     source: str
 
+    # Any additional metadata to record.
+    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+
     # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
     provider_api_keys: ProviderApiKeys
 
     # The number of generations.
     num_samples: int
 
     # Include the log probabilities of the top n tokens in the provider_response
@@ -41,12 +63,9 @@
 
     # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
     suffix: str
 
     # End-user ID passed through to provider call.
     user: str
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-class CompletionDeployedRequest(RequiredCompletionDeployedRequest, OptionalCompletionDeployedRequest):
+class CompletionRequest(RequiredCompletionRequest, OptionalCompletionRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/completion_experiment_request.py` & `humanloop-0.4.9/humanloop/type/data_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,46 +10,37 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.provider_api_keys import ProviderApiKeys
+from humanloop.type.tool_result_response import ToolResultResponse
 
-class RequiredCompletionExperimentRequest(TypedDict):
-    # Unique project name.
-    project: str
+class RequiredDataResponse(TypedDict):
+    # Unique ID for the model inputs and output logged to Humanloop. Use this when recording feedback later.
+    id: str
 
-    # The inputs passed to the prompt template.
-    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-    # If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations.
-    experiment_id: str
-
-class OptionalCompletionExperimentRequest(TypedDict, total=False):
-    # Identifies where the model was called from.
-    source: str
+    # The index for the sampled generation for a given input. The num_samples request parameter controls how many samples are generated.
+    index: int
 
-    # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
-    provider_api_keys: ProviderApiKeys
+    # Output text returned from the provider model with leading and trailing whitespaces stripped.
+    output: str
 
-    # The number of chat responses, where each chat response will use a model configuration sampled from the experiment.
-    num_samples: int
+    # Raw output text returned from the provider model.
+    raw_output: str
 
-    # Include the log probabilities of the top n tokens in the provider_response
-    logprobs: int
-
-    # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
-    stream: bool
+    # The inputs passed to the prompt template.
+    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
-    suffix: str
+    # The model configuration used to create the generation.
+    model_config_id: str
 
-    # End-user ID passed through to provider call.
-    user: str
+class OptionalDataResponse(TypedDict, total=False):
+    # Why the completion ended. Usually one of 'stop' (indicating a stop token was encountered), or 'length' (indicating the max tokens limit has been reached). It will be set as null for the intermediary responses during a stream, and will only be set as non-null for the final streamed token.
+    finish_reason: str
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # Results of any tools run during the generation.
+    tools: typing.List[ToolResultResponse]
 
-class CompletionExperimentRequest(RequiredCompletionExperimentRequest, OptionalCompletionExperimentRequest):
+class DataResponse(RequiredDataResponse, OptionalDataResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/completion_model_config_request.py` & `humanloop-0.4.9/humanloop/type/completion_experiment_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -12,44 +12,59 @@
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 from humanloop.type.provider_api_keys import ProviderApiKeys
 
-class RequiredCompletionModelConfigRequest(TypedDict):
-    # Unique project name.
+class RequiredCompletionExperimentRequest(TypedDict):
+    # If an experiment ID is provided a model configuration will be sampled from the experiments active model configurations.
+    experiment_id: str
+
+class OptionalCompletionExperimentRequest(TypedDict, total=False):
+    # Unique function name. If no function exists with this name, a new function will be created.
     project: str
 
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
+
+    # ID of the session to associate the datapoint.
+    session_id: str
+
+    # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
+    session_reference_id: str
+
+    # ID associated to the parent datapoint in a session.
+    parent_id: str
+
+    # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
+    parent_reference_id: str
+
     # The inputs passed to the prompt template.
     inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # Identifies the model configuration used to create a chat response.
-    model_config_id: str
-
-class OptionalCompletionModelConfigRequest(TypedDict, total=False):
     # Identifies where the model was called from.
     source: str
 
+    # Any additional metadata to record.
+    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+
     # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
     provider_api_keys: ProviderApiKeys
 
-    # The number of generations.
+    # The number of chat responses, where each chat response will use a model configuration sampled from the experiment.
     num_samples: int
 
     # Include the log probabilities of the top n tokens in the provider_response
     logprobs: int
 
     # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
     stream: bool
 
     # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
     suffix: str
 
     # End-user ID passed through to provider call.
     user: str
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-class CompletionModelConfigRequest(RequiredCompletionModelConfigRequest, OptionalCompletionModelConfigRequest):
+class CompletionExperimentRequest(RequiredCompletionExperimentRequest, OptionalCompletionExperimentRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/completion_request.py` & `humanloop-0.4.9/humanloop/type/completion_deployed_request.py`

 * *Files 24% similar despite different names*

```diff
@@ -10,31 +10,47 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.model_config_completion_request import ModelConfigCompletionRequest
 from humanloop.type.provider_api_keys import ProviderApiKeys
 
-class RequiredCompletionRequest(TypedDict):
-    # Unique project name.
+class RequiredCompletionDeployedRequest(TypedDict):
+    pass
+
+class OptionalCompletionDeployedRequest(TypedDict, total=False):
+    # Unique function name. If no function exists with this name, a new function will be created.
     project: str
 
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
+
+    # ID of the session to associate the datapoint.
+    session_id: str
+
+    # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
+    session_reference_id: str
+
+    # ID associated to the parent datapoint in a session.
+    parent_id: str
+
+    # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
+    parent_reference_id: str
+
     # The inputs passed to the prompt template.
     inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # The model configuration used to generate.
-    model_config: ModelConfigCompletionRequest
-
-class OptionalCompletionRequest(TypedDict, total=False):
     # Identifies where the model was called from.
     source: str
 
+    # Any additional metadata to record.
+    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+
     # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
     provider_api_keys: ProviderApiKeys
 
     # The number of generations.
     num_samples: int
 
     # Include the log probabilities of the top n tokens in the provider_response
@@ -45,12 +61,9 @@
 
     # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
     suffix: str
 
     # End-user ID passed through to provider call.
     user: str
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
-class CompletionRequest(RequiredCompletionRequest, OptionalCompletionRequest):
+class CompletionDeployedRequest(RequiredCompletionDeployedRequest, OptionalCompletionDeployedRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/completion_response.py` & `humanloop-0.4.9/humanloop/type/model_config_completion_request.py`

 * *Files 21% similar despite different names*

```diff
@@ -10,41 +10,47 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.data_response import DataResponse
-from humanloop.type.usage import Usage
+from humanloop.type.model_endpoints import ModelEndpoints
+from humanloop.type.model_providers import ModelProviders
 
-class RequiredCompletionResponse(TypedDict):
-    # Unique identifier of the parent project.
-    project_id: str
+class RequiredModelConfigCompletionRequest(TypedDict):
+    # The model instance used. E.g. text-davinci-002.
+    model: str
 
-    # Array containing the generation responses.
-    data: typing.List[DataResponse]
+    # Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
+    prompt_template: str
 
-    # The raw responses returned by the model provider.
-    provider_responses: typing.List[typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+class OptionalModelConfigCompletionRequest(TypedDict, total=False):
+    # The company providing the underlying model service.
+    provider: ModelProviders
 
-class OptionalCompletionResponse(TypedDict, total=False):
-    # How many completions to make for each set of inputs.
-    num_samples: int
+    # The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
+    max_tokens: int
 
-    # Include the log probabilities of the top n tokens in the provider_response
-    logprobs: int
+    # What sampling temperature to use when making a generation. Higher values means the model will be more creative.
+    temperature: typing.Union[int, float]
 
-    # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
-    suffix: str
+    # An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
+    top_p: typing.Union[int, float]
 
-    # End-user ID passed through to provider call.
-    user: str
+    # The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.
+    stop: typing.Union[str, typing.List[str]]
 
-    # Counts of the number of tokens used and related stats.
-    usage: Usage
+    # Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.
+    presence_penalty: typing.Union[int, float]
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.
+    frequency_penalty: typing.Union[int, float]
 
-class CompletionResponse(RequiredCompletionResponse, OptionalCompletionResponse):
+    # Other parameter values to be passed to the provider call.
+    other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+
+    # The provider model endpoint used.
+    endpoint: ModelEndpoints
+
+class ModelConfigCompletionRequest(RequiredModelConfigCompletionRequest, OptionalModelConfigCompletionRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/config_response.py` & `humanloop-0.4.9/humanloop/type/config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/config_type.py` & `humanloop-0.4.9/humanloop/type/config_type.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/create_experiment_request.py` & `humanloop-0.4.9/humanloop/type/create_experiment_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/create_log_response.py` & `humanloop-0.4.9/humanloop/type/create_log_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/create_project_request.py` & `humanloop-0.4.9/humanloop/type/create_project_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/create_session_response.py` & `humanloop-0.4.9/humanloop/type/create_session_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/create_trace_request.py` & `humanloop-0.4.9/humanloop/type/create_trace_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/create_trace_response.py` & `humanloop-0.4.9/humanloop/type/create_trace_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/data_response.py` & `humanloop-0.4.9/humanloop/type/update_experiment_request.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,37 +10,27 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.tool_result_response import ToolResultResponse
+from humanloop.type.positive_label import PositiveLabel
 
-class RequiredDataResponse(TypedDict):
-    # Unique ID for the model inputs and output logged to Humanloop. Use this when recording feedback later.
-    id: str
-
-    # The index for the sampled generation for a given input. The num_samples request parameter controls how many samples are generated.
-    index: int
-
-    # Output text returned from the provider model with leading and trailing whitespaces stripped.
-    output: str
-
-    # Raw output text returned from the provider model.
-    raw_output: str
+class RequiredUpdateExperimentRequest(TypedDict):
+    pass
 
-    # The inputs passed to the prompt template.
-    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+class OptionalUpdateExperimentRequest(TypedDict, total=False):
+    # Name of experiment.
+    name: str
 
-    # The model configuration used to create the generation.
-    model_config_id: str
+    # Feedback labels to treat as positive user feedback. Used to monitor the performance of model configs in the experiment.
+    positive_labels: typing.List[PositiveLabel]
 
-class OptionalDataResponse(TypedDict, total=False):
-    # Why the completion ended. Usually one of 'stop' (indicating a stop token was encountered), or 'length' (indicating the max tokens limit has been reached). It will be set as null for the intermediary responses during a stream, and will only be set as non-null for the final streamed token.
-    finish_reason: str
+    # Model configs to add to this experiment.
+    config_ids_to_register: typing.List[str]
 
-    # Results of any tools run during the generation.
-    tools: typing.List[ToolResultResponse]
+    # Model configs in this experiment to be deactivated.
+    config_ids_to_deregister: typing.List[str]
 
-class DataResponse(RequiredDataResponse, OptionalDataResponse):
+class UpdateExperimentRequest(RequiredUpdateExperimentRequest, OptionalUpdateExperimentRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/experiment_config_response.py` & `humanloop-0.4.9/humanloop/type/experiment_config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/experiment_response.py` & `humanloop-0.4.9/humanloop/type/experiment_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/experiment_status.py` & `humanloop-0.4.9/humanloop/type/experiment_status.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/experiments_list_response.py` & `humanloop-0.4.9/humanloop/type/experiments_list_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback.py` & `humanloop-0.4.9/humanloop/type/feedback.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_class.py` & `humanloop-0.4.9/humanloop/type/feedback_class.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_label_request.py` & `humanloop-0.4.9/humanloop/type/feedback_label_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_request.py` & `humanloop-0.4.9/humanloop/type/feedback_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_response.py` & `humanloop-0.4.9/humanloop/type/feedback_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_submit_request.py` & `humanloop-0.4.9/humanloop/type/feedback_submit_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_submit_response.py` & `humanloop-0.4.9/humanloop/type/feedback_submit_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_type.py` & `humanloop-0.4.9/humanloop/type/feedback_type.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_type_model.py` & `humanloop-0.4.9/humanloop/type/feedback_type_model.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_type_request.py` & `humanloop-0.4.9/humanloop/type/feedback_type_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/feedback_types.py` & `humanloop-0.4.9/humanloop/type/feedback_types.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/generic_config_request.py` & `humanloop-0.4.9/humanloop/type/generic_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/generic_config_response.py` & `humanloop-0.4.9/humanloop/type/generic_config_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/get_model_config_response.py` & `humanloop-0.4.9/humanloop/type/get_model_config_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,34 +11,34 @@
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 from humanloop.type.config_response import ConfigResponse
-from humanloop.type.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.type.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
 
 class RequiredGetModelConfigResponse(TypedDict):
+    # String ID of project the model config belongs to. Starts with `pr_`.
+    project_id: str
+
+    # Name of the project the model config belongs to.
+    project_name: str
+
     created_at: datetime
 
     updated_at: datetime
 
     last_used: datetime
 
     config: ConfigResponse
 
 class OptionalGetModelConfigResponse(TypedDict, total=False):
-    # String ID of project the model config belongs to. Starts with `pr_`.
-    project_id: str
-
-    # Name of the project the model config belongs to.
-    project_name: str
-
     # Feedback statistics for the project model config.
-    feedback_stats: typing.List[SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse]
+    feedback_stats: typing.List[ProjectModelConfigFeedbackStatsResponse]
 
     # Number of datapoints associated with this project model config.
     num_datapoints: int
 
     # The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment.
     experiment_id: str
```

### Comparing `humanloop-0.4.8/humanloop/type/http_validation_error.py` & `humanloop-0.4.9/humanloop/type/http_validation_error.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/label_sentiment.py` & `humanloop-0.4.9/humanloop/type/label_sentiment.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/log_datapoint_request.py` & `humanloop-0.4.9/humanloop/type/log_datapoint_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/log_model_config_request.py` & `humanloop-0.4.9/humanloop/type/log_model_config_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/log_request.py` & `humanloop-0.4.9/humanloop/type/log_request.py`

 * *Files 6% similar despite different names*

```diff
@@ -24,50 +24,53 @@
 class RequiredLogRequest(TypedDict):
     pass
 
 class OptionalLogRequest(TypedDict, total=False):
     # Unique function name. If no function exists with this name, a new function will be created.
     project: str
 
-    # A unique string to reference the datapoint. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a subsequent log request.
-    reference_id: str
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
 
     # ID of the session to associate the datapoint.
     session_id: str
 
     # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
     session_reference_id: str
 
     # ID associated to the parent datapoint in a session.
     parent_id: str
 
     # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
     parent_reference_id: str
 
-    # Unique ID of an experiment trial to associate to the log.
-    trial_id: str
-
     # The inputs passed to the prompt template.
     inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
+    # Identifies where the model was called from.
+    source: str
+
+    # Any additional metadata to record.
+    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+
+    # A unique string to reference the datapoint. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a subsequent log request.
+    reference_id: str
+
+    # Unique ID of an experiment trial to associate to the log.
+    trial_id: str
+
     # The messages passed to the to provider chat endpoint.
     messages: typing.List[ChatMessage]
 
     # Generated output from your model for the provided inputs. Can be `None` if logging an error, or if logging a parent datapoint with the intention to populate it later
     output: str
 
-    # Identifies where the model was called from.
-    source: str
-
     # The model config used for this generation. Required unless `trial_id` is provided.
     config: typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]
 
-    # Any additional metadata to record.
-    metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
-
     # Optional parameter to provide feedback with your logged datapoint.
     feedback: typing.Union[Feedback, typing.List[Feedback]]
 
     # User defined timestamp for when the log was created. 
     created_at: datetime
 
     # Error message if the log is an error.
```

### Comparing `humanloop-0.4.8/humanloop/type/log_response.py` & `humanloop-0.4.9/humanloop/type/log_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -16,63 +16,63 @@
 
 from humanloop.type.chat_message import ChatMessage
 from humanloop.type.config_response import ConfigResponse
 from humanloop.type.feedback import Feedback
 from humanloop.type.project_config_response import ProjectConfigResponse
 
 class RequiredLogResponse(TypedDict):
-    # Function name. If it does not exist, a new function will be created.
-    project: str
-
     config: ConfigResponse
 
     # String ID of logged datapoint. Starts with `data_`.
     id: str
 
-    # String ID of project the datapoint belongs to. Starts with `pr_`.
-    project_id: str
-
 class OptionalLogResponse(TypedDict, total=False):
-    # A unique string to reference the datapoint. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a subsequent log request.
-    reference_id: str
+    # Unique function name. If no function exists with this name, a new function will be created.
+    project: str
 
-    # Session ID.
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
+
+    # ID of the session to associate the datapoint.
     session_id: str
 
     # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
     session_reference_id: str
 
-    # Id associated to the parent datapoint. Useful when providing a trace from a chain.
+    # ID associated to the parent datapoint in a session.
     parent_id: str
 
     # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
     parent_reference_id: str
 
-    # Unique ID of an experiment trial to associate to the log.
-    trial_id: str
-
     # The inputs passed to the prompt template.
     inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # The messages passed to the to provider chat endpoint.
-    messages: typing.List[ChatMessage]
-
-    # Generated output from your model for the provided inputs.
-    output: str
-
     # Identifies where the model was called from.
     source: str
 
-    # Additional metadata logged for reference.
+    # Any additional metadata to record.
     metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # Feedback associated to the datapoint.
+    # A unique string to reference the datapoint. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a subsequent log request.
+    reference_id: str
+
+    # Unique ID of an experiment trial to associate to the log.
+    trial_id: str
+
+    # The messages passed to the to provider chat endpoint.
+    messages: typing.List[ChatMessage]
+
+    # Generated output from your model for the provided inputs. Can be `None` if logging an error, or if logging a parent datapoint with the intention to populate it later
+    output: str
+
+    # Optional parameter to provide feedback with your logged datapoint.
     feedback: typing.Union[Feedback, typing.List[Feedback]]
 
-    # Timestamp for when the datapoint was created.
+    # User defined timestamp for when the log was created. 
     created_at: datetime
 
     # Error message if the log is an error.
     error: str
 
     # Duration of the logged event in seconds.
     duration: typing.Union[int, float]
```

### Comparing `humanloop-0.4.8/humanloop/type/logs_log_response.py` & `humanloop-0.4.9/humanloop/type/logs_log_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/model_config_chat_request.py` & `humanloop-0.4.9/humanloop/type/model_config_chat_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/model_config_completion_request.py` & `humanloop-0.4.9/humanloop/type/trace_model_config_request.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,25 +10,29 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
+from humanloop.type.chat_message import ChatMessage
 from humanloop.type.model_endpoints import ModelEndpoints
 from humanloop.type.model_providers import ModelProviders
 
-class RequiredModelConfigCompletionRequest(TypedDict):
+class RequiredTraceModelConfigRequest(TypedDict):
     # The model instance used. E.g. text-davinci-002.
     model: str
 
-    # Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    prompt_template: str
+    type: str
+
+class OptionalTraceModelConfigRequest(TypedDict, total=False):
+    description: str
+
+    name: str
 
-class OptionalModelConfigCompletionRequest(TypedDict, total=False):
     # The company providing the underlying model service.
     provider: ModelProviders
 
     # The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
     max_tokens: int
 
     # What sampling temperature to use when making a generation. Higher values means the model will be more creative.
@@ -48,9 +52,15 @@
 
     # Other parameter values to be passed to the provider call.
     other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
     # The provider model endpoint used.
     endpoint: ModelEndpoints
 
-class ModelConfigCompletionRequest(RequiredModelConfigCompletionRequest, OptionalModelConfigCompletionRequest):
+    # Prompt template that will take your specified inputs to form your final request to the model. Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
+    prompt_template: str
+
+    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. Input variables within the template should be specified with syntax: {{INPUT_NAME}}.
+    chat_template: typing.List[ChatMessage]
+
+class TraceModelConfigRequest(RequiredTraceModelConfigRequest, OptionalTraceModelConfigRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/model_endpoints.py` & `humanloop-0.4.9/humanloop/type/model_endpoints.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/model_providers.py` & `humanloop-0.4.9/humanloop/type/model_providers.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/paginated_data_log_response.py` & `humanloop-0.4.9/humanloop/type/paginated_data_log_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/paginated_data_project_response.py` & `humanloop-0.4.9/humanloop/type/paginated_data_project_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/paginated_data_session_response.py` & `humanloop-0.4.9/humanloop/type/paginated_data_session_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/positive_label.py` & `humanloop-0.4.9/humanloop/type/positive_label.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/project_config_response.py` & `humanloop-0.4.9/humanloop/type/project_response.py`

 * *Files 17% similar despite different names*

```diff
@@ -10,37 +10,49 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.config_response import ConfigResponse
-from humanloop.type.src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse
+from humanloop.type.config_type import ConfigType
+from humanloop.type.experiment_response import ExperimentResponse
+from humanloop.type.feedback_types import FeedbackTypes
+from humanloop.type.project_config_response import ProjectConfigResponse
+from humanloop.type.project_user_response import ProjectUserResponse
 
-class RequiredProjectConfigResponse(TypedDict):
-    created_at: datetime
+class RequiredProjectResponse(TypedDict):
+    # Project ID
+    id: str
 
-    updated_at: datetime
+    # Project ID for internal Humanloop use.
+    internal_id: int
+
+    # Unique project name.
+    name: str
+
+    # Users associated to the project.
+    users: typing.List[ProjectUserResponse]
 
-    last_used: datetime
+    # The count of datapoints that have been logged to the project.
+    data_count: int
 
-    config: ConfigResponse
+    feedback_types: FeedbackTypes
 
-class OptionalProjectConfigResponse(TypedDict, total=False):
-    # String ID of project the model config belongs to. Starts with `pr_`.
-    project_id: str
+    # Unique ID of the team the project belongs to. Starts with `tm_`.
+    team_id: str
 
-    # Name of the project the model config belongs to.
-    project_name: str
+    created_at: datetime
+
+    updated_at: datetime
 
-    # Feedback statistics for the project model config.
-    feedback_stats: typing.List[SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse]
+class OptionalProjectResponse(TypedDict, total=False):
+    # Experiment that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set.
+    active_experiment: ExperimentResponse
 
-    # Number of datapoints associated with this project model config.
-    num_datapoints: int
+    # Config that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set.
+    active_config: ProjectConfigResponse
 
-    # The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment.
-    experiment_id: str
+    config_type: ConfigType
 
-class ProjectConfigResponse(RequiredProjectConfigResponse, OptionalProjectConfigResponse):
+class ProjectResponse(RequiredProjectResponse, OptionalProjectResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/project_model_config_request.py` & `humanloop-0.4.9/humanloop/type/project_model_config_request.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,39 +15,30 @@
 from typing_extensions import TypedDict, Literal
 
 from humanloop.type.chat_message import ChatMessage
 from humanloop.type.model_endpoints import ModelEndpoints
 from humanloop.type.model_providers import ModelProviders
 
 class RequiredProjectModelConfigRequest(TypedDict):
-    # What model instance to use for the generation. e.g. text-davinci-002.
+    # The model instance used. E.g. text-davinci-002.
     model: str
 
     # Unique project name. If it does not exist, a new project will be created.
     project: str
 
 class OptionalProjectModelConfigRequest(TypedDict, total=False):
     # The company providing the underlying model service.
     provider: ModelProviders
 
-    # Which of the providers model endpoints to use. For example Complete or Edit.
-    endpoint: ModelEndpoints
-
-    # Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    prompt_template: str
-
-    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    chat_template: typing.List[ChatMessage]
+    # The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
+    max_tokens: int
 
     # What sampling temperature to use when making a generation. Higher values means the model will be more creative.
     temperature: typing.Union[int, float]
 
-    # The maximum number of tokens to generate in the completion.
-    max_tokens: int
-
     # An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
     top_p: typing.Union[int, float]
 
     # The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.
     stop: typing.Union[str, typing.List[str]]
 
     # Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.
@@ -61,9 +52,18 @@
 
     # A friendly display name for the model config. If not provided, a name will be generated.
     name: str
 
     # If specified, the model config will be added to this experiment. Experiments are used for A/B testing and optimizing hyperparameters.
     experiment: str
 
+    # Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
+    prompt_template: str
+
+    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
+    chat_template: typing.List[ChatMessage]
+
+    # Which of the providers model endpoints to use. For example Complete or Edit.
+    endpoint: ModelEndpoints
+
 class ProjectModelConfigRequest(RequiredProjectModelConfigRequest, OptionalProjectModelConfigRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/project_model_config_response.py` & `humanloop-0.4.9/humanloop/type/src_external_app_models_v4_model_configs_model_config_response.py`

 * *Files 21% similar despite different names*

```diff
@@ -13,48 +13,32 @@
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 from humanloop.type.chat_message import ChatMessage
 from humanloop.type.model_endpoints import ModelEndpoints
 from humanloop.type.model_providers import ModelProviders
-from humanloop.type.src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response import SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse
 
-class RequiredProjectModelConfigResponse(TypedDict):
-    # What model instance to use for the generation. e.g. text-davinci-002.
+class RequiredSrcExternalAppModelsV4ModelConfigsModelConfigResponse(TypedDict):
+    # The model instance used. E.g. text-davinci-002.
     model: str
 
     # Model config unique identifier generated by Humanloop.
     id: str
 
-    created_at: datetime
-
-    updated_at: datetime
-
-    last_used: datetime
-
-class OptionalProjectModelConfigResponse(TypedDict, total=False):
+class OptionalSrcExternalAppModelsV4ModelConfigsModelConfigResponse(TypedDict, total=False):
     # The company providing the underlying model service.
     provider: ModelProviders
 
-    # Which of the providers model endpoints to use. For example Complete or Edit.
-    endpoint: ModelEndpoints
-
-    # Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    prompt_template: str
-
-    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    chat_template: typing.List[ChatMessage]
+    # The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
+    max_tokens: int
 
     # What sampling temperature to use when making a generation. Higher values means the model will be more creative.
     temperature: typing.Union[int, float]
 
-    # The maximum number of tokens to generate in the completion.
-    max_tokens: int
-
     # An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
     top_p: typing.Union[int, float]
 
     # The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.
     stop: typing.Union[str, typing.List[str]]
 
     # Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.
@@ -65,24 +49,18 @@
 
     # Other parameter values to be passed to the provider call.
     other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
     # A friendly display name for the model config.
     display_name: str
 
-    # String ID of project the model config belongs to. Starts with `pr_`.
-    project_id: str
-
-    # Name of the project the model config belongs to.
-    project_name: str
-
-    # Feedback statistics for the project model config.
-    feedback_stats: typing.List[SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse]
+    # Prompt template that will take your specified inputs to form your final request to the model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
+    prompt_template: str
 
-    # Number of datapoints associated with this project model config.
-    num_datapoints: int
+    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the template should be specified with syntax: {{INPUT_NAME}}.
+    chat_template: typing.List[ChatMessage]
 
-    # The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment.
-    experiment_id: str
+    # The provider model endpoint used.
+    endpoint: ModelEndpoints
 
-class ProjectModelConfigResponse(RequiredProjectModelConfigResponse, OptionalProjectModelConfigResponse):
+class SrcExternalAppModelsV4ModelConfigsModelConfigResponse(RequiredSrcExternalAppModelsV4ModelConfigsModelConfigResponse, OptionalSrcExternalAppModelsV4ModelConfigsModelConfigResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/project_response.py` & `humanloop-0.4.9/humanloop/type/update_project_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,49 +10,24 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.config_type import ConfigType
-from humanloop.type.experiment_response import ExperimentResponse
-from humanloop.type.feedback_types import FeedbackTypes
-from humanloop.type.project_config_response import ProjectConfigResponse
-from humanloop.type.project_user_response import ProjectUserResponse
+from humanloop.type.positive_label import PositiveLabel
 
-class RequiredProjectResponse(TypedDict):
-    # Project ID
-    id: str
-
-    # Project ID for internal Humanloop use.
-    internal_id: int
-
-    # Unique project name.
-    name: str
-
-    # Users associated to the project.
-    users: typing.List[ProjectUserResponse]
-
-    # The count of datapoints that have been logged to the project.
-    data_count: int
-
-    feedback_types: FeedbackTypes
-
-    # Unique ID of the team the project belongs to. Starts with `tm_`.
-    team_id: str
-
-    created_at: datetime
-
-    updated_at: datetime
+class RequiredUpdateProjectRequest(TypedDict):
+    pass
 
-class OptionalProjectResponse(TypedDict, total=False):
-    # Experiment that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set.
-    active_experiment: ExperimentResponse
+class OptionalUpdateProjectRequest(TypedDict, total=False):
+    # ID for an experiment to set as the project's active deployment. Starts with 'exp_'. At most one of 'active_experiment_id' and 'active_model_config_id' can be set.
+    active_experiment_id: str
 
-    # Config that has been set as the project's active deployment. At most one of active_experiment and active_model_config can be set.
-    active_config: ProjectConfigResponse
+    # ID for a config to set as the project's active deployment. Starts with 'config_'. At most one of 'active_experiment_id' and 'active_config_id' can be set.
+    active_config_id: str
 
-    config_type: ConfigType
+    # The full list of labels to treat as positive user feedback.
+    positive_labels: typing.List[PositiveLabel]
 
-class ProjectResponse(RequiredProjectResponse, OptionalProjectResponse):
+class UpdateProjectRequest(RequiredUpdateProjectRequest, OptionalUpdateProjectRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/project_sort_by.py` & `humanloop-0.4.9/humanloop/type/project_sort_by.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/project_user_response.py` & `humanloop-0.4.9/humanloop/type/project_user_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/projects_get_configs_response.py` & `humanloop-0.4.9/humanloop/type/projects_get_configs_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/projects_update_feedback_types_request.py` & `humanloop-0.4.9/humanloop/type/projects_update_feedback_types_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/provider_api_keys.py` & `humanloop-0.4.9/humanloop/type/provider_api_keys.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/session_project_response.py` & `humanloop-0.4.9/humanloop/type/session_project_response.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/session_response.py` & `humanloop-0.4.9/humanloop/type/tool_config_request.py`

 * *Files 20% similar despite different names*

```diff
@@ -10,30 +10,23 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.session_project_response import SessionProjectResponse
 
-class RequiredSessionResponse(TypedDict):
-    # String ID of session. Starts with `sesh_`.
-    id: str
+class RequiredToolConfigRequest(TypedDict):
+    type: str
 
-    # List of projects that have datapoints associated to this session.
-    projects: typing.List[SessionProjectResponse]
+class OptionalToolConfigRequest(TypedDict, total=False):
+    description: str
 
-    # Number of datapoints associated to this session.
-    datapoints_count: int
+    name: str
 
-    created_at: datetime
+    source: str
 
-class OptionalSessionResponse(TypedDict, total=False):
-    # Inputs for the first datapoint in the session.
-    first_inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # Other parameters that define the config.
+    other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # Output for the last datapoint in the session.
-    last_output: str
-
-class SessionResponse(RequiredSessionResponse, OptionalSessionResponse):
+class ToolConfigRequest(RequiredToolConfigRequest, OptionalToolConfigRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/sort_order.py` & `humanloop-0.4.9/humanloop/type/sort_order.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/src_external_app_models_v3_model_configs_model_config_response.py` & `humanloop-0.4.9/humanloop/type/src_external_app_models_v4_configs_model_config_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,53 +14,58 @@
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 from humanloop.type.chat_message import ChatMessage
 from humanloop.type.model_endpoints import ModelEndpoints
 from humanloop.type.model_providers import ModelProviders
 
-class RequiredSrcExternalAppModelsV3ModelConfigsModelConfigResponse(TypedDict):
-    # What model instance to use for the generation. e.g. text-davinci-002.
+class RequiredSrcExternalAppModelsV4ConfigsModelConfigResponse(TypedDict):
+    # String ID of config. Starts with `config_`.
+    id: str
+
+    type: str
+
+    # Name of config.
+    name: str
+
+    # The model instance used. E.g. text-davinci-002.
     model: str
 
-    # Model config unique identifier generated by Humanloop.
-    id: str
+class OptionalSrcExternalAppModelsV4ConfigsModelConfigResponse(TypedDict, total=False):
+    # Description of config.
+    description: str
+
+    # Other parameter values to be passed to the provider call.
+    other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-class OptionalSrcExternalAppModelsV3ModelConfigsModelConfigResponse(TypedDict, total=False):
     # The company providing the underlying model service.
     provider: ModelProviders
 
-    # Which of the providers model endpoints to use. For example Complete or Edit.
-    endpoint: ModelEndpoints
-
-    # Prompt template that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    prompt_template: str
-
-    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
-    chat_template: typing.List[ChatMessage]
+    # The maximum number of tokens to generate. Provide max_tokens=-1 to dynamically calculate the maximum number of tokens to generate given the length of the prompt
+    max_tokens: int
 
     # What sampling temperature to use when making a generation. Higher values means the model will be more creative.
     temperature: typing.Union[int, float]
 
-    # The maximum number of tokens to generate in the completion.
-    max_tokens: int
-
     # An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
     top_p: typing.Union[int, float]
 
     # The string (or list of strings) after which the model will stop generating. The returned text will not contain the stop sequence.
     stop: typing.Union[str, typing.List[str]]
 
     # Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the generation so far.
     presence_penalty: typing.Union[int, float]
 
     # Number between -2.0 and 2.0. Positive values penalize new tokens based on how frequently they appear in the generation so far.
     frequency_penalty: typing.Union[int, float]
 
-    # Other parameter values to be passed to the provider call.
-    other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # Prompt template that will take your specified inputs to form your final request to the model. NB: Input variables within the prompt template should be specified with syntax: {{INPUT_NAME}}.
+    prompt_template: str
 
-    # A friendly display name for the model config.
-    display_name: str
+    # Messages prepended to the list of messages sent to the provider. These messages that will take your specified inputs to form your final request to the provider model. NB: Input variables within the template should be specified with syntax: {{INPUT_NAME}}.
+    chat_template: typing.List[ChatMessage]
+
+    # The provider model endpoint used.
+    endpoint: ModelEndpoints
 
-class SrcExternalAppModelsV3ModelConfigsModelConfigResponse(RequiredSrcExternalAppModelsV3ModelConfigsModelConfigResponse, OptionalSrcExternalAppModelsV3ModelConfigsModelConfigResponse):
+class SrcExternalAppModelsV4ConfigsModelConfigResponse(RequiredSrcExternalAppModelsV4ConfigsModelConfigResponse, OptionalSrcExternalAppModelsV4ConfigsModelConfigResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/src_external_app_models_v3_model_configs_project_model_config_feedback_stats_response.py` & `humanloop-0.4.9/humanloop/type/project_model_config_feedback_stats_response.py`

 * *Files 22% similar despite different names*

```diff
@@ -11,21 +11,21 @@
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 
-class RequiredSrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse(TypedDict):
+class RequiredProjectModelConfigFeedbackStatsResponse(TypedDict):
     feedback_type_id: int
 
     feedback_type: str
 
     feedback_value: str
 
     feedback_count: int
 
-class OptionalSrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse(TypedDict, total=False):
+class OptionalProjectModelConfigFeedbackStatsResponse(TypedDict, total=False):
     pass
 
-class SrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse(RequiredSrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse, OptionalSrcExternalAppModelsV3ModelConfigsProjectModelConfigFeedbackStatsResponse):
+class ProjectModelConfigFeedbackStatsResponse(RequiredProjectModelConfigFeedbackStatsResponse, OptionalProjectModelConfigFeedbackStatsResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/src_external_app_models_v4_project_configs_project_model_config_feedback_stats_response.py` & `humanloop-0.4.9/humanloop/type/tool_result_response.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,21 +11,21 @@
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 
-class RequiredSrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse(TypedDict):
-    feedback_type_id: int
+class RequiredToolResultResponse(TypedDict):
+    id: str
 
-    feedback_type: str
+    name: str
 
-    feedback_value: str
+    signature: str
 
-    feedback_count: int
+    result: str
 
-class OptionalSrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse(TypedDict, total=False):
+class OptionalToolResultResponse(TypedDict, total=False):
     pass
 
-class SrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse(RequiredSrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse, OptionalSrcExternalAppModelsV4ProjectConfigsProjectModelConfigFeedbackStatsResponse):
+class ToolResultResponse(RequiredToolResultResponse, OptionalToolResultResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/tool_config_request.py` & `humanloop-0.4.9/humanloop/type/tool_config_response.py`

 * *Files 12% similar despite different names*

```diff
@@ -11,22 +11,28 @@
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
 
-class RequiredToolConfigRequest(TypedDict):
-    type: str
+class RequiredToolConfigResponse(TypedDict):
+    # String ID of config. Starts with `config_`.
+    id: str
 
-class OptionalToolConfigRequest(TypedDict, total=False):
-    description: str
+    type: str
 
+    # Name of config.
     name: str
 
-    source: str
+class OptionalToolConfigResponse(TypedDict, total=False):
+    # Description of config.
+    description: str
 
     # Other parameters that define the config.
     other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-class ToolConfigRequest(RequiredToolConfigRequest, OptionalToolConfigRequest):
+    # Code source of the tool.
+    source: str
+
+class ToolConfigResponse(RequiredToolConfigResponse, OptionalToolConfigResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/tool_config_response.py` & `humanloop-0.4.9/humanloop/type/project_config_response.py`

 * *Files 26% similar despite different names*

```diff
@@ -10,29 +10,37 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
+from humanloop.type.config_response import ConfigResponse
+from humanloop.type.project_model_config_feedback_stats_response import ProjectModelConfigFeedbackStatsResponse
 
-class RequiredToolConfigResponse(TypedDict):
-    # String ID of config. Starts with `config_`.
-    id: str
+class RequiredProjectConfigResponse(TypedDict):
+    # String ID of project the model config belongs to. Starts with `pr_`.
+    project_id: str
 
-    type: str
+    # Name of the project the model config belongs to.
+    project_name: str
 
-    # Name of config.
-    name: str
+    created_at: datetime
 
-class OptionalToolConfigResponse(TypedDict, total=False):
-    # Description of config.
-    description: str
+    updated_at: datetime
 
-    # Other parameters that define the config.
-    other: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    last_used: datetime
 
-    # Code source of the tool.
-    source: str
+    config: ConfigResponse
 
-class ToolConfigResponse(RequiredToolConfigResponse, OptionalToolConfigResponse):
+class OptionalProjectConfigResponse(TypedDict, total=False):
+    # Feedback statistics for the project model config.
+    feedback_stats: typing.List[ProjectModelConfigFeedbackStatsResponse]
+
+    # Number of datapoints associated with this project model config.
+    num_datapoints: int
+
+    # The ID of the experiment the model config has been registered to. Only populated when registering a model config to an experiment.
+    experiment_id: str
+
+class ProjectConfigResponse(RequiredProjectConfigResponse, OptionalProjectConfigResponse):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/trace_log_request.py` & `humanloop-0.4.9/humanloop/type/completion_model_config_request.py`

 * *Files 23% similar despite different names*

```diff
@@ -10,53 +10,61 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.agent_config_request import AgentConfigRequest
-from humanloop.type.chat_message import ChatMessage
-from humanloop.type.generic_config_request import GenericConfigRequest
-from humanloop.type.tool_config_request import ToolConfigRequest
-from humanloop.type.trace_model_config_request import TraceModelConfigRequest
+from humanloop.type.provider_api_keys import ProviderApiKeys
 
-class RequiredTraceLogRequest(TypedDict):
+class RequiredCompletionModelConfigRequest(TypedDict):
+    # Identifies the model configuration used to create a chat response.
+    model_config_id: str
+
+class OptionalCompletionModelConfigRequest(TypedDict, total=False):
     # Unique function name. If no function exists with this name, a new function will be created.
-    function_name: str
+    project: str
 
-class OptionalTraceLogRequest(TypedDict, total=False):
-    # Unique ID of an experiment trial to associate to the log.
-    trial_id: str
+    # Unique ID of a function to associate to the log. Either this or `function_name` must be provided.
+    project_id: str
 
-    # The inputs passed to the prompt template.
-    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
+    # ID of the session to associate the datapoint.
+    session_id: str
+
+    # A unique string identifying the session to associate the datapoint to. Allows you to log multiple datapoints to a session (using an ID kept by your internal systems) by passing the same `session_reference_id` in subsequent log requests. Specify at most one of this or `session_id`.
+    session_reference_id: str
+
+    # ID associated to the parent datapoint in a session.
+    parent_id: str
 
-    # The messages passed to the to provider chat endpoint.
-    messages: typing.List[ChatMessage]
+    # A unique string identifying the previously-logged parent datapoint in a session. Allows you to log nested datapoints with your internal system IDs by passing the same reference ID as `parent_id` in a prior log request. Specify at most one of this or `parent_id`. Note that this cannot refer to a datapoint being logged in the same request.
+    parent_reference_id: str
 
-    # Generated output from your model for the provided inputs. Can be `None` if logging an error.
-    output: str
+    # The inputs passed to the prompt template.
+    inputs: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
     # Identifies where the model was called from.
     source: str
 
-    # The config used for this generation. Required unless `trial_id` is provided.
-    config: typing.Union[TraceModelConfigRequest, ToolConfigRequest, GenericConfigRequest, AgentConfigRequest]
-
     # Any additional metadata to record.
     metadata: typing.Dict[str, typing.Union[bool, date, datetime, dict, float, int, list, str, None]]
 
-    # Error message if the log is an error.
-    error: str
+    # API keys required by each provider to make API calls. The API keys provided here are not stored by Humanloop. If not specified here, Humanloop will fall back to the key saved to your organization.
+    provider_api_keys: ProviderApiKeys
+
+    # The number of generations.
+    num_samples: int
+
+    # Include the log probabilities of the top n tokens in the provider_response
+    logprobs: int
 
-    # Duration of the logged event in seconds.
-    duration: typing.Union[int, float]
+    # If true, tokens will be sent as data-only server-sent events. If num_samples > 1, samples are streamed back independently.
+    stream: bool
 
-    # User-defined timestamp for when the log was created.
-    created_at: datetime
+    # The suffix that comes after a completion of inserted text. Useful for completions that act like inserts.
+    suffix: str
 
-    # List of children logs.
-    children: typing.List["TraceLogRequest"]
+    # End-user ID passed through to provider call.
+    user: str
 
-class TraceLogRequest(RequiredTraceLogRequest, OptionalTraceLogRequest):
+class CompletionModelConfigRequest(RequiredCompletionModelConfigRequest, OptionalCompletionModelConfigRequest):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/update_log_request.py` & `humanloop-0.4.9/humanloop/type/update_log_request.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type/update_project_request.py` & `humanloop-0.4.9/humanloop/type/validation_error.py`

 * *Files 27% similar despite different names*

```diff
@@ -10,24 +10,20 @@
 """
 
 from datetime import datetime, date
 import typing
 from enum import Enum
 from typing_extensions import TypedDict, Literal
 
-from humanloop.type.positive_label import PositiveLabel
 
-class RequiredUpdateProjectRequest(TypedDict):
-    pass
+class RequiredValidationError(TypedDict):
+    loc: typing.List[typing.Union[typing.List[str], typing.List[int]]]
 
-class OptionalUpdateProjectRequest(TypedDict, total=False):
-    # ID for an experiment to set as the project's active deployment. Starts with 'exp_'. At most one of 'active_experiment_id' and 'active_model_config_id' can be set.
-    active_experiment_id: str
+    msg: str
 
-    # ID for a config to set as the project's active deployment. Starts with 'config_'. At most one of 'active_experiment_id' and 'active_config_id' can be set.
-    active_config_id: str
+    type: str
 
-    # The full list of labels to treat as positive user feedback.
-    positive_labels: typing.List[PositiveLabel]
+class OptionalValidationError(TypedDict, total=False):
+    pass
 
-class UpdateProjectRequest(RequiredUpdateProjectRequest, OptionalUpdateProjectRequest):
+class ValidationError(RequiredValidationError, OptionalValidationError):
     pass
```

### Comparing `humanloop-0.4.8/humanloop/type/usage.py` & `humanloop-0.4.9/humanloop/type/usage.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/type_util.py` & `humanloop-0.4.9/humanloop/type_util.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/humanloop/validation_metadata.py` & `humanloop-0.4.9/humanloop/validation_metadata.py`

 * *Files identical despite different names*

### Comparing `humanloop-0.4.8/pyproject.toml` & `humanloop-0.4.9/pyproject.toml`

 * *Files 15% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 [tool.poetry]
 name = "humanloop"
-version = "0.4.8"
+version = "0.4.9"
 description = "Client for Humanloop API"
 authors = ["Konfig <engineering@konfigthis.com>"]
 license = "MIT"
 readme = "README.md"
 packages = [{include = "humanloop"}]
 
 [tool.poetry.dependencies]
```

### Comparing `humanloop-0.4.8/PKG-INFO` & `humanloop-0.4.9/PKG-INFO`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: humanloop
-Version: 0.4.8
+Version: 0.4.9
 Summary: Client for Humanloop API
 License: MIT
 Author: Konfig
 Author-email: engineering@konfigthis.com
 Requires-Python: >=3.7,<4.0
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Programming Language :: Python :: 3
@@ -18,25 +18,25 @@
 Requires-Dist: frozendict (>=2.3.4,<3.0.0)
 Requires-Dist: python-dateutil (>=2.8.2,<3.0.0)
 Requires-Dist: typing_extensions (>=4.3.0,<5.0.0)
 Requires-Dist: urllib3 (>=1.26.7,<2.0.0)
 Requires-Dist: validators (>=0.20.0,<0.21.0)
 Description-Content-Type: text/markdown
 
-# humanloop@0.4.8
+# humanloop@0.4.9
 
 
 ## Requirements
 
 Python >=3.7
 
 ## Installing
 
 ```sh
-pip install humanloop==0.4.8
+pip install humanloop==0.4.9
 ```
 
 ## Getting Started
 
 ```python
 from pprint import pprint
 from humanloop import Humanloop, ApiException
```

