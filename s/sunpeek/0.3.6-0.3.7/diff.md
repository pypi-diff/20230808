# Comparing `tmp/sunpeek-0.3.6-py3-none-any.whl.zip` & `tmp/sunpeek-0.3.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,55 +1,55 @@
-Zip file size: 193862 bytes, number of entries: 74
+Zip file size: 195588 bytes, number of entries: 74
 -rw-r--r--  2.0 unx     1035 b- defN 80-Jan-01 00:00 sunpeek/__init__.py
 -rw-r--r--  2.0 unx      264 b- defN 80-Jan-01 00:00 sunpeek/api/__init__.py
 -rw-r--r--  2.0 unx      581 b- defN 80-Jan-01 00:00 sunpeek/api/dependencies.py
--rw-r--r--  2.0 unx     7949 b- defN 80-Jan-01 00:00 sunpeek/api/main.py
+-rw-r--r--  2.0 unx     7986 b- defN 80-Jan-01 00:00 sunpeek/api/main.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 sunpeek/api/routers/__init__.py
 -rw-r--r--  2.0 unx     1718 b- defN 80-Jan-01 00:00 sunpeek/api/routers/api_jobs.py
 -rw-r--r--  2.0 unx     6312 b- defN 80-Jan-01 00:00 sunpeek/api/routers/config.py
--rw-r--r--  2.0 unx     5513 b- defN 80-Jan-01 00:00 sunpeek/api/routers/evaluations.py
+-rw-r--r--  2.0 unx     6090 b- defN 80-Jan-01 00:00 sunpeek/api/routers/evaluations.py
 -rw-r--r--  2.0 unx     6582 b- defN 80-Jan-01 00:00 sunpeek/api/routers/files.py
 -rw-r--r--  2.0 unx      245 b- defN 80-Jan-01 00:00 sunpeek/api/routers/helper.py
 -rw-r--r--  2.0 unx    19263 b- defN 80-Jan-01 00:00 sunpeek/api/routers/plant.py
 -rw-r--r--  2.0 unx      780 b- defN 80-Jan-01 00:00 sunpeek/base_model.py
 -rw-r--r--  2.0 unx      100 b- defN 80-Jan-01 00:00 sunpeek/common/__init__.py
 -rw-r--r--  2.0 unx     1248 b- defN 80-Jan-01 00:00 sunpeek/common/common_units.py
 -rw-r--r--  2.0 unx     1968 b- defN 80-Jan-01 00:00 sunpeek/common/config_parser.py
 -rw-r--r--  2.0 unx     1802 b- defN 80-Jan-01 00:00 sunpeek/common/errors.py
 -rw-r--r--  2.0 unx     6639 b- defN 80-Jan-01 00:00 sunpeek/common/time_zone.py
 -rw-r--r--  2.0 unx    17863 b- defN 80-Jan-01 00:00 sunpeek/common/unit_uncertainty.py
 -rw-r--r--  2.0 unx     5134 b- defN 80-Jan-01 00:00 sunpeek/common/utils.py
 -rw-r--r--  2.0 unx      986 b- defN 80-Jan-01 00:00 sunpeek/components/__init__.py
--rw-r--r--  2.0 unx    13435 b- defN 80-Jan-01 00:00 sunpeek/components/base.py
+-rw-r--r--  2.0 unx    13697 b- defN 80-Jan-01 00:00 sunpeek/components/base.py
 -rw-r--r--  2.0 unx     2800 b- defN 80-Jan-01 00:00 sunpeek/components/components_factories.py
 -rw-r--r--  2.0 unx    26948 b- defN 80-Jan-01 00:00 sunpeek/components/fluids.py
 -rw-r--r--  2.0 unx    14800 b- defN 80-Jan-01 00:00 sunpeek/components/fluids_wpd_models.py
 -rw-r--r--  2.0 unx    14886 b- defN 80-Jan-01 00:00 sunpeek/components/helpers.py
 -rw-r--r--  2.0 unx    15784 b- defN 80-Jan-01 00:00 sunpeek/components/iam_methods.py
 -rw-r--r--  2.0 unx      674 b- defN 80-Jan-01 00:00 sunpeek/components/jobs.py
 -rw-r--r--  2.0 unx     3804 b- defN 80-Jan-01 00:00 sunpeek/components/operational_events.py
--rw-r--r--  2.0 unx    49882 b- defN 80-Jan-01 00:00 sunpeek/components/physical.py
+-rw-r--r--  2.0 unx    49813 b- defN 80-Jan-01 00:00 sunpeek/components/physical.py
 -rw-r--r--  2.0 unx     3075 b- defN 80-Jan-01 00:00 sunpeek/components/results.py
--rw-r--r--  2.0 unx    23359 b- defN 80-Jan-01 00:00 sunpeek/components/sensor.py
+-rw-r--r--  2.0 unx    23308 b- defN 80-Jan-01 00:00 sunpeek/components/sensor.py
 -rw-r--r--  2.0 unx    11412 b- defN 80-Jan-01 00:00 sunpeek/components/sensor_types.py
 -rw-r--r--  2.0 unx    20337 b- defN 80-Jan-01 00:00 sunpeek/components/types.py
 -rw-r--r--  2.0 unx       87 b- defN 80-Jan-01 00:00 sunpeek/core_methods/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 sunpeek/core_methods/common/__init__.py
--rw-r--r--  2.0 unx    13669 b- defN 80-Jan-01 00:00 sunpeek/core_methods/common/main.py
+-rw-r--r--  2.0 unx    13751 b- defN 80-Jan-01 00:00 sunpeek/core_methods/common/main.py
 -rw-r--r--  2.0 unx     4570 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/__init__.py
--rw-r--r--  2.0 unx    15126 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/equation.py
--rw-r--r--  2.0 unx    31604 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/main.py
+-rw-r--r--  2.0 unx    14730 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/equation.py
+-rw-r--r--  2.0 unx    31591 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/main.py
 -rw-r--r--  2.0 unx    22617 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/plotting.py
--rw-r--r--  2.0 unx    10781 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/wrapper.py
+-rw-r--r--  2.0 unx    10738 b- defN 80-Jan-01 00:00 sunpeek/core_methods/pc_method/wrapper.py
 -rw-r--r--  2.0 unx       83 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/__init__.py
--rw-r--r--  2.0 unx    41535 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/algorithms.py
--rw-r--r--  2.0 unx     4224 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/main.py
+-rw-r--r--  2.0 unx    39360 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/calculations.py
+-rw-r--r--  2.0 unx     4202 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/main.py
 -rw-r--r--  2.0 unx    35090 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/radiation.py
--rw-r--r--  2.0 unx     3449 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/virtuals_array.py
--rw-r--r--  2.0 unx     3868 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/virtuals_plant.py
+-rw-r--r--  2.0 unx     3446 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/virtuals_array.py
+-rw-r--r--  2.0 unx     3773 b- defN 80-Jan-01 00:00 sunpeek/core_methods/virtuals/virtuals_plant.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 sunpeek/data_handling/__init__.py
 -rw-r--r--  2.0 unx    23667 b- defN 80-Jan-01 00:00 sunpeek/data_handling/context.py
 -rw-r--r--  2.0 unx    24335 b- defN 80-Jan-01 00:00 sunpeek/data_handling/data_uploader.py
 -rw-r--r--  2.0 unx     1849 b- defN 80-Jan-01 00:00 sunpeek/data_handling/wrapper.py
 -rw-r--r--  2.0 unx       25 b- defN 80-Jan-01 00:00 sunpeek/db_utils/__init__.py
 -rw-r--r--  2.0 unx     5593 b- defN 80-Jan-01 00:00 sunpeek/db_utils/crud.py
 -rw-r--r--  2.0 unx    16575 b- defN 80-Jan-01 00:00 sunpeek/db_utils/db_data_operations.py
@@ -63,14 +63,14 @@
 -rw-r--r--  2.0 unx     3450 b- defN 80-Jan-01 00:00 sunpeek/definitions/fluid_data/Wocklum Thermum P/density.csv
 -rw-r--r--  2.0 unx     2532 b- defN 80-Jan-01 00:00 sunpeek/definitions/fluid_data/Wocklum Thermum P/heat capacity.csv
 -rw-r--r--  2.0 unx    33003 b- defN 80-Jan-01 00:00 sunpeek/definitions/fluid_definitions.py
 -rw-r--r--  2.0 unx      528 b- defN 80-Jan-01 00:00 sunpeek/demo/__init__.py
 -rw-r--r--  2.0 unx     1902 b- defN 80-Jan-01 00:00 sunpeek/demo/demo_plant.py
 -rw-r--r--  2.0 unx     5168 b- defN 80-Jan-01 00:00 sunpeek/demo/demo_plant_script.py
 -rw-r--r--  2.0 unx     6191 b- defN 80-Jan-01 00:00 sunpeek/exporter.py
--rw-r--r--  2.0 unx    22210 b- defN 80-Jan-01 00:00 sunpeek/serializable_models.py
--rw-r--r--  2.0 unx     7652 b- defN 80-Jan-01 00:00 sunpeek-0.3.6.dist-info/COPYING.LESSER
--rw-r--r--  2.0 unx    15186 b- defN 80-Jan-01 00:00 sunpeek-0.3.6.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 sunpeek-0.3.6.dist-info/WHEEL
--rw-r--r--  2.0 unx    35149 b- defN 80-Jan-01 00:00 sunpeek-0.3.6.dist-info/COPYING
-?rw-r--r--  2.0 unx     6727 b- defN 16-Jan-01 00:00 sunpeek-0.3.6.dist-info/RECORD
-74 files, 713456 bytes uncompressed, 183088 bytes compressed:  74.3%
+-rw-r--r--  2.0 unx    31339 b- defN 80-Jan-01 00:00 sunpeek/serializable_models.py
+-rw-r--r--  2.0 unx     7652 b- defN 80-Jan-01 00:00 sunpeek-0.3.7.dist-info/COPYING.LESSER
+-rw-r--r--  2.0 unx    15186 b- defN 80-Jan-01 00:00 sunpeek-0.3.7.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 sunpeek-0.3.7.dist-info/WHEEL
+-rw-r--r--  2.0 unx    35149 b- defN 80-Jan-01 00:00 sunpeek-0.3.7.dist-info/COPYING
+?rw-r--r--  2.0 unx     6729 b- defN 16-Jan-01 00:00 sunpeek-0.3.7.dist-info/RECORD
+74 files, 720678 bytes uncompressed, 184810 bytes compressed:  74.4%
```

## zipnote {}

```diff
@@ -120,15 +120,15 @@
 
 Filename: sunpeek/core_methods/pc_method/wrapper.py
 Comment: 
 
 Filename: sunpeek/core_methods/virtuals/__init__.py
 Comment: 
 
-Filename: sunpeek/core_methods/virtuals/algorithms.py
+Filename: sunpeek/core_methods/virtuals/calculations.py
 Comment: 
 
 Filename: sunpeek/core_methods/virtuals/main.py
 Comment: 
 
 Filename: sunpeek/core_methods/virtuals/radiation.py
 Comment: 
@@ -201,23 +201,23 @@
 
 Filename: sunpeek/exporter.py
 Comment: 
 
 Filename: sunpeek/serializable_models.py
 Comment: 
 
-Filename: sunpeek-0.3.6.dist-info/COPYING.LESSER
+Filename: sunpeek-0.3.7.dist-info/COPYING.LESSER
 Comment: 
 
-Filename: sunpeek-0.3.6.dist-info/METADATA
+Filename: sunpeek-0.3.7.dist-info/METADATA
 Comment: 
 
-Filename: sunpeek-0.3.6.dist-info/WHEEL
+Filename: sunpeek-0.3.7.dist-info/WHEEL
 Comment: 
 
-Filename: sunpeek-0.3.6.dist-info/COPYING
+Filename: sunpeek-0.3.7.dist-info/COPYING
 Comment: 
 
-Filename: sunpeek-0.3.6.dist-info/RECORD
+Filename: sunpeek-0.3.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sunpeek/api/main.py

```diff
@@ -87,33 +87,30 @@
             status_code=409,
             content={"error": "IntegrityError",
                      "message": "Cannot remove a component which is still referenced by other components",
                      "detail": str(exc.orig)}
         )
 
     else:
-        return JSONResponse(content = {"error": "IntegrityError",
-                                       "message": "A database integrity error occurred",
-                                       "detail": ''},
-                                       status_code=500)
-
+        return JSONResponse(content={"error": "IntegrityError",
+                                     "message": "A database integrity error occurred",
+                                     "detail": ''},
+                            status_code=500)
 
 
 @app.exception_handler(pint.errors.UndefinedUnitError)
 def invalid_unit(_, exc):
     return JSONResponse(
         status_code=422,
         content={"error": "UndefinedUnitError",
                  "message": "One of the unit strings in your request was invalid",
                  "detail": str(exc)}
     )
 
 
-
-
 origins = json.loads(os.environ.get('HIT_API_ALLOWED_ORIGINS',
                                     '["http://localhost", "http://127.0.0.1", "http://localhost:8080", \
                                     "http://127.0.0.1:8080", "http://localhost:8000"]')
                      )
 
 app.add_middleware(
     CORSMiddleware,
@@ -124,18 +121,18 @@
 )
 
 
 @app.exception_handler(500)
 def internal_server_error(request, exc):
     tb = traceback.format_tb(exc.__traceback__)
     sp_logger.error(exc, exc_info=exc)
-    response = JSONResponse(content = {"error": "Internal Server Error",
-                 "message": "Critical Error occurred in the backend!",
-                 "detail":  f"A critical error occured: '{exc}'.",
-                 "traceback": tb}, status_code=500)
+    response = JSONResponse(content={"error": "Internal Server Error",
+                                     "message": "Critical Error occurred in the backend!",
+                                     "detail": f"A critical error occured: '{exc}'.",
+                                     "traceback": tb}, status_code=500)
 
     # Since the CORSMiddleware is not executed when an unhandled server exception
     # occurs, we need to manually set the CORS headers ourselves if we want the FE
     # to receive a proper JSON 500, opposed to a CORS error.
     # Setting CORS headers on server errors is a bit of a philosophical topic of
     # discussion in many frameworks, and it is currently not handled in FastAPI.
     # See dotnet core for a recent discussion, where ultimately it was
```

## sunpeek/api/routers/evaluations.py

```diff
@@ -1,10 +1,11 @@
 import datetime
 from typing import Union, List
 from fastapi import APIRouter, Depends, HTTPException
+from starlette.responses import JSONResponse
 
 from sunpeek.api.dependencies import session, crud
 from sunpeek.api.routers.plant import plant_router
 from sunpeek.api.routers.config import config_router
 from sunpeek.core_methods.pc_method import AvailablePCEquations, AvailablePCMethods
 from sunpeek.core_methods.pc_method.wrapper import run_performance_check, list_pc_problems
 import sunpeek.serializable_models as smodels
@@ -41,25 +42,36 @@
                   safety_pipes: Union[float, None] = None,
                   safety_uncertainty: Union[float, None] = None,
                   safety_others: Union[float, None] = None,
                   sess=Depends(session), crd=Depends(crud)):
     """Runs the PC Method for the specified dates range"""
     plant = crd.get_plants(sess, plant_id=plant_id)
     plant.context.set_eval_interval(eval_start=eval_start, eval_end=eval_end)
-    pc_output = run_performance_check(
+
+    pc_algo_result = run_performance_check(
         plant=plant,
         method=[method],
         equation=[equation],
         use_wind=None if ignore_wind is None else [not ignore_wind],
         safety_pipes=safety_pipes,
         safety_uncertainty=safety_uncertainty,
         safety_others=safety_others,
-    ).output
-
-    return pc_output
+    )
+    pc_output = pc_algo_result.output
+    if pc_output is not None:
+        return pc_output
+
+    # pc_output None -> None of the PC strategies was successful -> Return problem report
+    return JSONResponse(
+        status_code=400,
+        content={'error': 'Could not calculate Performance Check.',
+                 'message': f'None of the chosen Performance Check strategies '
+                            f'({len(pc_algo_result.problems.sub_reports)}) was successful.',
+                 'detail': pc_algo_result.problems.parse_with_virtuals()}
+    )
 
 
 @evaluations_router.get("/pc_method_problems", summary="Report which PC method variants can be run",
                         response_model=List[smodels.PCMethodProblem])
 def list_pc_problems_api(plant_id: int,
                          method: Union[AvailablePCMethods, None] = None,
                          equation: Union[AvailablePCEquations, None] = None,
```

## sunpeek/components/base.py

```diff
@@ -219,18 +219,23 @@
             return True
         if isinstance(sensor, Q):
             raise TypeError(f'In {self.name}, {self.__class__.__name__}.{slot_name} exists, '
                             f'but is a ComponentParam, not a sensor. Check the calling code.')
         if sensor.is_virtual:
             if check_mode == AlgoCheckMode.config_only:
                 is_slot_ok = sensor.can_calculate
-                return not is_slot_ok
+                # return not is_slot_ok
             elif check_mode == AlgoCheckMode.config_and_data:
-                is_slot_ok = sensor.data.notna().sum() > 0
-                return not is_slot_ok
+                is_slot_ok = sensor.data.notna().any()
+                # return not is_slot_ok
+                # return not sensor.data.notna().any()
+            else:
+                raise ValueError(f'Unexpected check_mode "{check_mode}". '
+                                 f'Expected: {", ".join(list(AlgoCheckMode))}')
+            return not is_slot_ok
         return False
 
     def is_real_slot_missing(self, slot_name: str, check_mode) -> bool:
         """Like is_slot_missing, but additionally checks if sensor in named slot is real (not virtual).
         """
         sensor = getattr(self, slot_name)
         if sensor is None:
```

## sunpeek/components/physical.py

```diff
@@ -287,16 +287,14 @@
                  **kwargs):
 
         # to change plant context, explicitly attach a different Context object to plant in the calling code
         from sunpeek.data_handling.context import Context
         self.context = Context(plant=self)
 
         self.defer_post_config_changed_actions = True
-        # TODO Remove
-        # self.defer_configure_virtuals = True
 
         if name is not None:
             self.name = name
         else:
             self.name = str(uuid.uuid4().hex[0:12])
         self.owner = owner
         self.operator = operator
```

## sunpeek/components/sensor.py

```diff
@@ -178,15 +178,14 @@
                     "'sensor_native_unit' must be a valid python pint library unit string")
             # Make sure native_unit is compatible with SensorType unit
             if sensor_type_unit is not None:
                 uu.assert_compatible(sensor_type_unit, native_unit)
         # normalise unit name, store as string for DB compatibility
         self._native_unit = str(native_unit)
 
-
     @property
     def problems(self):
         # self.problems is not persisted in the database, so if self._problems is None, on a virtual sensor,
         # config_virtuals() is called on the plant which sets self.problems for all virtual sensors.
         if self._problems is None and self.is_virtual:
             if self.plant is not None:
                 [func(self.plant) for func in self.plant.post_config_changed_callbacks]
@@ -490,15 +489,14 @@
             # self.plant = None     # Causes stack overflow by calling SQLAlchemy remove() code
             self.plant.raw_sensors.pop(self.plant.raw_sensors.index(self))
 
         self.mappings.clear()  # There might be mappings from sensor to a component that has no parent plant.
 
         if plant is not None:
             if not plant.defer_post_config_changed_actions:
-                # virtuals.config_virtuals(plant)
                 [func(plant) for func in plant.post_config_changed_callbacks]
 
     def is_info_missing(self, info_item: str) -> bool:
         """Make sure sensor info has an item with the specified key.
         """
         return (self.info is None) or (info_item not in self.info._info)
```

## sunpeek/core_methods/common/main.py

```diff
@@ -152,15 +152,16 @@
     or various Performance Check methods, equations etc.
 
     *args and **kwargs passed to object creation are forwarded to :meth:`define_strategies`.
     """
 
     def __init__(self, component: Component, strategies: Optional[List[VirtualSensorStrategy]] = None, *args, **kwargs):
         self.component = component
-        self.strategies = strategies if strategies is not None else self.define_strategies(*args, **kwargs)
+        # self.strategies = strategies if strategies is not None else self.define_strategies(*args, **kwargs)
+        self.strategies = strategies or self.define_strategies(*args, **kwargs)
         self.problems = ProblemReport()
 
     @abstractmethod
     def define_strategies(self, *args, **kwargs) -> List[VirtualSensorStrategy]:
         raise NotImplementedError()
 
     def run(self, on_strategy_error: StrategyErrorBehavior = 'skip') -> AlgoResult:
```

## sunpeek/core_methods/pc_method/equation.py

```diff
@@ -4,22 +4,21 @@
 
 from sunpeek.common.unit_uncertainty import Q
 from sunpeek.components.base import AlgoCheckMode
 from sunpeek.core_methods.common.main import is_valid_collector
 from sunpeek.components.physical import Plant, Array
 from sunpeek.core_methods.pc_method import AvailablePCEquations
 from sunpeek.common.errors import PCMethodError
-from sunpeek.serializable_models import ProblemReport, ProblemType, AlgoProblem
+from sunpeek.serializable_models import ProblemReport
 
 # Common to all equations
 MAX_DELTA_T_COLLECTOR = Q(5.0, 'K hour**-1')
 MIN_TE_AMB = Q(5.0, 'degC')
 MAX_WIND_SPEED = Q(10, 'm s**-1')
 
-
 # TODO Use this for all equations?
 MAX_AOI = Q(80, 'deg')
 
 MAX_AOI_EQ2 = Q(75, 'deg')
 
 # Equation 1
 MIN_RD_GTI = Q(800, 'W m**-2')
@@ -90,39 +89,35 @@
         use_wind : bool
             if False, the wind speed sensor is ignored as a restriction to finding valid intervals
             in the data filtering process for meeting the ISO 24194 requirements.
         """
         self.use_wind = use_wind
         return
 
-    def report_problems(self, array: Array, check_mode: AlgoCheckMode) -> ProblemReport:
-        r = ProblemReport()
-
+    def report_problems(self, r: ProblemReport, array: Array, check_mode: AlgoCheckMode) -> ProblemReport:
         for attrib in ['area_gr']:
             if array.is_attrib_missing(attrib):
-                r.add_own(AlgoProblem(ProblemType.component_attrib, array, attrib))
+                r.add_missing_attrib(array, attrib)
 
         if not is_valid_collector(array.collector_type, check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                  array, 'collector_type',
-                                  'Collector type is None or UninitialisedCollectorType.'))
+            r.add_missing_collector(array, 'collector_type')
         else:
             for attrib in ['a1', 'a2', 'a5', 'eta0b', 'kd']:
                 if getattr(array.collector_type, attrib) is None:
-                    r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                          array.collector_type, attrib,
-                                          f'Collector coefficient "{attrib}" is required but is None / not available.'))
-
-        for slot_name in ['te_op', 'te_op_deriv', 'is_shadowed', 'iam']:
-            if array.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, array, slot_name))
+                    r.add_missing_attrib(array.collector_type, attrib,
+                                         f'Collector coefficient "{attrib}" is required but is None / not available.')
+
+        for slot in ['te_op', 'te_op_deriv', 'is_shadowed', 'iam']:
+            if array.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(array, slot, check_mode)
 
         if self.use_wind:
-            if array.plant.is_slot_missing('ve_wind', check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, array.plant, 've_wind'))
+            slot = 've_wind'
+            if array.plant.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(array.plant, slot, check_mode)
 
         return r
 
     @abstractmethod
     def get_nan_mask(self, plant: Plant):
         """This method checks whether all sensors required to apply an equations are available.
 
@@ -231,31 +226,30 @@
     # Deliberately set maximum incidence angle (not defined in ISO 24194) to avoid numerical problems and problems
     # with calculated Kd values at high incidence angles.
 
     # TODO change for newest ISO 24194 version
     max_aoi_eq1 = MAX_AOI_EQ2
     min_rd_gti = MIN_RD_GTI
 
-    def report_problems(self, array: Array, check_mode: AlgoCheckMode) -> ProblemReport:
-        r = super().report_problems(array, check_mode)
+    def report_problems(self, r: ProblemReport, array: Array, check_mode: AlgoCheckMode) -> ProblemReport:
+        r = super().report_problems(r, array, check_mode)
 
         for attrib in ['eta0hem']:
             if getattr(array.collector_type, attrib) is None:
-                r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                      array.collector_type, attrib,
-                                      f'Collector coefficient "{attrib}" is required for equation 1 but '
-                                      f'is None / not available.'))
-
-        for slot_name in ['rd_gti', 'aoi']:
-            if array.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, array, slot_name))
+                r.add_missing_attrib(array.collector_type, attrib,
+                                     f'Collector coefficient "{attrib}" is required for equation 1 but '
+                                     f'is None / not available.')
+
+        for slot in ['rd_gti', 'aoi']:
+            if array.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(array, slot, check_mode)
 
         return r
 
-    def get_nan_mask(self, plant:Plant):
+    def get_nan_mask(self, plant: Plant):
         # Common sensors
         mask = self._get_nan_mask_common(plant)
 
         # Specific to equation 1
         for array in plant.arrays:
             mask = mask | array.rd_gti.data.isna()
             mask = mask | array.aoi.data.isna()
@@ -304,14 +298,15 @@
                                 - a1 * (te_op - te_amb) \
                                 - a2 * (te_op - te_amb) ** 2 \
                                 - a5 * te_op_deriv
 
         return tp_estimated_specific.astype('pint[W m**-2]')
 
 
+# noinspection PyArgumentList
 class Equation2(Equation):
     """ Implements Equation 2 of the ISO 24194. See Equation base class for more infos.
     """
     id = 2
 
     # Restrictions specific to equation 2
     min_rd_bti = MIN_RD_BTI
@@ -324,20 +319,20 @@
         for array in plant.arrays:
             mask = mask | array.rd_bti.data.isna()
             mask = mask | array.rd_dti.data.isna()
             mask = mask | array.iam.data.isna()
 
         return mask
 
-    def report_problems(self, array: Array, check_mode: AlgoCheckMode) -> ProblemReport:
-        r = super().report_problems(array, check_mode)
+    def report_problems(self, r: ProblemReport, array: Array, check_mode: AlgoCheckMode) -> ProblemReport:
+        r = super().report_problems(r, array, check_mode)
 
-        for slot_name in ['rd_bti', 'rd_dti']:
-            if array.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, array, slot_name))
+        for slot in ['rd_bti', 'rd_dti']:
+            if array.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(array, slot, check_mode)
 
         return r
 
     def calc_pc_restrictions(self, plant, resampler) -> pd.Series:
         is_valid = self._calc_pc_restrictions_common(plant, resampler)
 
         for array in plant.arrays:
```

## sunpeek/core_methods/pc_method/main.py

```diff
@@ -348,24 +348,25 @@
         return pc_method_output
 
     def report_problems(self, check_mode: AlgoCheckMode) -> ProblemReport:
         r = ProblemReport()
 
         if not self.plant.arrays:
             r.add_own(AlgoProblem(ProblemType.component_missing, self.plant, 'arrays',
-                                  'To run the Performance Check method, you need to add arrays to the plant.'))
+                                  'To run the Performance Check method, you need to add arrays to the plant'))
 
-        for slot_name in ['te_amb', 'tp']:
-            if self.plant.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.plant, slot_name))
-
-        for i, array in enumerate(self.plant.arrays):
-            r_array = self.equation.report_problems(array, check_mode)
-            if not r_array.success:
-                r.add_sub(f'Array {i + 1} called "{array.name}"', r_array)
+        for slot in ['te_amb', 'tp']:
+            if self.plant.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.plant, slot, check_mode)
+
+        for array in self.plant.arrays:
+            # r_array = self.equation.report_problems(array, check_mode)
+            # r.add_own(r_array.own_problems)
+            # r.add_virtual()
+            r = self.equation.report_problems(r, array, check_mode)
 
         return r
 
     @abstractmethod
     def _aggregate_candidates(self, s: pd.Series, agg_fun: str):
         """Implements the aggregation of sensor data records, e.g. hourly mean (ISO) or rolling mean (extended),
         into candidate intervals that may be selected as the final PC method intervals.
```

## sunpeek/core_methods/pc_method/wrapper.py

```diff
@@ -40,15 +40,16 @@
         'max_gap_in_interval': max_gap_in_interval,
         'max_nan_density': max_nan_density,
         'min_intervals_in_output': min_intervals_in_output,
         'check_accuracy_level': check_accuracy_level,
     }
 
     pc_algo = PCAlgo(plant, methods=method, equations=equation, use_wind=use_wind, **kwds)
-    return pc_algo.run()
+    algo_result = pc_algo.run()
+    return algo_result
 
 
 def get_pc_problemreport(plant: Plant,
                          method: Optional[List[Union[None, str, AvailablePCMethods]]] = None,
                          equation: Optional[List[Union[None, int, AvailablePCEquations]]] = None,
                          use_wind: Optional[List[Union[None, bool]]] = None,
                          # Settings:
@@ -111,21 +112,21 @@
     return out
 
 
 class PCStrategy(CoreStrategy):
     def __init__(self, pc: PCMethod):
         super().__init__(pc.plant)
         self.pc = pc
-        self.name = f'evaluation mode: {"ISO" if pc.mode==AvailablePCMethods.iso else "ISO extended"}, ' \
-                    f'equation: {pc.equation.id}, ' \
-                    f'{"using wind" if pc.equation.use_wind else "ignoring wind"}'
+        self.name = f'Evaluation mode: {"ISO" if pc.mode == AvailablePCMethods.iso else "ISO extended"}, ' \
+                    f'Equation: {pc.equation.id}, ' \
+                    f'{"Using wind" if pc.equation.use_wind else "Ignoring wind"}'
 
     def _calc(self):
         # return {'pc_method_output': self.pc.run()}     # results.PCMethodOutput
-        return self.pc.run()     # results.PCMethodOutput
+        return self.pc.run()  # results.PCMethodOutput
 
     def _report_problems(self, check_mode: AlgoCheckMode) -> ProblemReport:
         return self.pc.report_problems(check_mode)
 
 
 class PCAlgo(CoreAlgorithm):
 
@@ -133,15 +134,14 @@
         """Returns list of all possible PC method strategies in the order they will be executed.
         """
 
         def process_args(arg, arg_name, allowed_type) -> List[Any]:
             # Make sure arg is a list of allowed_type (bool or Enum). Remove None elements and duplicates.
 
             if isinstance(allowed_type, type) and issubclass(allowed_type, Enum):
-                # allowed_values = set(allowed_type.__members__.values())
                 allowed_values = {x.value for x in allowed_type}
             elif allowed_type is bool:
                 allowed_values = {True, False}
             else:
                 raise TypeError("Invalid allowed_type: Must be either bool or an Enum class.")
 
             arg = arg if isinstance(arg, list) else [arg]
@@ -192,15 +192,15 @@
                                min_data_in_interval: Optional[int] = None,
                                max_gap_in_interval: Optional[dt.timedelta] = None,
                                max_nan_density: Optional[float] = None,
                                min_intervals_in_output: Optional[int] = None,
                                check_accuracy_level: Optional[str] = None,
                                ) -> PCStrategy:
     """Report the first strategy of the Performance Check analysis that is successful with given plant and
-    settings. Like get_pc_problemreport(), this does not actually run calculations.
+    settings. Like `get_pc_problemreport()`, this does not actually run calculations.
     """
     kwds = {
         'safety_pipes': safety_pipes,
         'safety_uncertainty': safety_uncertainty,
         'safety_others': safety_others,
         'interval_length': interval_length,
         'min_data_in_interval': min_data_in_interval,
```

## sunpeek/core_methods/virtuals/main.py

```diff
@@ -56,15 +56,15 @@
     # TODO Uncomment if plant horizontal radiations are needed e.g. for KPIs.
     # vp.config_virtuals_radiation_conversion(plant)
 
     for array in plant.arrays:
         va.config_virtuals_ambient(array)
         va.config_virtuals_power(array)
         va.config_virtuals_temperature(array)
-        va.config_virtuals_radiation_conversion(array)
+        va.config_virtuals_radiation(array)
         # TODO Uncomment if vsensor array.te_out (averaged over row outlet temperatures) is required.
         # va.config_virtuals_te_out(array)
 
     sp_logger.debug(f"  [config_virtuals] --- Done in {(time.time() - start_time):.1f} seconds ---")
 
 
 def calculate_virtuals(plant):
@@ -92,15 +92,15 @@
     # vp.calculate_virtuals_radiation_conversion(plant)
 
     # Arrays
     for array in plant.arrays:
         va.calculate_virtuals_ambient(array)
         va.calculate_virtuals_power(array)
         va.calculate_virtuals_temperature(array)
-        va.calculate_virtuals_radiation_conversion(array)
+        va.calculate_virtuals_radiation(array)
         # TODO Uncomment if vsensor array.te_out (averaged over row outlet temperatures) is required.
         # va.calculate_virtuals_te_out(array)
 
     sp_logger.debug(f"[calculate_virtuals] --- Done in {(time.time() - start_time):.1f} seconds ---")
 
 
 Component.register_callback('post_config_changed_callbacks', config_virtuals)
```

## sunpeek/core_methods/virtuals/virtuals_array.py

```diff
@@ -1,9 +1,9 @@
 from typing import Optional
-from sunpeek.core_methods.virtuals import algorithms as algos
+from sunpeek.core_methods.virtuals import calculations as algos
 from sunpeek.common.errors import CalculationError
 
 
 def config_virtuals_ambient(array):
     """Virtual sensors for sun- and shadow-related stuff in array.
     """
     # Angle of incidence
@@ -58,38 +58,38 @@
 
 def calculate_virtuals_temperature(array):
     result = algos.ArrayTemperatures(array).run()
     array.te_op.update('te_op', result)
     array.te_op_deriv.update('te_op_deriv', result)
 
 
-def config_virtuals_radiation_conversion(array):
+def config_virtuals_radiation(array):
     """Array plane-of-array irradiance (global, beam, diffuse) including masking, shading etc.
     """
     problems = algos.TiltedIrradiances(array).get_config_problems()
     array.map_vsensor('rd_gti', problems)
     array.map_vsensor('rd_bti', problems)
     array.map_vsensor('rd_dti', problems)
 
     # Incidence angle modifier
     array.map_vsensor('iam', algos.AlgoIAM(array).get_config_problems())
 
 
-def calculate_virtuals_radiation_conversion(array, strategy: Optional[str] = None):
+def calculate_virtuals_radiation(array, strategy: Optional[str] = None):
     """Array irradiance components, including beam shading and diffuse masking.
     """
     if strategy is None:
-        result = algos.TiltedIrradiances(array).run()
+        algo = algos.TiltedIrradiances(array)
     elif strategy == 'feedthrough':
         strategy = algos.StrategyTiltedIrradiance_feedthrough(array)
-        result = algos.AlgoIAM(array, strategies=[strategy]).run()
+        algo = algos.TiltedIrradiances(array, strategies=[strategy])
     else:
         raise CalculationError(f'Unknown strategy string: "{strategy}".')
 
+    result = algo.run()
     array.rd_gti.update('rd_gti', result)
     array.rd_bti.update('rd_bti', result)
     array.rd_dti.update('rd_dti', result)
 
     # Incidence angle modifier
     result = algos.AlgoIAM(array).run()
-
     array.iam.update('iam', result)
```

## sunpeek/core_methods/virtuals/virtuals_plant.py

```diff
@@ -1,21 +1,21 @@
-from sunpeek.core_methods.virtuals import algorithms as algos
+from sunpeek.core_methods.virtuals import calculations as algos
 
 
 def config_virtuals_ambient(plant):
     """Solar position, airmass, clearsky radiation, dew point"""
     problems = algos.SolarPosition(plant).get_config_problems()
     plant.map_vsensor('sun_azimuth', problems)
     plant.map_vsensor('sun_zenith', problems)
     plant.map_vsensor('sun_apparent_zenith', problems)
     plant.map_vsensor('sun_elevation', problems)
     plant.map_vsensor('sun_apparent_elevation', problems)
 
-    # TODO The following algorithms are commented because they are not needed for now (because radiation conversion
-    #  is not active at the moment).
+    # The following algorithms are commented because they are not needed for now (because radiation conversion
+    # is not active at the moment).
 
     # Dew point temperature
     # problems = algos.DewPointTemperature(plant).config_problems
     # plant.map_vsensor('te_dew_amb', problems)
 
     # Clearsky solar radiation
     # problems = algos.DNIExtra(plant).config_problems
@@ -42,15 +42,14 @@
     result = algos.SolarPosition(plant).run()
     plant.sun_azimuth.update('azimuth', result)
     plant.sun_zenith.update('zenith', result)
     plant.sun_apparent_zenith.update('apparent_zenith', result)
     plant.sun_elevation.update('elevation', result)
     plant.sun_apparent_elevation.update('apparent_elevation', result)
 
-    # TODO Comment / not needed? see config_virtuals_ambient() above
     # Dew point temperature
     # result = algos.DewPointTemperature(plant).run()
     # plant.te_dew_amb.update('te_dew_amb', result)
 
     # Extraterrestrial solar radiation
     # result = algos.DNIExtra(plant).run()
     # plant.rd_dni_extra.update('dni_extra', result)
@@ -82,26 +81,26 @@
     result = algos.ThermalPower(plant).run()
     plant.tp.update('tp', result)
     # Mass flow
     result = algos.MassFlow(plant).run()
     plant.mf.update('mf', result)
 
 
-def config_virtuals_radiation_conversion(plant):
+def config_virtuals_radiation(plant):
     """Horizontal irradiance components from plant radiation input slots
     """
     pass
 #     # problems = algos.HorizontalIrradiances(plant).config_problems
 #     # plant.map_vsensor('rd_ghi', problems)
 #     # plant.map_vsensor('rd_bhi', problems)
 #     # plant.map_vsensor('rd_dhi', problems)
 #     # plant.map_vsensor('rd_dni', problems)
 
 
-def calculate_virtuals_radiation_conversion(plant):
+def calculate_virtuals_radiation(plant):
     """Horizontal irradiance components from plant radiation input slots
     """
     pass
 #     # ghi, bhi, dhi, dni = algos.HorizontalIrradiances(plant).run()
 #     # plant.rd_ghi.update(ghi)
 #     # plant.rd_bhi.update(bhi)
 #     # plant.rd_dhi.update(dhi)
```

## sunpeek/serializable_models.py

```diff
@@ -1,20 +1,23 @@
 import datetime
 import uuid
 import enum
 from dataclasses import field
+
 from pydantic.dataclasses import dataclass
 import numpy as np
 from pydantic import validator, constr
-from typing import Union, Any, Dict, List
+from typing import Union, Any, Dict, List, Tuple
 import pint.errors
 
 import sunpeek.components as cmp
+import sunpeek.components.physical
+from sunpeek.common.errors import AlgorithmError
 from sunpeek.common.unit_uncertainty import Q
-from sunpeek.components.base import IsVirtual
+from sunpeek.components.base import IsVirtual, AlgoCheckMode
 from sunpeek.components.helpers import SensorMap, DatetimeTemplates, AccuracyClass, InstallCondition
 from sunpeek.components.fluids import UninitialisedFluid
 from sunpeek.base_model import BaseModel
 
 
 class ComponentBase(BaseModel):
     sensor_map: Union[Dict[str, Union[str, None]], None]
@@ -114,17 +117,17 @@
 class IAM_Interpolated(IAM_Method):
     method_type = 'IAM_Interpolated'
     aoi_reference: Quantity
     iam_reference: Quantity
 
 
 class CollectorTypeBase(BaseModel):
-    test_reference_area: str
-    test_type: str
-    gross_length: Quantity
+    test_reference_area: Union[str, None]
+    test_type: Union[str, None]
+    gross_length: Union[Quantity, None]
     iam_method: Union[IAM_K50, IAM_ASHRAE, IAM_Ambrosetti, IAM_Interpolated, None]
     name: str
     manufacturer_name: Union[str, None]
     product_name: Union[str, None]
     test_report_id: Union[str, None]
     licence_number: Union[str, None]
     certificate_date_issued: Union[datetime.datetime, str, None]
@@ -140,15 +143,22 @@
     kd: Union[Quantity, None]
     eta0b: Union[Quantity, None]
     eta0hem: Union[Quantity, None]
     f_prime: Union[Quantity, None]
 
 
 class CollectorType(CollectorTypeBase):
-    id: int
+    id: Union[int, None]
+
+    def __str__(self):
+        return f'{self.__class__.__name__} {self.name}'
+
+    def __repr__(self):
+        return self.__str__()
+
 
 class CollectorTypeQDT(CollectorTypeBase):
     a1: Quantity
     a2: Quantity
     a5: Quantity
 
 
@@ -174,15 +184,14 @@
     def check_unit(cls, v):
         if isinstance(v, str):
             Q(1, v)
 
         return v
 
 
-
 class Sensor(SensorBase):
     id: Union[int, None]
     plant_id: Union[int, None]
     raw_name: Union[str, None]
     sensor_type: Union[str, None]
     native_unit: Union[str, None]
     formatted_unit: Union[str, None]
@@ -250,15 +259,14 @@
     def fluid_name(cls, v):
         try:
             return v.name
         except AttributeError:
             return v
 
 
-# class ArrayBase(BaseModel):
 class Array(ComponentBase):
     id: Union[int, None]
     plant_id: Union[int, None]
     name: Union[str, None]
     collector_type: Union[str, None]
     area_gr: Union[Quantity, None]
     area_ap: Union[Quantity, None]
@@ -277,14 +285,20 @@
 
     @validator('collector_type', pre=True)
     def convert_col_type(cls, v):
         if isinstance(v, cmp.CollectorType):
             return v.name
         return v
 
+    def __str__(self):
+        return f'{self.__class__.__name__} {self.name}'
+
+    def __repr__(self):
+        return self.__str__()
+
 
 class NewArray(Array):
     name: str
     collector_type: str
     sensors: Union[Dict[str, NewSensor], None]
     sensor_map: Union[dict, None]
 
@@ -325,14 +339,20 @@
     id: Union[int, None]
     latitude: Union[Quantity, None]
     longitude: Union[Quantity, None]
     fluid_solar: Union[FluidSummary, str, None]
     local_tz_string_with_DST: Union[str, None]
     data_upload_defaults: Union[DataUploadDefaults, None]
 
+    def __str__(self):
+        return f'{self.__class__.__name__} {self.name}'
+
+    def __repr__(self):
+        return self.__str__()
+
 
 class UpdatePlant(Plant):
     sensors: Union[Dict[str, NewSensor], None]
     fluid_solar: Union[FluidSummary, None]
 
 
 class NewPlant(PlantBase):
@@ -521,41 +541,64 @@
 #         pydantic_field_kwargs[ _field.name] = (_field.type, default)
 #
 #     return pydantic.create_model(name, **pydantic_field_kwargs, __base__=BaseModel)
 
 
 class ProblemType(str, enum.Enum):
     component_slot = 'Component slot'
-    component_attrib = 'Component attribute'
-    sensor_info = 'Sensor info'
+    real_sensor_missing = 'Real sensor'
+    virtual_sensor_missing = 'Virtual sensor'
+    real_or_virtual_sensor_missing = 'Real or virtual sensor'
+    component_attrib = 'Component attribute problem'
+    sensor_info = 'Sensor info problem'
     component_missing = 'Component missing'
     other_problem = 'Unspecified problem'
     unexpected_in_calc = 'Unexpected calculation error'
     unexpected_getting_problems = 'Unexpected error getting problem report'
 
 
 @dataclass
 class AlgoProblem:
-    """A pydantic class used to hold information on a problem / missing info for a calculation / CoreStrategy.
+    """A class used to hold information on a problem / missing info for a calculation / CoreStrategy.
     Can be used to track problems / missing information back to the root cause.
 
     Parameters
     ----------
     problem_type : ProblemType enum
-    affected_component : ComponentBase, optional
+    affected_component : Plant, Array, CollectorType, optional
         The component where some problem occurs / information is missing.
     affected_item_name : str, optional
         Typically the name of the affected sensor slot or attribute of the affected component.
     description : str, optional
     """
     problem_type: ProblemType
-    affected_component: Union[Plant, Array, None] = None
+    affected_component: Union[Any, None] = None
     affected_item_name: Union[str, None] = None
     description: Union[str, None] = None
 
+    def __init__(self, problem_type, affected_component=None, affected_item_name=None, description=None):
+        # Defining an explicit init because affected_component got silently cast into the wrong serializable model.
+        self.problem_type = problem_type
+        self.affected_item_name = affected_item_name
+        self.description = description
+
+        if affected_component is None:
+            self.affected_component = None
+            return
+
+        if isinstance(affected_component, sunpeek.components.physical.Plant):
+            self.affected_component = Plant.from_orm(affected_component)
+        elif isinstance(affected_component, sunpeek.components.physical.Array):
+            self.affected_component = Array.from_orm(affected_component)
+        elif isinstance(affected_component, sunpeek.components.types.CollectorType):
+            self.affected_component = CollectorType.from_orm(affected_component)
+        else:
+            raise ValueError(f'Unexpected component: Expected ORM Plant, Array or CollectorType, '
+                             f'got {type(affected_component)}.')
+
 
 @dataclass
 class ProblemReport:
     """Standardized reporting of problems / missing information required to perform some calculation.
 
     This applies to all calculations in SunPeek, i.e. both virtual sensors and other calculations e.g. PC method.
     Any CoreStrategy and CoreAlgorithm holds / can return a ProblemReport which holds structured information as to
@@ -572,96 +615,239 @@
     own_problems : List[AlgoProblem], optional
         List of reported problems that affect the algo / strategy itself (as opposed to problems coming from called /
         sub algorithms). Example: Strategy needs some component attribute, but that attribute is None.
     sub_reports : Dict[str, ProblemReport], optional
         Problems that are not directly associated to the algo / strategy holding this ProblemReport, but rather stem
         from a previous calculation / strategy. Example: Strategy needs some virtual sensor, but that had its own
         problems, reported as a ProblemReport.
+    virtuals_reports : Dict[Tuple[Any, str], 'ProblemReport']
+        Problems arising from virtual sensors. These are kept separate from sub_reports because the same virtual sensor
+        report might appear in several locations of the problem tree, but should only be parsed once.
     problem_slots : List[str], optional
         Set by virtual sensor strategies, problem_slots can be used to report partial success, i.e.:
         If a strategy is successful for some but not all virtual sensors, the success flag can be set to True,
         and the ProblemReport applies only to the virtual sensor slot names which cannot be calculated,
         i.e. the problem_slots.
     """
     success: Union[bool, None] = True
     own_problems: Union[List[AlgoProblem], None] = None
     sub_reports: Union[Dict[str, 'ProblemReport'], None] = None
+    virtuals_reports: Union[Dict[Tuple[Any, str], 'ProblemReport'], None] = None
     problem_slots: Union[List[str], None] = field(default_factory=list)  # Used if some virtual sensors / slots fail
 
     @property
     def successful_strategy_str(self) -> Union[str, None]:
         """Loop through strategies, return name of first successful strategy, or None if no strategy was successful.
         """
         if not self.success:
             return None
         for strategy_name, problem in self.sub_reports.items():
             if problem.success:
                 return strategy_name
         return None
 
-    def add_own(self, algo_problem: AlgoProblem):
-        lst = [] if self.own_problems is None else self.own_problems
-        lst.append(algo_problem)
+    def add_own(self, algo_problems: Union[AlgoProblem, List[AlgoProblem]]) -> None:
+        """Add "leaf" to problem tree: add 1 or more AlgoProblems to report.
+        """
+        # lst = [] if self.own_problems is None else self.own_problems
+        if algo_problems is None:
+            return
+        lst = self.own_problems or []
+        if not isinstance(algo_problems, list):
+            algo_problems = [algo_problems]
+        lst.extend(algo_problems)
         self.own_problems = lst
         self.success = False
 
-    def add_sub(self, strategy_name: str, problem_report: 'ProblemReport'):
-        dct = {} if self.sub_reports is None else self.sub_reports
-        dct.update({strategy_name: problem_report})
-        self.sub_reports = dct
+    def add_virtual(self, component: cmp.Component, slot_name: str, problem_report: 'ProblemReport') -> None:
+        """Add subtree of virtual sensor problems to `self.virtuals_reports`.
+        """
+        virtuals_dict = self.virtuals_reports or {}
+        virtuals_dict.update({(component, slot_name): problem_report})
+        self.virtuals_reports = virtuals_dict
+
+    def add_sub(self, strategy_name: str, problem_report: 'ProblemReport') -> None:
+        """Add subtree to problem tree: Add 1 ProblemReport subtree.
+        """
+        sub_dict = self.sub_reports or {}
+        sub_dict.update({strategy_name: problem_report})
+        self.sub_reports = sub_dict
         self.success = False
 
+    def add_missing_sensor(self, component: cmp.Component,
+                           slot_name: str,
+                           check_mode: AlgoCheckMode,
+                           enforce_real: bool = False) -> None:
+        """Add a "missing sensor" AlgoProblem as own problem. Set ProblemType & description depending on sensor / slot.
+        """
+        try:
+            is_virtual = component.sensor_slots[slot_name].virtual
+        except KeyError:
+            raise AlgorithmError(f'Error trying to add AlgoProblem: '
+                                 f'Component slot {slot_name} not found in component {component}.')
+        p_types = {IsVirtual.always: ProblemType.virtual_sensor_missing,
+                   IsVirtual.possible: ProblemType.real_or_virtual_sensor_missing,
+                   IsVirtual.never: ProblemType.real_sensor_missing}
+        descriptions = {IsVirtual.always: 'Virtual sensor is all-NaN',
+                        IsVirtual.possible: 'Real sensor missing or virtual sensor is all-NaN',
+                        IsVirtual.never: 'Real sensor missing'}
+        if is_virtual not in p_types.keys():
+            raise ValueError(f'Unexpected value of IsVirtual enum: "{is_virtual}".')
+
+        # Under certain circumstances, a calling calculation might strictly require a _real_ sensor to exist.
+        # E.g. CoreStrategy with feedthrough_real_sensor==True, like StrategyPowerFromSensor
+        if enforce_real:
+            is_virtual = IsVirtual.never
+
+        problem_type = p_types[is_virtual]
+        description = descriptions[is_virtual]
+        self.add_own(AlgoProblem(problem_type, component, slot_name, description))
+
+        # Specifically if component slot is virtual: Add subtree to problem tree
+        if slot_name not in component.sensors:
+            return
+        s = component.sensors[slot_name]
+
+        if s.is_virtual:
+            if check_mode is None:
+                raise AlgorithmError(f'Input "check_mode" required to treat a virtual sensor in problem reporting.')
+            add_vsensor = ((check_mode == AlgoCheckMode.config_and_data) or
+                           (check_mode == AlgoCheckMode.config_only and s._problems is not None))
+            if add_vsensor:
+                self.add_virtual(component, slot_name, s.problems)
+
+    def add_missing_attrib(self, component: Union[cmp.Component, cmp.CollectorType],
+                           attrib_name: str, description: str = None) -> None:
+        """Add a "missing attribute" AlgoProblem as own problem.
+        """
+        algo_problem = AlgoProblem(ProblemType.component_slot, component, attrib_name, description)
+        self.add_own(algo_problem)
+
+    def add_missing_collector(self, component: cmp.Component, slot_name: str) -> None:
+        """Add a "missing fluid" AlgoProblem as own problem. Set ProblemType & description.
+        """
+        algo_problem = AlgoProblem(ProblemType.component_attrib, component, slot_name,
+                                   'Collector type is None or UninitialisedCollectorType')
+        self.add_own(algo_problem)
+
+    def add_missing_fluid(self, component: cmp.Component, slot_name: str) -> None:
+        """Add a "missing fluid" AlgoProblem as own problem. Set ProblemType & description.
+        """
+        algo_problem = AlgoProblem(ProblemType.component_attrib, component, slot_name,
+                                   'Fluid is None or UninitialisedFluid')
+        self.add_own(algo_problem)
+
+    def add_missing_sensor_info(self, component: cmp.Component, slot_name: str = None,
+                                info_name: str = None, description: str = None) -> None:
+        """Add a "missing fluid" AlgoProblem as own problem. Set ProblemType & description.
+        """
+        if description is None:
+            if info_name is None:
+                raise AlgorithmError(f'"info_name" required to generate missing sensor info description.')
+            description = f'Sensor info "{info_name}" not found.'
+        algo_problem = AlgoProblem(ProblemType.sensor_info, component, slot_name, description)
+        self.add_own(algo_problem)
+
+    def add_generic_slot_problem(self, component: cmp.Component, description: str = None) -> None:
+        """Add a generic ProblemType.component_slot AlgoProblem as own problem
+        """
+        self.add_own(AlgoProblem(ProblemType.component_slot, component, description=description))
+
+    def parse_with_virtuals(self, include_successful_strategies: bool = False,
+                            include_problem_slots: bool = True) -> str:
+        s_report = self.parse(include_successful_strategies, include_problem_slots)
+        s_virtuals = self.parse_virtuals()
+        s_virtuals = '\n' + s_virtuals if s_virtuals else ''
+        return s_report + s_virtuals
+
     def parse(self, include_successful_strategies: bool = False, include_problem_slots: bool = True) -> str:
+        """Recursively parse a problem report into a string.
+        Virtual sensor problems (self.virtuals_report) are handled separately in `self.parse_virtuals`.
+        """
+
         def parse_problem(algo_problem: AlgoProblem) -> str:
-            result = f'- {algo_problem.problem_type.value}: '
+            if algo_problem is None:
+                return ''
+            sensor_problems = [ProblemType.real_sensor_missing,
+                               ProblemType.virtual_sensor_missing,
+                               ProblemType.real_or_virtual_sensor_missing]
+            if algo_problem.problem_type in sensor_problems:
+                result = '\n- '
+            else:
+                result = f'\n- {algo_problem.problem_type.value}: '
+            c = algo_problem.affected_component
+            if algo_problem.description is not None:
+                result += f'{algo_problem.description}: '
             if algo_problem.affected_item_name is not None:
-                # result += f'item "{algo_problem.affected_item_name}" '
-                result += f'"{algo_problem.affected_item_name}" '
+                if c is not None:
+                    result += f'"{c.__class__.__name__.lower()}.'
+                else:
+                    result += '"'
+                result += f'{algo_problem.affected_item_name}" '
             if algo_problem.affected_component is not None:
-                result += f'in {algo_problem.affected_component.__class__.__name__} "{algo_problem.affected_component.name}"'
-                # result += f'in component "{algo_problem.affected_component.name}"'
-            if algo_problem.description is not None:
-                result += f': {algo_problem.description}'
+                result += f'in {c.__class__.__name__.lower()} "{c.name}"'
             else:
                 result += '.'
-            result = '\n' + result if result else ''
             return result
 
         def parse_sub_reports(reports: Dict[str, 'ProblemReport']) -> str:
             # Recursive walk through the problem reports of all strategies (strategy name is dict key).
             result = ''
             for strategy_name, problem_report in reports.items():
                 include_slots = self.problem_slots and include_problem_slots
                 skip = problem_report.success and not include_successful_strategies and not include_slots
-                # if problem_report.success and include_successful_strategies:
                 if skip:
                     continue
                 if not problem_report.success:
                     sub = problem_report.parse(include_successful_strategies, include_problem_slots)
                 else:
                     if not self.problem_slots:
                         sub = ' No problems found.'
                     else:  # partial success, some virtual sensors missing
                         sub = f'Some virtual sensors could not be calculated: {", ".join(self.problem_slots)}. '
                         # if not problem_report.no_problems:
                         sub += problem_report.parse(include_successful_strategies, include_problem_slots)
                 result += '\n' if result else ''
-                result += f'Strategy "{strategy_name}":{sub}'
+                result += f'Strategy "{strategy_name}":'
+                result += sub
             return result
 
         result = ''
         if self.own_problems is not None:
             for algo_problem in self.own_problems:
                 result += parse_problem(algo_problem)
 
         if self.sub_reports is not None:
             result += parse_sub_reports(self.sub_reports)
 
         return result
 
+    def collect_virtual_reports(self) -> Dict[Tuple[Any, str], 'ProblemReport']:
+        """Recursively collect all virtual sensor problems in ProblemReport tree.
+        """
+        v_reports = {}
+        if self.virtuals_reports is not None:
+            v_reports.update(self.virtuals_reports)
+        if self.sub_reports is not None:
+            for sub_report in self.sub_reports.values():
+                v_reports.update(sub_report.collect_virtual_reports())
+
+        return v_reports
+
+    def parse_virtuals(self) -> str:
+        indent = '  '
+        result = ''
+        for k, v in self.collect_virtual_reports().items():
+            component, slot = k
+            result += (f'\n- Virtual sensor "{component.__class__.__name__.lower()}.{slot}" '
+                       f'in {component.__class__.__name__.lower()} "{component.name}":\n')
+            result += indent + v.parse().replace('\n', '\n' + indent)
+
+        return ('Virtual sensors:' + result) if result else ''
+
 
 # Goal = Report success / problems of a specific PC method strategy.
 @dataclass
 class PCMethodProblem:
     evaluation_mode: str
     equation: int
     wind_used: bool
```

## Comparing `sunpeek/core_methods/virtuals/algorithms.py` & `sunpeek/core_methods/virtuals/calculations.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 import numpy as np
 import scipy.signal
 import pvlib as pv
 from metpy.calc import dewpoint_from_relative_humidity
 
 import sunpeek.common.unit_uncertainty as uu
 from sunpeek.components import Plant, Array
-from sunpeek.serializable_models import ProblemType, AlgoProblem, ProblemReport
+from sunpeek.serializable_models import ProblemReport
 from sunpeek.core_methods.common.main import CoreAlgorithm, VirtualSensorStrategy, is_valid_fluid, is_valid_collector
 from sunpeek.common.errors import CalculationError
 import sunpeek.core_methods.virtuals.radiation as rd
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # Thermal Power
@@ -54,41 +54,39 @@
     def _calc(self):
         return {'tp': None}
 
     def _report_problems(self, check_mode):
         """Make sure real sensor 'tp' exists in Plant or Array.
         """
         r = ProblemReport()
-        if self.component.is_real_slot_missing('tp', check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_slot,
-                                  self.component, 'tp', 'Sensor is None or virtual.'))
+        slot = 'tp'
+        if self.component.is_real_slot_missing(slot, check_mode):
+            r.add_missing_sensor(self.component, slot, check_mode, enforce_real=True)
         return r
 
 
 # noinspection PyArgumentList
 class StrategyPowerFromVolumeFlow(VirtualSensorStrategy):
     """For Plant and Arrays, calculate thermal power from fluid, volume flow and inlet & outlet temperatures.
     """
     name = 'Power from volume flow'
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
         if not is_valid_fluid(self.component.fluid_solar, check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                  self.component, 'fluid_solar', 'Fluid is None or UninitialisedFluid.'))
+            r.add_missing_fluid(self.component, 'fluid_solar')
 
-        for slot_name in ['vf', 'te_in', 'te_out']:
-            if self.component.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot,
-                                      self.component, slot_name, 'Sensor missing.'))
+        for slot in ['vf', 'te_in', 'te_out']:
+            if self.component.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.component, slot, check_mode)
 
+        slot, info_name = 'vf', 'position'
         if not self.component.is_slot_missing('vf', check_mode):
-            if self.component.vf.is_info_missing('position'):
-                r.add_own(AlgoProblem(ProblemType.sensor_info,
-                                      affected_item_name='vf', description='Sensor info "position" not found.'))
+            if self.component.vf.is_info_missing(info_name):
+                r.add_missing_sensor_info(self.component, slot, info_name)
         return r
 
     def _calc(self):
         """
         Notes
         -----
         Position of volume flow sensor decides which temperature (inlet or outlet or a weighted average) is used for
@@ -130,24 +128,19 @@
     """For Plants and Arrays, calculate mass flow from fluid, thermal power and inlet & outlet temperatures.
     """
     name = 'Mass flow from thermal power'
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
         if not is_valid_fluid(self.component.fluid_solar, check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_attrib, self.component,
-                                  'fluid_solar', 'Fluid is None or UninitialisedFluid.'))
+            r.add_missing_fluid(self.component, 'fluid_solar')
 
-        for slot_name in ['tp', 'te_in', 'te_out']:
-            if self.component.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.component,
-                                      slot_name, 'Sensor missing.'))
-
-        if self.component.is_slot_missing('tp', check_mode):
-            r.add_sub(self.name, self.component.tp.problems)
+        for slot in ['tp', 'te_in', 'te_out']:
+            if self.component.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.component, slot, check_mode)
 
         return r
 
     def _calc(self):
         """
         Returns
         -------
@@ -170,26 +163,24 @@
     """For Plants and Arrays, calculate mass flow from fluid, thermal power and inlet & outlet temperatures.
     """
     name = 'Mass flow from volume flow'
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
         if not is_valid_fluid(self.component.fluid_solar, check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_attrib, self.component,
-                                  'fluid_solar', 'Fluid is None or UninitialisedFluid.'))
-
-        for slot_name in ['tp', 'te_in', 'te_out']:
-            if self.component.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.component,
-                                      slot_name, 'Sensor missing.'))
+            r.add_missing_fluid(self.component, 'fluid_solar')
 
-        if not self.component.is_slot_missing('vf', check_mode):
-            if self.component.vf.is_info_missing('position'):
-                r.add_own(AlgoProblem(ProblemType.sensor_info,
-                                      affected_item_name='vf', description='Sensor info "position" not found.'))
+        for slot in ['tp', 'te_in', 'te_out']:
+            if self.component.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.component, slot, check_mode)
+
+        slot, info_name = 'vf', 'position'
+        if not self.component.is_slot_missing(slot, check_mode):
+            if self.component.vf.is_info_missing(info_name):
+                r.add_missing_sensor_info(self.component, slot, info_name)
 
         return r
 
     def _calc(self):
         """
         Returns
         -------
@@ -225,15 +216,15 @@
 class StrategySolarPosition_pvlib(VirtualSensorStrategy):
     name = 'Solar position using pvlib'
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
         for attrib in ['latitude', 'longitude']:
             if self.component.is_attrib_missing(attrib):
-                r.add_own(AlgoProblem(ProblemType.component_attrib, self.component, attrib))
+                r.add_missing_attrib(self.component, attrib)
         return r
 
     def _calc(self):
         """Calculates solar angles (azimuth, elevation, zenith), based on pvlib.
         https://pvlib-python.readthedocs.io/en/stable/reference/generated/pvlib.solarposition.get_solarposition.html
 
         Returns
@@ -264,19 +255,14 @@
 
         return {'azimuth': uu.to_s(sol_pos['azimuth'], 'deg'),
                 'zenith': uu.to_s(sol_pos['zenith'], 'deg'),
                 'apparent_zenith': uu.to_s(sol_pos['apparent_zenith'], 'deg'),
                 'elevation': uu.to_s(sol_pos['elevation'], 'deg'),
                 'apparent_elevation': uu.to_s(sol_pos['apparent_elevation'], 'deg'),
                 }
-        # return uu.to_s(sol_pos['azimuth'], 'deg'), \
-        #     uu.to_s(sol_pos['zenith'], 'deg'), \
-        #     uu.to_s(sol_pos['apparent_zenith'], 'deg'), \
-        #     uu.to_s(sol_pos['elevation'], 'deg'), \
-        #     uu.to_s(sol_pos['apparent_elevation'], 'deg')
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # Dew Point Temperature
 
 # class DewPointTemperature(CoreAlgorithm):
 #     """Ambient dew point temperature for Plant.
@@ -311,18 +297,18 @@
 # class StrategyDewPointFromTemperatureHumidty(VirtualSensorStrategy):
 #     """Calculates ambient dew point temperature based on ambient temperature and ambient relative humidity of component.
 #     """
 #     name = 'Dew point temperature from air temperature and relative humidity'
 #
 #     def _report_problems(self, check_mode):
 #         r = ProblemReport()
-#         for slot_name in ['te_amb', 'rh_amb']:
-#             if self.component.is_slot_missing(slot_name, check_mode):
+#         for slot in ['te_amb', 'rh_amb']:
+#             if self.component.is_slot_missing(slot, check_mode):
 #                 r.add_own(AlgoProblem(ProblemType.component_slot,
-#                                       self.component, slot_name, 'Sensor missing.'))
+#                                       self.component, slot, 'Sensor missing.'))
 #         return r
 #
 #     def _calc(self):
 #         """Calculates ambient dew point temperature based on ambient temperature and ambient relative humidity of component.
 #
 #         Returns
 #         -------
@@ -471,18 +457,18 @@
 # class StrategyClearskyRadiation_pvlib(VirtualSensorStrategy):
 #     """For Plants and Arrays, calculate clearsky global horizontal irradiance and DNI using pvlib.
 #     """
 #     name = 'Clearsky radiation from pvlib'
 #
 #     def _report_problems(self, check_mode):
 #         r = ProblemReport()
-#         for slot_name in ['sun_apparent_zenith', 'abs_airmass', 'linke_turbidity', 'rd_dni_extra']:
-#             if self.component.is_slot_missing(slot_name, check_mode):
+#         for slot in ['sun_apparent_zenith', 'abs_airmass', 'linke_turbidity', 'rd_dni_extra']:
+#             if self.component.is_slot_missing(slot, check_mode):
 #                 r.add_own(AlgoProblem(ProblemType.component_slot,
-#                                       self.component, slot_name, 'Sensor missing.'))
+#                                       self.component, slot, 'Sensor missing.'))
 #         return r
 #
 #     def _calc(self):
 #         """Calculate clearsky global horizontal irradiance and DNI using pvlib.
 #         https://pvlib-python.readthedocs.io/en/stable/reference/generated/pvlib.clearsky.ineichen.html#pvlib.clearsky.ineichen
 #         Alternative models:
 #         https://pvlib-python.readthedocs.io/en/stable/reference/generated/pvlib.clearsky.haurwitz.html
@@ -577,51 +563,47 @@
 
 
 # noinspection PyArgumentList
 class StrategyTiltedIrradiance_feedthrough(VirtualSensorStrategy):
     """Array tilted irradiance components using only available real sensors, no radiation modeling.
     """
 
-    name = 'Feedthrough, uses only real sensors'
+    name = 'Feedthrough'
     feedthrough_real_sensor = True
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
         a = self.component
 
         input_pattern = rd.get_radiation_pattern(a)
         # global only
         if input_pattern == '1000':
-            r.add_own(AlgoProblem(ProblemType.component_slot, a,
-                                  description=f'Only global irradiance given, cannot calculate '
-                                              f'beam and diffuse irradiances.'))
+            r.add_generic_slot_problem(a, f'Only global irradiance given, cannot calculate '
+                                          f'beam and diffuse irradiances.')
             r.problem_slots.extend(['rd_bti', 'rd_dti'])
             r.success = True
 
         # beam + diffuse
         elif input_pattern == '0110':
-            r.add_own(AlgoProblem(ProblemType.component_slot, a,
-                                  description=f'Only beam and diffuse irradiances given, cannot calculate '
-                                              f'global irradiance.'))
+            r.add_generic_slot_problem(a, f'Only beam and diffuse irradiances given, cannot calculate '
+                                          f'global irradiance.')
             r.problem_slots.extend(['rd_gti'])
             r.success = True
 
         # global + beam + diffuse
         elif input_pattern in ['1110', '1111']:
             pass  # all good, nothing missing
 
         else:
-            r.add_own(AlgoProblem(ProblemType.component_slot, a,
-                                  description=f'Invalid radiation input pattern {input_pattern}.'))
+            r.add_generic_slot_problem(a, f'Invalid radiation input pattern {input_pattern}')
 
         if not rd.same_orientation(a, a.in_global, a.in_beam, a.in_diffuse):
-            r.add_own(AlgoProblem(ProblemType.sensor_info, a,
-                                  description='For feedthrough strategy, '
-                                              'array radiations "in_global", "in_beam", "in_diffuse" must have same '
-                                              'orientation as the array and among themselves.'))
+            r.add_missing_sensor_info(a, description='Array irradiances '
+                                                     '"in_global", "in_beam", "in_diffuse" must have same '
+                                                     'orientation as the array and among themselves')
         return r
 
     def _calc(self):
         """Returns global, beam, diffuse irradiances on array, only if input sensor and array orientations match.
         Does not do any further calculations like applying radiation models.
         Returns
         -------
@@ -735,26 +717,27 @@
         iam = a.collector_type.iam_method.get_iam(aoi=a.aoi.data,
                                                   azimuth_diff=p.sun_azimuth.data - a.azim)
         return {'iam': iam}
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
         if not is_valid_collector(self.component.collector_type, check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                  self.component, 'collector_type',
-                                  'Collector type is None or UninitialisedCollectorType.'))
-
-        if self.component.is_slot_missing('aoi', check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_slot, self.component, 'aoi'))
-
-        if self.component.is_attrib_missing('azim'):
-            r.add_own(AlgoProblem(ProblemType.component_attrib, self.component, 'azim'))
+            r.add_missing_collector(self.component, 'collector_type')
 
-        if self.plant.is_slot_missing('sun_azimuth', check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_slot, self.plant.name, 'sun_azimuth'))
+        slot = 'aoi'
+        if self.component.is_slot_missing(slot, check_mode):
+            r.add_missing_sensor(self.component, slot, check_mode)
+
+        attrib = 'azim'
+        if self.component.is_attrib_missing(attrib):
+            r.add_missing_attrib(self.component, attrib)
+
+        slot = 'sun_azimuth'
+        if self.plant.is_slot_missing(slot, check_mode):
+            r.add_missing_sensor(self.plant, slot, check_mode)
 
         return r
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # Angle of Incidence
 
@@ -789,21 +772,21 @@
                                 surface_azimuth=a.azim.m_as('deg'),
                                 solar_zenith=p.sun_zenith.m_as('deg'),
                                 solar_azimuth=p.sun_azimuth.m_as('deg'))
         return {'aoi': uu.to_s(aoi, 'deg')}
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
-        for slot_name in ['sun_zenith', 'sun_azimuth']:
-            if self.plant.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.plant.name, slot_name))
-
-        for slot_name in ['tilt', 'azim']:
-            if self.component.is_attrib_missing(slot_name):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.component, slot_name))
+        for slot in ['sun_zenith', 'sun_azimuth']:
+            if self.plant.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.plant, slot, check_mode)
+
+        for attrib in ['tilt', 'azim']:
+            if self.component.is_attrib_missing(attrib):
+                r.add_missing_attrib(self.component, attrib)
 
         return r
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # Internal Shading
 
@@ -911,34 +894,32 @@
                 'internal_shading_ratio': internal_shading_ratio,
                 'shadow_angle': shadow_angle,
                 'shadow_angle_midpoint': shadow_angle_midpoint,
                 }
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
-        for slot_name in ['sun_zenith', 'sun_azimuth']:
-            if self.plant.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.plant.name, slot_name))
-
-        for slot_name in ['aoi']:
-            if self.component.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.component, slot_name))
-
-        for attrib_name in ['tilt', 'azim', 'row_spacing']:
-            if self.component.is_attrib_missing(attrib_name):
-                r.add_own(AlgoProblem(ProblemType.component_attrib, self.component, attrib_name))
+        for slot in ['sun_zenith', 'sun_azimuth']:
+            if self.plant.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.plant, slot, check_mode)
+
+        slot = 'aoi'
+        if self.component.is_slot_missing(slot, check_mode):
+            r.add_missing_sensor(self.component, slot, check_mode)
+
+        for attrib in ['tilt', 'azim', 'row_spacing']:
+            if self.component.is_attrib_missing(attrib):
+                r.add_missing_attrib(self.component, attrib)
 
         if not is_valid_collector(self.component.collector_type, check_mode):
-            r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                  self.component, 'collector_type',
-                                  'Collector type is None or UninitialisedCollectorType.'))
+            r.add_missing_collector(self.component, 'collector_type')
         else:
-            if self.component.collector_type.is_attrib_missing('gross_length'):
-                r.add_own(AlgoProblem(ProblemType.component_attrib,
-                                      self.component.collector_type, 'gross_length'))
+            attrib = 'gross_length'
+            if self.component.collector_type.is_attrib_missing(attrib):
+                r.add_missing_attrib(self.component.collector_type, attrib)
 
         return r
 
 
 # ----------------------------------------------------------------------------------------------------------------------
 # Array Temperatures and Temperature Derivatives
 
@@ -996,17 +977,17 @@
 
         return {'te_op': uu.to_s(te_op, 'K'),
                 'te_op_deriv': uu.to_s(te_op_deriv_final, 'K s**-1'),
                 }
 
     def _report_problems(self, check_mode):
         r = ProblemReport()
-        for slot_name in ['te_in', 'te_out']:
-            if self.component.is_slot_missing(slot_name, check_mode):
-                r.add_own(AlgoProblem(ProblemType.component_slot, self.component, slot_name))
+        for slot in ['te_in', 'te_out']:
+            if self.component.is_slot_missing(slot, check_mode):
+                r.add_missing_sensor(self.component, slot, check_mode)
 
         return r
 
 
 def _get_weighted_temperature(te1, te2, w1=0.5, w2=0.5):
     """Return weighted average between temperature pd.Series te1 and te2.
     Takes care of converting things to K before doing the weighting. Result will be unit-aware pd.Series in degC.
```

## Comparing `sunpeek-0.3.6.dist-info/COPYING.LESSER` & `sunpeek-0.3.7.dist-info/COPYING.LESSER`

 * *Files identical despite different names*

## Comparing `sunpeek-0.3.6.dist-info/METADATA` & `sunpeek-0.3.7.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sunpeek
-Version: 0.3.6
+Version: 0.3.7
 Summary: Large Solar Thermal Monitoring Tool. Implements the Performance Check Method of ISO 24194
 Home-page: https://gitlab.com/sunpeek/sunpeek
 License: LGPL-3.0-only
 Keywords: solarthermal,solar,energy,monitoring
 Author: Philip Ohnewein, Daniel Tschopp, Lukas Feierl, Marnoch Hamilton-Jones, Jonathan Cazco
 Maintainer: Marnoch Hamilton-Jones
 Maintainer-email: m.hamilton-jones@aee.at
```

## Comparing `sunpeek-0.3.6.dist-info/COPYING` & `sunpeek-0.3.7.dist-info/COPYING`

 * *Files identical despite different names*

## Comparing `sunpeek-0.3.6.dist-info/RECORD` & `sunpeek-0.3.7.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,54 +1,54 @@
 sunpeek/__init__.py,sha256=3OVGGe7fF52quxTfpeGZ9WLlVZ9wc3BK7sWngF73KpM,1035
 sunpeek/api/__init__.py,sha256=6D8BHGZVV1B9mw90ii9DPj8aqgk7T2uGcMSJgpcVgrY,264
 sunpeek/api/dependencies.py,sha256=_JRAjCRDF3hV8Bfyq6E2MD8gYhojSekgJRMTka_-Qp8,581
-sunpeek/api/main.py,sha256=18QVCvCt4s3lJjmShRGYsvuI5t53-j0yZEyXlLVZWvc,7949
+sunpeek/api/main.py,sha256=jtQvbJAgDp_923egR15L7xLTo_j0Omwggb50PNYziqc,7986
 sunpeek/api/routers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sunpeek/api/routers/api_jobs.py,sha256=ow_AdoC04SyibS7enKsD4Cq3aNRfJIY6tLdLEgxEuU4,1718
 sunpeek/api/routers/config.py,sha256=5QTn7dvwiYFnMvn30HWSe9YLDt0IMupTIiSlL5aRx0M,6312
-sunpeek/api/routers/evaluations.py,sha256=9N5SnEhykB69m2LNr4auNeFbIgUydXIIGRMG7wPcc1o,5513
+sunpeek/api/routers/evaluations.py,sha256=-eSj6hLG70L6Y42NbHqCQVgAuDih_dlvQ_2VV_IjCSA,6090
 sunpeek/api/routers/files.py,sha256=ZViDGFt1FqX7h_bm7_fK44oaM4AIo8ZXk6V28mPqKAg,6582
 sunpeek/api/routers/helper.py,sha256=VbxR96aCsbzuKS7mG3tLeTC8Bb8yPNnPK4n8ssBXkN4,245
 sunpeek/api/routers/plant.py,sha256=vBsWmZSGfx-f5QiCW5vg81j-FX5lmgDMGXoUG_T3Cc0,19263
 sunpeek/base_model.py,sha256=v3tIRStkycYr5uYReaQ7VDztTRFw0Js6j9hNtUDGUyc,780
 sunpeek/common/__init__.py,sha256=WVUQ1PQnwc5lHNsQm0dnkXsUfmgfC8qC9UEgpUKnE_E,100
 sunpeek/common/common_units.py,sha256=DPykzkJEX8oGql7iw6ZK6kiI5rsoIHrR3KCXydqPbRc,1248
 sunpeek/common/config_parser.py,sha256=NfKIR2a9abhPxQI52UFLm_R1o9s_IDu1-mc39PI86no,1968
 sunpeek/common/errors.py,sha256=lASviLRJhtDEdro41Lj__Br4sYp5EG89u2iNVoRaXuk,1802
 sunpeek/common/time_zone.py,sha256=q73QtB4gBxuCDqnO6yxtWYUNXE2nm6ydFpmyL6Gy7iM,6639
 sunpeek/common/unit_uncertainty.py,sha256=355iPUVFtlFDASsezyT_58GUWXD8dIJ5PZPne1HJ20s,17863
 sunpeek/common/utils.py,sha256=nJzOZhtgm95C1DA3H53pjKm6OU-9Bx9LX2Dsy96m3Tw,5134
 sunpeek/components/__init__.py,sha256=ffw2cp0QyLk9YEzjPPI2igVO-YU7SzkbfOv0WsUGtD4,986
-sunpeek/components/base.py,sha256=ftMIv1luBZMoNgrRxDaG3M1PpagPQE6A9esPpId49Pk,13435
+sunpeek/components/base.py,sha256=7UC_Z1WaNMV-kts3UUpgkGx42JOURepzqg6BpXQXrEw,13697
 sunpeek/components/components_factories.py,sha256=nDQSyiCUw-3PQqm4T0ItRf6h9p25Q52XUCtooitQnK0,2800
 sunpeek/components/fluids.py,sha256=FpYwEOauBJJhrnxBnIVAQ4QGs8jvs8c9Jyjr3Tx56ig,26948
 sunpeek/components/fluids_wpd_models.py,sha256=dU685R5VBey42l1tlPqb82xiIEQwi4MbvSsxXL-TqFg,14800
 sunpeek/components/helpers.py,sha256=hKgEg1Uhn4tmM9ZOwlcQ9RqETWNNSPdy850LwogHCkw,14886
 sunpeek/components/iam_methods.py,sha256=qKV1RT4TpEK2qoEcJxMnd9i5Yu0Nf2gtfsMEAg-8V8g,15784
 sunpeek/components/jobs.py,sha256=iYU2KpDCFZJVcJkMISPctC8c5yAzECKleoqK5Pn0o9U,674
 sunpeek/components/operational_events.py,sha256=mKT8QamEfXYLIclwGJeXUqG44zozruGg560XHvM8rfU,3804
-sunpeek/components/physical.py,sha256=sFLuxpxxhtrSEGxdefFho0qpyv05HH92QcxAwjZeIDM,49882
+sunpeek/components/physical.py,sha256=VWbUxUi8VMmdiKPuh8F-AYpNS2ViHJ3VYn8k7nfIPZo,49813
 sunpeek/components/results.py,sha256=_sNDJbwHgTl-f7f-tP7Rr9NgjGde_EwXgL-kTUSTo-g,3075
-sunpeek/components/sensor.py,sha256=7enxAzMgWxlBCbJLntZeflYyk6lIi_uwIM-t4m3DXlU,23359
+sunpeek/components/sensor.py,sha256=rPdkDFbQYkWGlOuNNqDMhgdhKaHV8GYkuhI7moY6380,23308
 sunpeek/components/sensor_types.py,sha256=cgj-J4kO31VXjNY8w1k8mBT6OPFEG0prZMd4AgvqWlU,11412
 sunpeek/components/types.py,sha256=uMomU9P1ZitOE5MYaxkHb1f41Mn8BoMkMKuaH7EvJiw,20337
 sunpeek/core_methods/__init__.py,sha256=Js-UR8fqFyHIkPCX_2XQX-rGLPRb-AzkElBEK57nz2w,87
 sunpeek/core_methods/common/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-sunpeek/core_methods/common/main.py,sha256=QgYX34ZGWiOniEpaIGB7bA0pHO_WYLJvDwsdAtxExLs,13669
+sunpeek/core_methods/common/main.py,sha256=bDba3S60SBmHmyuuYMb5-Uw0WxIaoXp3Cr5QbX7AEao,13751
 sunpeek/core_methods/pc_method/__init__.py,sha256=ay7JztMWmxBEb2U-cuKdL7-UKcX6Xat3slqhpS27mGA,4570
-sunpeek/core_methods/pc_method/equation.py,sha256=3MvA4_plpzxkGO6P8PmeSMnV6VX07AqE8FT4RE7C358,15126
-sunpeek/core_methods/pc_method/main.py,sha256=S6XRoKVWZp95L9lMGWvzKROiq1s8tBDxadxd5Hk9bCw,31604
+sunpeek/core_methods/pc_method/equation.py,sha256=Ygj68Lz47FkeUEYflEWtc31AFyNWdcczKMdupDy2_WM,14730
+sunpeek/core_methods/pc_method/main.py,sha256=Yhgu2bQTwU2sX7ZiYVNt1QLChe4fuDu7oSzqYxZddww,31591
 sunpeek/core_methods/pc_method/plotting.py,sha256=hln6QFu7ShcsK___zIwczjdPPoO3X7MmawlJHhmjqos,22617
-sunpeek/core_methods/pc_method/wrapper.py,sha256=f8s1ezFJlRuOpGfuM9RQZQV4y7oLmrTyuT5QYixUZ2s,10781
+sunpeek/core_methods/pc_method/wrapper.py,sha256=nxgvDk3ML8_ciINrN4qh8-kUrSzUYZjtEzmi3TQVibs,10738
 sunpeek/core_methods/virtuals/__init__.py,sha256=Mabq_yA70c9I63nDY8A63jyw8PMShe3f6X4QzqRDoGg,83
-sunpeek/core_methods/virtuals/algorithms.py,sha256=yLyBZv5HYRplmjmMIbeWeZY6U4kpm5-IE9C-gpYyPuA,41535
-sunpeek/core_methods/virtuals/main.py,sha256=S0H_ZqV_-FnfQapvxJeK830h8urixmQePwYs3EgyaaE,4224
+sunpeek/core_methods/virtuals/calculations.py,sha256=jCc_3W4Uzu_B9op91-mtXNFmoyVjtUi4Zz_nk9B8rks,39360
+sunpeek/core_methods/virtuals/main.py,sha256=jaEHDbS0Hn_rWG4FpMySs-K0yWLCsNSMnAb_kNfdvWM,4202
 sunpeek/core_methods/virtuals/radiation.py,sha256=rzDZaA8pldmxuF1oZJ6N_eUtYud52XjglnENH2mA5jQ,35090
-sunpeek/core_methods/virtuals/virtuals_array.py,sha256=FAepbbwe8gnAN706f4SW58hAfmP4qUzyY-pfLVwry0A,3449
-sunpeek/core_methods/virtuals/virtuals_plant.py,sha256=h2XEqneBqVM6iyFBHd0B8XL0QUsfI7EmzCwDge5_T4M,3868
+sunpeek/core_methods/virtuals/virtuals_array.py,sha256=yvlsjC7hs8FZqRitEvY5YXxnusYBUFf43Gx-pZ1D1a0,3446
+sunpeek/core_methods/virtuals/virtuals_plant.py,sha256=SOCH8vMbcCuuZNovIC8Gtt-qLYCyS1T6B6w9okxgMOk,3773
 sunpeek/data_handling/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sunpeek/data_handling/context.py,sha256=tmCD7YSGLvHbIvf2poXpIBrcZ0cU6COyeigxruJRHV0,23667
 sunpeek/data_handling/data_uploader.py,sha256=4qcdfI9yVVYVAnbohe-_kDVqL8m0mlMLepVXuEls0oc,24335
 sunpeek/data_handling/wrapper.py,sha256=DqTzGs5afZZuSng6azWTOD2qMzXbsOIsD4jTTKCobVo,1849
 sunpeek/db_utils/__init__.py,sha256=btLFbporMPPB8l8OvHVb7D4ZwQHd0nj0Tfgj0eOGqfg,25
 sunpeek/db_utils/crud.py,sha256=xhY0jRRGtinnVwYzdwKuBYVifXjF_M_Fdj6NgOEJEvo,5593
 sunpeek/db_utils/db_data_operations.py,sha256=kyqkWnCGLQETmhj_PPY-ahzCgJZAErYq2fb87PSirXc,16575
@@ -62,13 +62,13 @@
 sunpeek/definitions/fluid_data/Wocklum Thermum P/density.csv,sha256=rb1uk1d9bj3MdDQfWb1-YcxhC_RZ7mjhNAdSoHn7XZ8,3450
 sunpeek/definitions/fluid_data/Wocklum Thermum P/heat capacity.csv,sha256=F-IZeYyL2U3rww2tTP1qRWH0bCY3FhGY7f9-FtlvZ_w,2532
 sunpeek/definitions/fluid_definitions.py,sha256=Qry_kWr-cHKEnEbKl9WolUiAJ9g2NzO-rnmIVNpJ2lI,33003
 sunpeek/demo/__init__.py,sha256=djMLgvrYODa5bcBr2KnbPZ37s1yO_3igMAEYNXp_iPQ,528
 sunpeek/demo/demo_plant.py,sha256=tVfvaM7wa2bWLIeZxwpykS0HHxPsoxXthU9zfwJV6Gs,1902
 sunpeek/demo/demo_plant_script.py,sha256=ifWIWRvLTA-IYaTfM-BGZc6mnh15A3-SOwFTs2ehKuE,5168
 sunpeek/exporter.py,sha256=okT1A2hiRjtu-usUAnl5Oq84bIMrkvMuSvTYCitlhGs,6191
-sunpeek/serializable_models.py,sha256=I_GnCQZd7qDmk4n3sobRnfQdIrYl71pLg4Q-c3Bz2Z4,22210
-sunpeek-0.3.6.dist-info/COPYING.LESSER,sha256=46mU2C5kSwOnkqkw9XQAJlhBL2JAf1_uCD8lVcXyMRg,7652
-sunpeek-0.3.6.dist-info/METADATA,sha256=GLtObydQuXk_tvgZVr8A7gnL9rj1A73v5GSaoBjSGPM,15186
-sunpeek-0.3.6.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
-sunpeek-0.3.6.dist-info/COPYING,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
-sunpeek-0.3.6.dist-info/RECORD,,
+sunpeek/serializable_models.py,sha256=-TX_mWUp0TscHx266DP1vLZaGWApsswSbP2owWoJ34U,31339
+sunpeek-0.3.7.dist-info/COPYING.LESSER,sha256=46mU2C5kSwOnkqkw9XQAJlhBL2JAf1_uCD8lVcXyMRg,7652
+sunpeek-0.3.7.dist-info/METADATA,sha256=zmzzWiYlGJa38RbcLpArZk1u5pTp4oyeDaOjNngDX-Q,15186
+sunpeek-0.3.7.dist-info/WHEEL,sha256=vVCvjcmxuUltf8cYhJ0sJMRDLr1XsPuxEId8YDzbyCY,88
+sunpeek-0.3.7.dist-info/COPYING,sha256=OXLcl0T2SZ8Pmy2_dmlvKuetivmyPd5m1q-Gyd-zaYY,35149
+sunpeek-0.3.7.dist-info/RECORD,,
```

